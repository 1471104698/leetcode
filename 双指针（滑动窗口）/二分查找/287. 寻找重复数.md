## [287. 寻找重复数](https://leetcode-cn.com/problems/find-the-duplicate-number/)

*![image.png](https://pic.leetcode-cn.com/a4416750f53893d90fb6d9fb055648e2248ce9eda96e72b4826bac909e08e0d4-image.png)*

## 题意描述

给定一个数组，有 n + 1 个元素，但是它的元素范围为 [1, n]

那么这就意味着数组内必定存在一个重复数

**说明：**

不能更改原数组（假设数组是只读的）。
只能使用额外的 O(1) 的空间。
时间复杂度小于 O(n2) 。
**数组中只有一个重复的数字，但它可能不止重复出现一次。**





## **示例 1:**

```java
输入: [1,3,4,2,2]
输出: 2
```



## **示例 2:**

```java
输入: [3,1,3,4,2]
输出: 3
```



## 方法①、二分查找

### 实现思路

n + 1 个元素的数组，所有元素数值范围为 [1, n]

那么必定存在一个重复的元素，但是重复元素出现次数不一定为 2

即不一定 [1, n] 所有元素都出现过，即可能 `nums = [2,3,3,3]`



假设 n = 10

如果不出现重复，那么出现在 范围 [1, 5] 内的元素必须只有 5 个，刚好占 [1,2,3,4,5] 5 个位置

而出现在 [6, 10] 范围内的数同样只能有 5 个，当超过 5 个时，表示必定该范围内存在重复值

可能有的会说某个范围内出现重复值，但是它的个数不超过边界长度，那么可能吗？

比如 n = 10，并且 [1, 5] 范围内的元素为 [5,5,5,5,5] 刚好 5 个

 那么我们看右边，由于左边已经存在了重复值，那么意味着右边不会存在重复值，那么右边就是 [6,7,8,9,10]

但是这时候只有 10 个元素，但数组实际上有 n + 1，即 11 个元素

由于右边不存在重复值，那么右边就塞不下了，那么就只能放在存在重复值的左边了

因此超出边界长度的部分必定存在重复值



时间复杂度 `O(nlogn)`:二分 [1, n] `O(logn)`，内部遍历数组统计元素个数 `O(n)`

空间复杂度：`O(1)`

由于要求空间复杂度 `O(1)`，因此我们不能预处理记录各个元素出现个数

如果不要求 `O(1)` 空间，那么我们可以将时间复杂度缩减为 `O(n) + O(logn)`



### 实现代码

```java
class Solution {
    public int findDuplicate(int[] nums) {
        int n = nums.length;
        int left = 1;
        int right = n;
        while(left < right){
            int mid = (left + right) >>> 1;
            //我们计算 [left, mid] 范围内元素个数
            int count = 0;
            for(int num : nums){
                if(num >= left && num <= mid){
                    count++;
                }
            }
            int len = mid - left + 1;
            if(count <= len){
                left = mid + 1;
            }else{
                right = mid;
            }
        }
        return left;
    }
}
```


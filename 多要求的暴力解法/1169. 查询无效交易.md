## **[1169. 查询无效交易](https://leetcode-cn.com/problems/invalid-transactions/)**

```java
如果出现下述两种情况，交易 可能无效：

交易金额超过 ¥1000
或者，它和另一个城市中同名的另一笔交易相隔不超过 60 分钟（包含 60 分钟整）
每个交易字符串 transactions[i] 由一些用逗号分隔的值组成，这些值分别表示交易的名称，时间（以分钟计），金额以及城市。

给你一份交易清单 transactions，返回可能无效的交易列表。你可以按任何顺序返回答案。

提示：

transactions.length <= 1000
每笔交易 transactions[i] 按 "{name},{time},{amount},{city}" 的格式进行记录
每个交易名称 {name} 和城市 {city} 都由小写英文字母组成，长度在 1 到 10 之间
每个交易时间 {time} 由一些数字组成，表示一个 0 到 1000 之间的整数
每笔交易金额 {amount} 由一些数字组成，表示一个 0 到 2000 之间的整数
```





## **示例 1：**

```java
输入：transactions = ["alice,20,800,mtv","alice,50,100,beijing"]
输出：["alice,20,800,mtv","alice,50,100,beijing"]
解释：第一笔交易是无效的，因为第二笔交易和它间隔不超过 60 分钟、名称相同且发生在不同的城市。同样，第二笔交易也是无效的。
```





## **示例 2：**

```java
输入：transactions = ["alice,20,800,mtv","alice,50,1200,mtv"]
输出：["alice,50,1200,mtv"]
```





## **示例 3：**

```java
输入：transactions = ["alice,20,800,mtv","bob,50,1200,mtv"]
输出：["bob,50,1200,mtv"]
```





## **实现思路**

```java
            1、交易金额超过 1000 的无效
            2、不同城市但交易名称相同，时间不超过 60 分钟的无效
            3、只要相同城市，即使 交易名称相同 且 不超过 60 分钟，也是有效的

            暴力解法：
			字符串通过 "," 进行拆分为四个块
            然后 O(n^2) 查找判断
```





## **实现代码**

```java
class Solution {
    public List<String> invalidTransactions(String[] transactions) {
        /*
            1、交易金额超过 1000 的无效
            2、不同城市但交易名称相同，时间不超过 60 分钟的无效
            3、只要相同城市，即使 交易名称相同 且 不超过 60 分钟，也是有效的

            暴力解法
        */

        int len = transactions.length;
        String[][] strs = new String[len][4];
        for(int i = 0; i < len; i++){
            strs[i] = transactions[i].split(",");
        }

        List<String> res = new ArrayList<>();

        /*
        记录是否已经访问过了
        目的：当我们查询 第 i 个交易是否无效的时候，需要跟 第 j 个交易进行对比
             当发现 第 i 个交易 和 第 j 个交易 两个满足无效交易，那么我们 添加 第 i 个交易 的时候也可以同时添加第 j 个交易，因为都无效了
             这样就无需在后面再去判断 第 j 个交易是否无效了
             这样我们就需要一个 boolean 数组来判断是否访问过
        */
        boolean[] visited = new boolean[len];
        for(int i = 0; i < len; i++){
            //已访问过，跳过
            if(visited[i]){
                continue;
            }
            //交易额超过 1000，添加，设置为已访问，跳过
            if(Integer.parseInt(strs[i][2]) > 1000){
                res.add(transactions[i]);
                visited[i] = true;
                continue;
            }
            for(int j = 0; j < len; j++){
                if(i == j){
                    continue;
                }
                //名字相同，时间不超过 60 分钟，并且不在同一城市
                if(strs[i][0].equals(strs[j][0]) && Math.abs(Integer.parseInt(strs[i][1]) - Integer.parseInt(strs[j][1])) <= 60
                    && !strs[i][3].equals(strs[j][3])){
                    visited[i] = true;
                    res.add(transactions[i]);
                    //第 j 个交易没访问过才进行添加，否则可能会重复添加
                    if(!visited[j]){
                        visited[j] = true;
                        res.add(transactions[j]);
                    }
                    break;
                }
            }
        }
        return res;
    }
}
```


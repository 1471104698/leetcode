# [字节常考题：440. 字典序的第K小数字](https://leetcode-cn.com/problems/k-th-smallest-in-lexicographical-order/)

*![image.png](https://pic.leetcode-cn.com/55d14fa47859c2d4f3889ad5c3593e9d5ae5b8b652273ab9d77f7eb7d3cc39ad-image.png)*

```java
给定整数 n 和 k，找到 1 到 n 中字典序第 k 小的数字。

注意：1 ≤ k ≤ n ≤ 109。
```



## **示例 :**

```java
输入:
n: 13   k: 2

输出:
10

解释:
字典序的排列是 [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9]，所以第二小的数字是 10。
```





## 方法①、优先队列（超时）



### 实现思路

```java
维护一个大顶堆
直接将 [1, n] 转换为字符串添加进优先队列，维护一个 k 个大小的大顶堆
最终返回堆顶元素
```



### 实现代码

```java
class Solution {
    public int findKthNumber(int n, int k) {
        PriorityQueue<String> maxHeap = new PriorityQueue<>((a, b) -> b.compareTo(a));
        for(int i = 1; i <= n; i++){
            maxHeap.add(String.valueOf(i));
            if(maxHeap.size() > k){
                maxHeap.poll();
            }
        }
        return Integer.parseInt(maxHeap.peek());
    }
}
```





## 方法②、十叉树



### 实现思路



#### 十叉树建模：

<img src="https://pic.leetcode-cn.com/2d29fc99e0e23eac3bd5a25997ffc111694e1024d24a62677decb89e15f6dfce-file_1568710778725" style="zoom:150%;" />



本题跟 386. 字典序排数 差不多，不过 386 题的数据量较小，只有 5,000,000，即 1e6
因此可以直接添加排序

而本题数据量最大为 1e9
采用 方法① 的思路，将 [1, n] 全部添加排序，再求出第 k 个的话肯定超时
因此，我们需要跟 60. 第k个排列 一样，不是求出所有的，而是通过技巧直接定位到 第 k 个



#### 1、确定某个前缀下的子节点数：

这里说下，前缀就是指比如 1100，它的前缀有 1，11，110
我们求取某个前缀下的子节点个数，意思就是 比如 求取 10 为前缀的子节点的个数（它子节点有 101，102，1001 之类的）

怎么获取某个前缀的子节点个数？
可以用过下一个前缀的起点 - 当前前缀的起点（注意：起点不是子节点）
比如：
我们求取 1 为前缀的子节点的个数
那么存在以下代码

```java
public int getCount(int prefix){
    int cur = prefix;
    int next = prefix + 1;
    int c = 0;
    while(cur <= n){
    /*
    	最开始 cur = 1，next = 2
    	那么该层以 1 为前缀的子节点个数为 2 - 1 = 1
    	然后 cur * 10 ，next * 10， 
    	cur = 10, next = 20
    	那么该层以 1 为前缀的子节点的个数为 20 - 10 = 10
    	然后 cur * 10 ，next * 10， 
    	cur = 100, next = 200
    	那么该层以 1 为前缀的子节点的个数为 200 - 100 = 100
    	
    	直到 cur > n 位置停止循环
    	
    	最开始 cur = 12，next = 13
    	那么该层以 12 为前缀的子节点个数为 13 - 12 = 1
    	然后 cur * 10 ，next * 10， 
    	cur = 120, next = 130
    	那么该层以 12 为前缀的子节点的个数为 130 - 120 = 10
    	然后 cur * 10 ，next * 10， 
    	cur = 1200, next = 1300
    	那么该层以 1 为前缀的子节点的个数为 1300 - 1200 = 100
    */
        c += next - cur;
        next *= 10;
        cur *= 10;
    }
    return c;0
}
```

但上面存在问题，我们上面求取的是每层以 1 作为前缀的子节点的个数，是一层一层求的，
比如 第三层，最小的数为 100，最大的数为 199，那么我们通过 200 - 100，可以得到这 100 个数
但是，如果 next 超过了 n 呢？比如 cur = 100, next = 200, n = 150，实际上只有 100 - 150 这 50 个数
但是如果使用 200 - 100 的话，就有 200 个数，因此我们需要在 next 和 n 之间取最小值 Math.min(next, n + 1);
注意，这里是 n + 1，而不是 n，因为如果是 n 的话，n - 100 表示不包含 n 这个数，就跟上面的 200 - 100 不包含 200 这个数
因此我们需要使用 n + 1 - cur 才会包含 n 这个数

```java
public int getCount(int prefix){
    int cur = prefix;
    int next = prefix + 1;
    int c = 0;
    while(cur <= n){
        c += Math.min(next, n + 1) - cur;
        next *= 10;
        cur *= 10;
    }
    return c;
}
```



#### 2、确定 k 在哪个前缀下

如果 prefix 的子节点个数为 count 
存在 count < k，那么不在当前前缀下，那么 prefix++
存在 count >= k，那么在当前前缀下，缩小范围，prefix *= 10




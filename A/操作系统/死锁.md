# 死锁

## 1、死锁的产生

> ### 举个例子

假设我们有一把蓝钥匙，可以打开一扇蓝色的门；以及一把红钥匙，可以打开一扇红色的门。

两把钥匙被保存在一个皮箱里。

同时我们定义六种行为：获取蓝钥匙，打开蓝色门，归还蓝钥匙，获取红钥匙，打开红色门，归还红钥匙。

![img](https://pic1.zhimg.com/80/v2-823088df49d849ebbcb52739ec20333b_720w.jpg)



获取蓝钥匙，打开蓝色门，归还蓝钥匙 应该保证相对顺序

获取红钥匙，打开红色门，归还红钥匙 应该保证相对顺序



那么一共有 20 种情况（![[公式]](https://www.zhihu.com/equation?tex=A_%7B6%7D%5E%7B6%7D%2F%28A_%7B3%7D%5E%7B3%7D%2AA_%7B3%7D%5E%7B3%7D%29)），我们任取 6 种

![img](https://pic1.zhimg.com/80/v2-1a3491eb9bcf99612863a4be404e57f4_720w.jpg)



假设线程 A 和 线程 B 都有一个任务，就是需要打开蓝色门和红色门，它们的指令安排是这样的：（解法 3 和 解法 4）

![img](https://picb.zhimg.com/80/v2-021292616c89207b9868f3991be7d699_720w.jpg)

线程 A 获取 蓝色钥匙，打开蓝色门，阻塞等待红色钥匙，线程 B 获取红色钥匙打开红色门，归还红色钥匙，阻塞 等待蓝色钥匙

线程 B 获取红色钥匙，打开红色门，归还红色钥匙，再归还蓝色钥匙，这样线程 B 获取蓝色钥匙，完成后续指令

一切都是这么的顺利，无死锁发生



但是，如果选取 解法 3 和 解法 5

![img](https://picb.zhimg.com/80/v2-4423d2645e0d0ef610cf63d34013792d_720w.jpg)



线程 A 在持有 蓝色钥匙的情况下阻塞等待获取红色钥匙，线程 B 在持有红色钥匙的情况下阻塞等待获取蓝色钥匙

两者都贪心的想要获取对方手里的资源，但都不想要放弃自己手里的资源，**因此发生了死锁**



> ### 死锁产生的条件

- 互斥条件：一个资源一次只能由一个线程拥有，其他线程如果想要获取，需要阻塞等待拥有者线程释放
  - 比如 一个门只有一把钥匙
- 请求和保持条件：线程很“贪心”，在持有资源的情况下请求别的资源，它们不会放弃自己手里的资源
  - 比如上面拿着红色钥匙的线程又去请求蓝色钥匙，陷入阻塞状态也不会放弃自己手里的红色钥匙
- 不剥夺条件：线程获取的资源在完成任务之前，是不能被剥夺的，只能等待线程主动释放
  - 比如上面拿着红色钥匙，在没有执行到归还红钥匙的指令前是不会归还红钥匙的
- 循环等待条件：有多个进程{P0,P1,P2...Pn}，而 P0 等待 P1 的资源，P1 等待 P2 的资源 。。。Pn 等待 P0 的资源，就这样陷入了循环等待的困境
  - 比如上面 只有两个线程，但是陷入了循环等待的局面，线程 A 拿着蓝色钥匙等待 线程 B 手中的红色钥匙，线程 B 拿着红色钥匙等待线程 A 手中的蓝色钥匙



## 2、破坏死锁

- 破坏互斥条件：互斥条件是因为资源只有一个，且一次只能被一个线程持有，其他线程只能等待，比如上面的一把钥匙对应一个门，那么可以复制钥匙的副本，给多个线程。但实际上复制成本高，而且效率低，有的资源也只能存在一个，比如键盘的控制权之类的
- 破坏循环等待条件：由于线程 A 和 线程 B 按照不同的指令执行造成的循环等待，那么我们可以让线程 A 和 线程 B 最开始都去获取 红色钥匙 或者 蓝色钥匙，这样没有获取的一方就会阻塞，不会去霸占另一把钥匙
- 破坏不剥夺条件：线程 A 和 线程 B 宁愿死等也不愿放弃自己手中的资源，因此我们可以设置一个等待时间，多久时间没有获取到就放弃自己手中的资源，即可以产生剥夺的条件
- 破坏请求和保持条件：线程 A 和 线程 B 都在持有一个资源的情况下请求另外一个资源，这样的话，我们规定必须先使用完一个资源，归还该资源后才能再请求另外一个资源，即保证它们不会霸占资源





## 3、死锁检测/避免 - 银行家算法

有多个进程，并且存在多个资源，每个进程请求的资源数是不同的

那么我们需要经过计算，生成一个安全分配的序列，提前知道如何进行资源分配，才会保证不会产生死锁

- 安全序列可以存在多个，并且一定不会产生死锁

- 不安全序列同样存在多个，并不是一定会产生死锁，但产生死锁的必定是不安全序列

银行家算法就是用来找到安全序列的



> ### 简单一句话

当一个进程去申请资源的时候，银行家算法会进行模拟，假设分配给了该进程资源，判断 是否能够使得该进程完成 或者 剩下的资源是否能够满足后续的进程完成，如果可以，那么就是安全序列，不会产生死锁，如果不可以，那么表示是不安全序列，可能产生死锁，不能分配给该进程



> ### 简单一幅图

![这里写图片描述](https://img-blog.csdn.net/20180508204335770?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNDE0Mjcx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)





> ### 银行家算法例子讲解

存在 P0 P1 P2 P3 P4 这五个进程，以及 4 种资源

Allocation 表示对应进程已经分配到的各个资源的数量

> 比如 P0 的 0 0 3 2 表示第一、二个资源分配到了 0 个，第三 个资源分配到了 3 个，第四个资源分配了 2 个

Need 表示对应进程在分配了的资源的基础上还需要的各个资源的数量

Available 表示如今资源库中各个资源剩下的可分配的数量



![img](https://img-blog.csdn.net/20180508210408944)



假设 P0 申请 (0,0,1,2) 个资源，银行家算法会进行模拟，过程如下：

- 给 P0 分配 (0,0,1,2) 个资源，那么剩下的可用资源为 (1,6,1,0)，但是 P0 已经拥有了需要的全部资源，因此它可以执行完毕，将所占有的资源全部归还，那么可用资源就变成了 (1,6,5,4)
- 后续看其他的进程，这时候可以先给 P3 分配 (0,6,5,2)，让 P3 完成任务，归还资源，可用资源就变成了 (1,9,8,6)
- 再给 P4 分配 (0,6,5,6)，让 P4 完成任务，归还资源，可用资源就变成了 (1,9,9,10)
- 再给 P1 分配 (1,7,5,0)，让 P1 完成任务，归还资源，可用资源就变成了 (2,9,9,10)
- 再给 P2 分配 (2,3,5,6)，让 P2 完成任务，归还资源
- 所有进程都完成任务，完美达成

**因此，可以给 P0 分配资源，安全序列为 P0 - P3 - P4 - P1 - P2，这样不会产生死锁**



假设 P2 申请 (1,2,2,2) 个资源，银行家算法模拟过程如下：

- 给 P2 分配 (1,2,2,2) 个资源，那么剩下的可用资源为 (0,4,0,0)
- P2 还需要资源，但是可用资源不足以供给，所以 P2 无法完成任务，归还资源，而可用资源同时无法给其他进程分配所需资源，使得它们完成任务
- 这样，就陷入了死锁，因为所有进程都无法完成任务，这样就一直都不会归还资源，使得每个进程都陷入等待状态

**因此，不能给 P2 分配资源**
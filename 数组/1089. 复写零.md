## **[1089. 复写零](https://leetcode-cn.com/problems/duplicate-zeros/)**

```java
给你一个长度固定的整数数组 arr，请你将该数组中出现的每个零都复写一遍，并将其余的元素向右平移。

注意：请不要在超过该数组长度的位置写入元素。

要求：请对输入的数组 就地 进行上述修改，不要从函数返回任何东西。

提示：

1 <= arr.length <= 10000
0 <= arr[i] <= 9
```



## **示例 1：**

```java
输入：[1,0,2,3,0,4,5,0]
输出：null
解释：调用函数后，输入的数组将被修改为：[1,0,0,2,3,0,0,4]
```



## **示例 2：**

```java
输入：[1,2,3]
输出：null
解释：调用函数后，输入的数组将被修改为：[1,2,3]
```



## **方法①：边遍历边找 0 边移动**

### **实现思路**

```java
            找到 0 的位置，就将后面的元素往后移动一步
            缺点：如果存在多个 0，那么需要多次移动
```



### **实现代码***

```java
class Solution {
    public void duplicateZeros(int[] arr) {
        int len = arr.length;
        for(int i = 0; i < len; i++){
            if(arr[i] == 0){
                for(int j = len - 1; j > i; j--){
                    arr[j] = arr[j - 1];
                }
                i++;
            }
        }
    }
}
```





## **方法②、提前查找好 0 的位置**

### **实现思路**

```java
比如数组 [8,4,5,0,0,0,0,7]，len = 8
正序遍历，每当遍历到一个 0，那么 数组长度 len--，即后面删减的位置不需要遍历，因为会被挤掉

过程：
①、前三个没什么问题
8,4,5,0,0,0,0,7
	👆		  👆
i = 2 		 len = 8
②、遇到 0
8,4,5,0,0,0,0,7
	  👆 	👆
	i = 3 	len = 7
③、再次遇到 0
8,4,5,0,0,0,0,7
	    👆👆
	  i = 4 len = 6
到这里我们可以发现，数组被缩减成 8,4,5,0,0，后面 i = 4, len = 6
下一步 i = 5 的时候仍然是 0，但是后面已经没有可以删减的位置了，即 i == len - 1
这表示这个 0 只能当作普通的 [1, n] 的数，而不能进行复制，因此我们提前将它放置在末尾，然后继续 len--，即变成 len = 5
```



### **实现代码**

```java
class Solution {
    public void duplicateZeros(int[] arr) {
        int len = arr.length;
        int write = len - 1;

        for(int i = 0; i < len; i++){
            if(arr[i] == 0){
                //注意：如果是最后一个 0，那么我们不去删除
                if(i == len - 1){
                    arr[write--] = 0;
                }
                len--;
            }
        }
        for(int i = len - 1; i >= 0; i--){
            arr[write--] = arr[i];
            if(arr[i] == 0){
                arr[write--] = 0;
            }
        }
    }
}
```


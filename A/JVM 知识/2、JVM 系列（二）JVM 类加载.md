# JVM 类加载

## 1、类加载过程

扩展知识点：只有在 两个类 的 全类名 相同 并且 由同一个 ClassLoader 加载，才算作是同一个类



**类加载涉及到的只有 静态变量 和 静态方法**

**加载：** 

- 通过全类名获取对应的 `.class` 文件，然后加载到 JVM 内存
- 将 `.class` 中的静态结构转换为方法区中运行时数据结构 Klass，比如 Method 和 Field
- 在堆内存中生成一个用来访问 Klass 的入口 -  Class 对象**（用于反射）**

**验证：**校验 class 文件中的字节流信息符合虚拟机的规范，因为 JVM 使用的 class 文件不一定是从 编译器编译过去的，可能是别人自己让一些不合法的规范强行转换为字节码，校验数据如下：

- 校验是否有父类，因为除了 Object 类外，其他所有的类都有父类
- 校验是否继承了 final 类
- 校验是否出现了不符合规范的方法重载
- 等等

**准备：**只对静态变量进行处理，为静态变量**分配内存**

- 如果是基本数据类型，比如 static int，那么在 Class 对象上为其分配 32 位内存地址，其内存地址上的值为 000000，所以当作初值为 0
- 如果是 OOP 对象，那么分配一个用于存储地址指针的内存空间，将引用返回，这时候由于实例对象还没有创建，所以内存地址上还没有对应的引用地址，所以这时候默认 OOP 对象引用的初值为 null
- 如果是 static final 常量，直接赋用户的值

**解析：**常量池的符号引用都转换为直接引用

**初始化**：调用静态代码块，为静态变量赋值

- 如果是基本数据类型，那么直接在内存地址上赋值
- 如果是 OOP 对象，那么根据全类名找到对应的 元数据 Klass，实例化一个对象，然后返回引用值填充到分配的内存地址上

​	

如果是类的生命周期，那么需要加上类卸载

**卸载：**将类的 Klass 从方法区中移除，类可卸载必须满足的条件：

- 该类没有任何 OOP 对象
- 该类的 Class 对象没被任何指针引用



> ### 准备阶段的 OOP 对象引用分配了什么空间

```java
class A{
	static B b = new B();
}
```

像这种在准备阶段就是为 B b 分配存储地址的内存空间，32 位机器下 一个引用地址指针在 为 4字节（32 位）

所以准备阶段 b 指向的是 32 位大小的地址，但是上面都还没有记录任何对象的地址，地址的值都是 00000000，

由于对象没有分配，所以相当于 b  = null（具体参考单例模式中指令重排序的问题）

![img](https://upload-images.jianshu.io/upload_images/2509688-7e9afd7b80a6588e.png?imageMogr2/auto-orient/strip|imageView2/2/w/774/format/webp)





## 2、JIT 编译

> ### 解释执行 和 编译执行

JVM 有两种编译

- 一种是 `.java` 变成 `.class` 的过程，这个是普通编译器做的
- 一种是调用方法时进行的，将字节码转换为可直接执行的机器指令



第一种编译得到的是 `.class`，它是字节码的形式，CPU 看不懂，无法直接执行

- CPU 调用实际上就是在执行方法，而一个方法的主体部分就是 Code 属性里面的字节码指令

第二种编译就是将方法的 Code 属性的字节码指令转变为 机器指令

- 这种编译是在运行时期执行的，当调用某个方法时，就将某个方法的 Code 属性字节码编译为机器指令

我们可以看出，运行时调用某个方法在将字节码编译为机器指令的时候，它并没有对已经编译好的机器指令进行保存，因为如果所有方法都保存那么就会占据很大的内存，这样的话，当某个方法被频繁调用的时候，每次都需要经过一段编译的过程，效率很低



因此，引入了 JIT 编译器，从而出现了两种编译方法：

- 解释执行：将 Code 字节码编译为机器指令，然后将机器指令交给 CPU 执行，由 Interpreter 解释器执行
- 编译执行：将 Code 字节码编译为机器指令，然后存储起来，等到存在该方法调用的时候，直接将机器指令返回，省去了等到编译过程，由 JIT 编译器执行

我们可以看出， 解释执行 效率上比 编译执行要低，因为每次调用都需要对 code 字节码一条条进行解释转换为机器指令，而编译执行则只需要一次编译即可，但是需要使用内存来存储，因此不是每个方法都能够使用编译执行的

JIT 编译器对某个方法使用编译执行的前提是：这个方法是被多次调用，是个热代码

JIT 使用的是计数的方法来判断方法的热度的，当 JVM 调用某个方法时，该方法的计数器 +1，在 while() 里循环调用某个方法时，该方法的计数器也是循环 +1

当计数器达到某个阈值时，JIT 就会对这个方法进行编译执行



![img](https://picb.zhimg.com/80/v2-b6f9389c136957504a5c1ae563aba5f3_720w.jpg)





> ### 逃逸分析

JVM 的对象一定都是存储在堆中吗？

不是，因为 JIT 会进行 **逃逸分析**，因此对象可能存在于栈中



**逃逸：**一个变量在一个线程的方法中被分配，但是该变量可能逃逸到别的线程中去，比如存在静态变量引用了它，导致它被访问的地方是无法确定的，这样的变量就是 逃逸



**逃逸分析：**JIT 会在执行代码前分析某个变量的生命周期是否只存在于当前线程中，如果可以确定不会逃逸，那么就会进行 **标量替换**



**标量替换：**具体看 <https://blog.csdn.net/Qgwperfect/article/details/107903290>

像 基本数据类型 这种就是不可分割的，是一个标量，而像 OOP 对象这种，它内部可能存在很多的标量，因此它是一个聚合量，它是可以分割的；当发现某个对象不会逃逸，并且可以进行分割，那么不会直接在堆中生成这个对象，而是会在栈中创建该对象后续使用的标量

比如下面的 Point，真正使用的只有里面的 x = 1 和 y = 2，因此不需要创建 point 对象，直接创建 x 和 y 变量即可

![img](https://img-blog.csdnimg.cn/20200810002334524.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Fnd3BlcmZlY3Q=,size_16,color_FFFFFF,t_70)





## 3、双亲委派模型

> ### 1、什么是双亲委派模型？



当某个类加载器要加载类的时候，会将这个类一层层传递给父类加载器加载

如果父类加载器有这个类，加载成功，那么返回成功，否则就自己加载，这就是双亲委派模型



> ### 2、双亲委派的过程

ClassLoader 中有两个主要方法：loadClass() 和 findClass()

loadClass() 是指定类加载的顺序，默认是先查自己的缓存，再找父类进行加载，然后再自己加载

findClass() 是自己加载类的逻辑

```java
protected Class<?> loadClass(String name, boolean resolve)
    throws ClassNotFoundException
{
    synchronized (getClassLoadingLock(name)) {
        //从自己的缓存中查找该类，如果存在则返回
        Class<?> c = findLoadedClass(name);
        //缓存中不存在该类
        if (c == null) {
            long t0 = System.nanoTime();
            try {
                //父类加载器不为空
                if (parent != null) {
                    c = parent.loadClass(name, false);
                } else {
                    //父类加载器为空，调用根类加载器加载
                    c = findBootstrapClassOrNull(name);
                }
            } catch (ClassNotFoundException e) {
            }

            if (c == null) {
                //findClass() 是自己的类加载逻辑
                c = findClass(name);
            }
        }
        return c;
    }
}
```



> ### 3、双亲委派模型的好处  

**双亲委派机制的好处：**

- 用户写的类覆盖核心类
- 避免类重复加载（如果不是双亲委派，那么多个类加载器加载同个类，内存中就存在重复对象，并且算作是不同的对象，因为我们上面说了，只有被同个类加载器加载的类才是相同的类）



最开始也说了，JVM 认定同一个类的原理，如果我们不使用双亲委派模型，自己写了一个 `java.lang.Object` 类，那么将会由 `AppClassLoader` 去加载

由于官方的 Object 类 和 我们自定义的 Object 类的类加载器不同

那么内存中就存在两个 Object 类，那么当我们使用 Object 类的时候，导入的` java.lang.Obejct`，也不知道是哪一个类

编译不会出错，但是运行会出错

```java
package java.lang;
//自定义 java.lang.Object 类
public class Object {
    public static void main(String[] args) {
        Object object = new Object();//编译不报错，运行报错
    }
}

```





> ### 4、如何打破双亲委派机制

**双亲委派模型的第一次打破：**

双亲委派模型的体现主要就是 ClassLoader 中的 loadClass() 方法

我们自定义类加载器，然后重写 loadClass() 和 findClass()

将这个自定义类加载的 parent 设置为 null，这样在 loadClass() 的时候就会由于没有父类而 调用自己的加载逻辑 findClass()



**双亲委派模型的第二次打破：**

为了让上层应用能够加载第三方类，因此引入了 线程上下文类加载器

```java
public static void main(String[] args)  {
    System.out.println(Thread.currentThread().getContextClassLoader());
}
```

输出结果：

```java
sun.misc.Launcher$AppClassLoader@18b4aac2	//AppClassLoader
```





> ### 5、为什么要破坏双亲委派模型

核心类一般是由 根类加载器 和 扩展类加载器 加载的

用户类是由 应用类加载器 加载的

根类加载器是无法加载 非指定目录下的类的



在某些特定情况下，比如 JDBC，JDK 只是设计了一个接口让第三方接入，并没有将第三方类放入到 JDK 中，通过在 META-services 路径下创建以 **服务接口** 命名的文件，该文件内说明具体的实现类的全类名，这样在加载的时候，就可以通过这个全类名找到对应的 class 文件然后加载进去

比如下图，mysql-connector-java-5.1.38.jar 这个包是 java.sql.Driver 服务接口的一个实现类，所以它在对应路径下创建了以这个服务接口命名的文件，同时在内部标明了实现类的全类名

*![image.png](https://pic.leetcode-cn.com/1601896588-ntKKBD-image.png)*

这样的话，就有点类似 IOC 自动装配的思想，根据全类名找到对应的实现类并加载进内存

但是这样就有一个问题了，Driver 服务接口是由 根类加载器加载的，就算它知道 实现类的全类名，调用 Class.forName() 去加载，但是 Class.forName() 会默认使用加载调用类的类加载器--- 根类加载器去加载，但是根类加载器只能加载指定路径下的类，因此这个第三方类是无法加载，这样就出现问题了，因为它不存在父类，并且 loadClass() 只能向上找父类加载器，而不能向下，所以将会导致这个第三方实现类无法被加载，进而无法使用

因此，为了解决这个问题，引入了线程上下文类加载器，默认情况下线程上下文类加载器是应用类加载器，这样的话在服务接口中只需要获取线程上下文类加载器即可加载第三方类，这就是对 双亲委派机制的 逆向操作
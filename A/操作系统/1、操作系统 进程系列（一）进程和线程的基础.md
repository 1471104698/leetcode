# 进程和线程的基础





## 1、用户态 和 内核态



> #### 用户态 和 内核态的关系

内存假设为 4G，那么内核态和用户态共用瓜分这 4G 内存，即将一部分作为内核态，一部分作为用户态

**地址空间划分： 0xc0000000以上的地址空间只能在内核态下访问，  0x00000000-0xbfffffff的地址空间在两种状态下都可以访问。** 



用户态：CPU 调用某个进程时，CPU 只能访问该进程所映射的内存，不允许访问外围设备（硬盘，键盘，网卡等），占用 CPU 的能力可以被剥夺，CPU 资源可以被其他程序获取

内核态：CPU 可以访问内存的所有数据，以及 外围设备



涉及到计算机资源的操作，比如读写文件，都需要在内核态中，因为文件不可能直接放在用户态中，否则用户态的程序就可以随意访问篡改了；

跟用户数据相关的，比如 JVM 内存这种，Java 自己定义的变量对象之类的，则在用户态运行

用户态的程序只能持有文件的文件描述符 fd，具体的操作通过传输 fd 给内核态，让 CPU 进入内核态中进行操作





> #### 内核态 和 用户态 切换开销

Linux 中每个进程都有两个栈：用户栈 和 内核栈

当发生用户态到内核态的切换时，CPU 需要保存好 用户栈的数据，然后切换到内核栈

**切换开销：**

- **栈的切换前需要保存很多的 CPU 寄存器，并且切换后也需要恢复很多 CPU 寄存器**
- 从用户态切换到内核态时，CPU cache 中的数据是用户态的数据，因此直接无效；当从内核态切换到用户态时，CPU cache 也同样无效，使得**缓存命中率下降**



> #### 什么时候用户态会切换到内核态？

- 系统调用：比如 read()、write() 等
- 异常：比如 缺页异常
- 外围设备中断：比如硬盘读写完成，CPU 会停止指向下一条将要执行的指令，去处理中断后的后续操作





## 2、进程 和 线程 的区别

最基本的一个点：**进程是资源分配的基本单位， 线程是调度的基本单位**。

一个进程至少存在一个主线程，多线程都是从这个主线程衍生出来的

线程 共享的是 进程的 数据段、代码段、 虚拟地址空间、打开的文件、信号量等

线程 私有的是 栈（虚拟机栈）、程序计数器、CPU 寄存器

```java
数据段：存储全局变量的一个内存区域，从 JVM 来看就是堆
代码段：存放进程执行代码的一个内存区域，从 JVM 来看就是方法区
虚拟地址空间：一个进程所占有的虚拟地址空间是所有线程共享的，即所有线程共享 MMU 的映射的物理块
```



由于一个 CPU 只存在一个 MMU（虚拟地址映射），所以一个 CPU 在一个时间只能运行一个进程

由于 一个 CPU 有多个 CPU 核心，即同一时间可以调度同一进程的多个线程（线程并行）

<img src="https://pic2.zhimg.com/80/v2-989b429f41fc9cb64d0f8b58a59dadce_720w.jpg?source=1940ef5c" style="zoom:70%;" />



## 3、进程/线程 上下文切换

进程有两个栈，用户栈 和 内核栈，内核栈对于用户来说不可见，对于内核来说可见

为什么需要内核栈？

一个简单的理解就是 用户栈不可靠，假如用户栈快要溢出了，然后切换到内核态中执行，内核如果使用用户栈保存数据，那么就会导致内核崩溃。



进程上下文切换需要 保存旧进程的 虚拟页目录、全局变量等用户态资源，还会保存内核堆栈、文件描述符 fd、CPU 寄存器 等内核态资源

这些数据打包好保存在进程的用户栈上，并且将栈顶指针保存在进程的 PCB 中



而线程上下文切换只需要保存 

- 虚拟机栈（存储调用的方法栈帧）
- 程序计数器（方法执行的下一条 JVM 指令）
- CPU 寄存器状态（因为 CPU 可能运算一半，这些运算的变量值是在 CPU 寄存器中的，下次切换回来不希望重新执行，所以需要进行保存）



> #### 为什么说上下文切换导致 CPU 效率降低

 假设 一个 CPU 主频是 2.6GHz，这意味着每秒可以执行：2.6*10^9 个指令，那么每个指令的时间大概是0.38ns！

而一次上下文切换，将近需要耗时2000ns！而这个时间内，CPU 什么都干不了，只是做了保存上下文的动作！





## 4、多进程 和 多线程

> #### 多进程 和 多线程、多 CPU 和 多核 CPU

**多进程表示同时运行多个大任务**

**多线程表示单个大任务分成多个小任务同时运行**



进程作为 操作系统资源分配的基本单位，线程是 CPU 调度的基本单位

多 CPU 表示有多个 CPU，多核 CPU 表示一个 CPU 有多个核

一个 CPU 对应一个进程，而 CPU 的核对应进程中的线程

如果有多个 CPU，那么多个进程是并行执行的，如果 CPU 有多个核，那么多个线程是并行执行的

如果只有一个 CPU，那么多个进程是并发执行的，如果 CPU 只有一个核，那么同个进程中的多个线程是并发执行的



> #### CPU 密集型 和 IO 密集型

CPU 密集型表示任务需要大量的计算，需要大量占用 CPU 的资源，因此尽量避免上下文切换导致 CPU 效率降低，如果有多个 CPU 可以使用多进程

IO 密集型表示任务 99%情况下进行的是 IO 操作，IO 操作中 线程 会挂起，当挂起的时候 CPU 处于无事状态，因此可以设置多个进程 去应用这段 CPU 空闲的时间





## 5、僵尸进程 和 孤儿进程



每个进程都有自己的唯一的 PID（进程标识符），进程死亡被回收时，PID 也会被回收，并且能够分配给新的进程



> #### 孤儿进程

子进程还没有结束，而父进程自己先执行完退出了，那么这个子进程就是一个孤儿进程，它会被交给 init 进程进行管理

相比僵尸进程，孤儿进程不会占用资源，因为它最终还是会被回收的



> #### 僵尸进程

[僵尸进程详细介绍]( https://blog.csdn.net/zjwson/article/details/53321431 )



**产生的原因：**子进程死亡后，会给 父进程发送 SIGCHLD  信号，父进程的  signal(SIGCHLD, SIG_IGN) 默认忽略该信号，导致父进程没有调用 wait() 或者 waipid() 去处理子进程

- 默认忽略 SIGCHLD  信号 的原因是，在并发时候常常需要 fork 很多子进程，如果子进程结束后都需要父进程去收尸，那么效率会降低

**危害：**僵尸进程会占用 PID，系统的 PID 是循环回收利用的，一旦大量僵尸进程占用大量的 PID 号，导致无法给新进程分配 PID



**查找僵尸进程：**通过 top 命令查看僵尸进程的数量，再通过 ps 可以查看 进程 stat，查找处于 Z 状态的进程

```shell
ps -aux | grep Z

grep Z 是正则表达式匹配 Z
```



**处理方法：**

- 改写父进程的 signal()，捕捉 SIGCHLD 信号，并且调用 wait() 或者 waitpid() 进行处理
- 手动杀死父进程，这样僵尸进程就变成了孤儿进程，留给 init 进程处理
- 两次 fork()，父进程 fork 一代子进程，一代子进程再 fork 二代子进程，真正的操作在 二代子进程中，然后将 一代子进程杀死，这样二代子进程就是孤儿进程，死后自己靠 init 处理





## 6、进程 5 种装态转换

**进程状态：【新建、运行、就绪、阻塞、终止】**

新建状态：进程正在创建过程中，为进程分配资源，还不能被 CPU 进行调度

就绪状态：进程等待被 CPU 调度，等待运行

运行状态：进程已经被 CPU 调度，正在运行

阻塞状态：进程由于阻塞事件（IO、阻塞等待锁、sleep()、wait()）而陷入阻塞状态，不会继续运行，只有等待阻塞事件完成后才能继续被 CPU 调度，此时就算给进程分配 CPU 资源也没有什么用。当阻塞事件完成后，不会立即被 CPU 调度，需要先进入到就绪状态（这里的阻塞状态在线程中是划分为 阻塞状态 和 等待状态）

终止状态：进程正常/异常退出（比如被 kill -9 杀掉）



 ![这里写图片描述](https://img-blog.csdn.net/20170422190534211?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXdlNjExMjA3MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast) 





## 7、线程 6 种装态转换

**首先我们需要知道，为什么面试经常问 线程的状态，它很重要吗？**

```java
是的，它的确很重要，在故障排除的时候，我们需要通过 jps 获取 Java 运行的进程，然后通过 jstack 查看该进程的所有线程的状态，按照每个线程的状态来排除是否存在问题，是否发生了死锁之类的，如果不知道哪个状态对应什么样的事件，显然是有问题的
```



在 `Thread.State` 中定义了 6 种状态

```java
public enum State {
    NEW,
    RUNNABLE,
    BLOCKED,
    WAITING,
    TIMED_WAITING,
    TERMINATED;
}
```



**线程状态 跟 进程状态的区别：**

```java
进程 将 等待事件/阻塞事件 都合并为一个 阻塞状态（1种状态）
线程 将 等待事件 划分为 等待、超时等待状态，将阻塞事件 划分为 阻塞状态（3种状态）

进程 将 等待 CPU 调度 和 已经被 CPU 调度 两种状态给分开了，划分为 就绪状态 RUNNABLE 和 运行状态 RUNNING（2种状态）
线程 将 等待 CPU 调度 和 已经被 CPU 调度 结合为一种状态，即 RUNNABLE 状态（1种状态）
```



初始化（NEW）：线程刚创建，还没有调用 start()



运行（RUNNABLE）：java 线程将 等待 CPU 调度的 **就绪状态** 和 已经被 CPU 调度的 **运行状态** 合并为一种状态 Runnable，表示线程当前没有什么问题，就是在运行中



等待（WAITING）：比如 wait()、join() 、lock()、lockInterruptibily()

（在 wait() 中，当被 notify() 后，从 WaitSet 队列移到 EntryList 队列中重新等待获取锁，状态会从 WAITING 变成 BLOCKED）

```java
join() 方法底层是 sync 锁修饰方法 + wait() 实现的
lock() 底层是调用 LockSupport 的 park() 来挂起线程，通过 park() 挂起的线程都是 WAITING（基本只有操作系统级别的才能设置为 BLOCKED）
```



超时等待（TIMED_WAITING）：在 WAITING 的基础上加了等待的时间，允许超时后就退出等待，比如 wait(1000)、Thread.sleep(1000)、t1.join(1000)、tryLock(1000)，等待完成后进入就绪状态

```java
tryLock(1000) 是有限期的挂起，调用的是 parkNanos()，那么就是 TIMED_WAITING
```



阻塞（BLOCKED）：官方说明了处于该状态的线程是正在等待获取锁，阻塞在 EntryList 或者 CXQ 队列中的线程才是处于 BLOCKED 的



终止（TERMINATED）：线程正常执行完成（退出 run()） 或者 异常退出（发生异常没有捕获导致抛出到 run()）



 ![img](https://greenhathg.github.io/2019/08/04/Java%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81/3.jpeg) 





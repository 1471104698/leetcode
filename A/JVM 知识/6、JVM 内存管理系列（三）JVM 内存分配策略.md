# JVM 内存分配策略



## 1、对象创建优先进入 E 区

大多数情况下，新建对象是会在 E 区分配内存空间的，即优先进入到 E 区

唯一一种特殊情况是 新建对象是一个大对象，需要分配的内存超过阈值，那么将该对象直接分配到 老年代 中



## 2、大对象直接进入老年代

大对象是需要大量连续的内存空间的，比如大数组和超长字符串，由于存放在 E 区的话很容易导致内存不足而频繁产生 GC，所以直接放到 老年代

对于多大的对象才直接进入老年代，可以通过参数设置



## 3、GC age 大于阈值的对象晋升老年代

每次经过一次 young GC 后对象仍然存活，那么该对象的 GC age + 1（在对象头的 _mark 中有 4bit 用来记录 GC age）

如果某个对象的 GC age 到达某个晋升阈值，那么将该对象晋升老年代，默认晋升阈值为 15



## 4、动态计算晋升年龄阈值 

当 GC age >= x 的所有对象占用超过 S 区空间一半时，将 GC age >= x 的对象全部提前晋升老年代，不需要等到 GC age 到达晋升阈值



## 5、空间分配担保

这里的 担保 有点像 买保险 的意思

如果对象在 E 区分配内存失败，那么会触发一次 young GC，而在发生 young GC 之前，有以下判断：

- **判断 老年代最大可用连续空间 是否 大于 新生代的所有对象的总空间大小**
  - 即如果极端的情况下，新生代所有的对象都晋升到老年代，老年代是否撑得住
- 如果大于，那么可以放心的进行 young GC；如果小于，那么判断**是否设置了允许空间分配担保**
- 如果设置了，那么 **判断 老年代最大可用连续空间 是否 大于 历次新生代晋升老年代的对象的平均大小**
  - 这里是退而求其次，按照历次的 young GC 晋升的对象大小来判断是否可以进行 young GC
- 如果大于，那么**带着风险 进行一次 young GC**
  - 因为历次平均值只能作为参考，如果刚好这次 young GC 晋升的对象空间超过了老年代最大可用连续空间，那么就崩了
- **如果不允许空间分配担保 或者 历次晋升老年代对象平均大小 超过了 老年代最大可用连续空间，那么进行一次 full GC**
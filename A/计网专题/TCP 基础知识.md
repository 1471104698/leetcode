# TCP 的基础知识



## 1、TCP 和 UDP 区别 和 使用场景：

> ### 区别

**TCP ：**

面向连接的、基于字节流，提供可靠性传输，因为是数据是字节流的形式，所以没有固定大小，可分割

并且存在流量控制、拥塞控制，网络拥堵会较少或停止发送数据

并且是 点对点 的连接

传输的数据是有序的，这里的有序并不是有序到达，而是接收端能够通过序列号对数据进行拼接，使得无序的数据变成有序的



**UDP：**

无连接，尽最大努力交付，基于报文传输

由于在报文中存储了该数据报的大小，因此不会进行分割，当传输过程中发现数据报超过  MTU（最大传输单元） 大小，那么数据报会直接丢弃

没有拥塞控制等功能，无论网络多么拥堵， UDP 都不会减慢发送速率

并且是 一对一、一对多、多对多的连接

传输的数据不能保证有序，比如最先发送了数据报 A，然后再发送数据报 B，本来数据报 A 应该先于数据报 B 被接收方接收才能保证数据的有序性，但是由于网络拥堵等问题，导致数据报 B 先被接收方接收，由于不存在序列号，所以不接收方就不知道哪个数据是在前面的了



![img](https://pic3.zhimg.com/80/v2-4ddab99ec7f379dcefd209805643e76c_720w.jpg)

> ### 使用场景

由于 TCP 需要经过握手连接、以及数据重传之类的，效率较低，因此适合电子邮件、QQ 聊天之类的

而 UDP 实时性高，效率高，适合 直播、电话会议之类的要求实时性高的，即使丢点包也不会太影响用户体验



**这里需要说明一下：微信视频聊天是UDP，信息是TCP**



## 2、TCP 的头部

> ###  序列号

发送方和接收方都会初始化一个 **随机序列号 ISN**（客户端和服务端都可以是发送方）

我们应该先明白 **序列号** 的作用：

**一是让接收方能够对乱序的数据包进行拼接**

 我们说了 TCP 是基于字节流的，一个字节流会分成多个 报文段 进行发送，每个报文内的数据是字节流的一部分，假设将某个字节流分为 1 2 3 4 报文段，按照这个顺序发送出去，数据包到达服务端的不一定是 1 2 3 4 的顺序，因此服务端需要根据各个数据包上面的序列号的大小判断先后顺序，然后进行拼接成为 一个完整的字节流

发送方发送数据，假设整个字节流有 0 - 2048 字节，它们进行标号就是 第 0 个字节、第 1 个字节 。。。

发送某个数据包的时候，假设这个数据包的标号为 512 ~ 1024 字节，那么该报文的序列号值为 ISN + 513，整个数据流可以通过 这个序列号 + 长度 - 1 得到最后一个字节的标号，这样服务端回应的 ACK 就是这个序列号 + 长度，表示下个期望收到的序列号



**二是能够让接收方通过序列号对重复的数据包去重**

比如发送方发送了 1 号数据包，由于网络拥堵，没有到达接收方或者 接收方的 ACK 没有到达 发送方，因此发送方超时重发 1 号数据包，后面两个 1 号数据包先后到达接收方，后到达的 1 号数据包接收方发现前面已经接收过相同序列号的数据包了，因此会直接丢弃，不会重复处理





**为什么序列号需要随机？**

为了防止 TCP 预测攻击，防止第三方发送一个 序列号符合预期的包，但是内容是伪造的，因为如果你不加序列号，那么数据包都是从 0 开始的，而加了随机序列号 ISN，数据包就是从 ISN 开始的了，而 ISN 是 0 ~ 2^32 尽头再循环，攻击者难以预测这个 ISN



> ### 标志位：

通过标志位的变化来标识某个报文字段什么类型的

对应类型的报文的标志位为 1，其余为 0

- *ACK*：该位为 `1` 时，确认应答，TCP 规定除了最初建立连接时的 `SYN` 包之外该位必须设置为 `1`** 

- *RST*：该位为 `1` 时，表示 中断异常，如果已经连接那么要断开连接

- *SYC*：该位为 `1` 时，表示建立连接，并在其「序列号」的字段进行序列号初始值的设定。

- *FIN*：该位为 `1` 时，表示断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 `FIN` 位置为 1 的 TCP 段。



## 3、TCP 三次握手



> ### 三次握手过程

- 第一次握手：客户端随机初始化一个序号，记作 `client_isn`，将它放在 TCP 报文的序列号部分

  然后将 SYN 标志位  置为 1，发送给服务端**（该报文不包含应用层数据）**

  

- 第二次握手：服务端接收到客户端的报文，然后随机初始化一个序号，记作 `server_isn`，将它放在 TCP 报文的序列号部分，再将从客户端报文获取的 `client_isn` + 1 放到 确认号 上，然后将 SYN、ACK 标志位      置 1，发送给客户端**（该报文不包含应用层数据）**

- 第三次握手：客户端接收到服务端的报文，然后将从服务端报文获取的 `server_isn` + 1 放到 确认号 上，然后将 ACK 标志位  置 1，发送给客户端，这次可以将数据放到报文顺便传输给服务端**（该报文包含应用层数据）**
  

**第一、二次握手没有传输数据，第三次握手可以传输数据**



![img](https://pic1.zhimg.com/80/v2-c2602875a99f219451bb5d9fe087812c_720w.jpg)





> ### 为什么是三次握手？不是两次、四次？

有 3 个原因：

- 三次握手才可以阻止历史连接（主要原因）
- 三次握手才可以同步双方的初始序列号
- 三次握手才可以避免资源浪费
- 

> 原因①：避免历史连接

发送方 发送 SYN 请求建立建立，可能由于网络拥堵原因，这个 SYN 和 迟迟到不了接收方 或者 接收方的 SYN + ACK 迟迟到不了 发送方，那么由于超时重发机制，发送方会再次发送 SYN

如果这时候最先的一个 SYN 到达了接收方 或者 接收方的 SYN + ACK 到达了 发送方，后续继续进行握手

而后面超时重发的第一次握手的 SYN 到达 接收方后，接收方会继续发送一个 SYN + ACK 给发送方

而这一个 SYN 连接实际上已经是不需要的了，因为发送方需要建立的连接已经建立了，这个 SYN 就相当于是历史连接了



如果只有两次握手，接收方对这些历史连接的 SYN 发送了 SYN + ACK 后，发送方接收到了，根据 seq 判断了这是历史连接，但是它无法告知接收方这是历史连接，因此接收方会将这些历史连接都放入到 accept 队列中，**这样就是造成了重复连接，导致了资源浪费（原因③）**

而如果是三次握手，那么就可以对这个历史连接进行处理了

- 发送方根据 seq 判断是历史连接，那么发送 RST 包给接收方中断这次连接
- 如果不是，那么发送 ACK 包给接收方，告知接收方没问题了，可以进行数据传输了



> 原因②：同步双方的初始序列号

在最上面 0、TCP 的头部讲了 序列号的作用，传输的序列号就是基于初始序列号来的

**只有三次握手，才能确保双方的初始序列号进行同步，方便后续传输**



**两次握手** 只能确保服务端同步了客户端的初始序列号，却不能确保客户端同步了服务端的初始序列号，因为客户端没有发送 ACK 给服务端



> 原因③：避免重复连接造成资源浪费

跟原因 ① 具有密不可分的联系

就是由于两次握手，无法解决历史连接问题，会造成重复连接，导致资源浪费



**综上：**

- 不使用两次握手的原因：无法避免历史连接，无法确保双方同步初始序列号，造成资源浪费

- 不使用四次握手的原因：三次已经可以确保可靠连接了，无需更多的通信次数

**即上面的原因都是针对 两次握手 提出的**





## 4、四次挥手



> ### 四次挥手过程

客户端和服务端都可以主动断开连接



现在假设：

- 客户端要断开连接，那么它会发送一个 FIN = 1 的报文给服务端，告知要关闭连接
- 服务端收到报文后，会发送一个 ACK 报文给客户端，表示自己收到了
- 客户端收到 ACK 报文后，会进入等待状态
- 等到服务端处理完数据后，会发送一个 FIN 报文给客户端
- 客户端接收到后，会发送一个 ACK 报文给服务端，然后进入 TIME_WAIT 状态
- 这时，服务端接收到 ACK 报文后，会关闭连接，而 客户端还在 等待
- 过了 2MSL 后，客户端关闭连接

一个来回都需要一个 FIN 和 ACK，称作四次挥手

（FIN 为正常终止连接，RST 为异常中止连接，比如上面的历史连接）

**需要注意的是**：谁先发起的关闭连接谁就有 TIME_WAIT 状态



![img](https://picb.zhimg.com/80/v2-083462b035aeaa02bbf10f67ab78f51f_720w.jpg)





> ### 为什么不能是三次挥手？

客户端发送 FIN 给服务端，表示所有数据都传输完毕了，可以关闭连接了，但仍然能够接收消息

服务端接收到 FIN 后，会发送一个 ACK ，但可能还有数据没有处理完，因此需要等到数据处理完毕后，才发送 FIN 给客户端，告知客户端数据处理完毕，可以关闭连接

对比三次挥手，因为服务端中间可能存在数据没有处理，因此 ACK 和 FIN 需要分开发送，所以需要四次挥手





## 5、SYN 攻击（攻击半连接队列）

**服务端存在两个队列，一个是 SYN 连接队列（半连接队列），一个是 Accept 队列（连接队列）**

SYN 队列是存储第一次握手接收到的客户端的 SYN 请求，将这个请求放到 SYN 队列中

Accept 队列是 第三次握手，服务端收到客户端的 ACK 后，将连接从 SYN 队列移除，放到 Accept 队列 中，然后应用程序通过调用 `accept() ` 来获取 Accept 队列 中的连接



正常流程：

- 当服务端接收到客户端的 SYN 报文时，会将其加入到内核的「 SYN 队列」；
- 接着发送 SYN + ACK 给客户端，等待客户端回应 ACK 报文；
- 服务端接收到 ACK 报文后，从「 SYN 队列」移除放入到「 Accept 队列」；
- 应用通过调用 `accpet()` socket 接口，从「 Accept 队列」取出的连接。

![1597974574685](C:\Users\蒜头王八\AppData\Roaming\Typora\typora-user-images\1597974574685.png)



SYN 攻击是针对三次握手的，假设攻击者短时间伪造不同 IP 地址的`SYN` 报文，服务端每接收到一个 SYN 报文后，会将这个连接放到 SYN 队列

当 服务端 发送 ACK + SYN 却没有收到 ACK ，那么这个连接会一直待在 SYN 队列，导致队列被塞满，无法响应正常用户的连接请求





## 6、TCP 是基于字节流的，为什么还有报文呢？如何理解 TCP面向字节流，UDP面向报文？

TCP 是基于字节流的，但是传输本身需要一个数据结构来存储这些字节流，这个数据结构就是报文，因此每次发送都是以 TCP 报文的形式发送，实际上这个报文只是作为 字节数据的载体，(**所谓载体的意思看下面的接收方回答**)



TCP 的基于字节流 和 UDP 的基于报文段，**区别在于 发送方发送数据的情况 以及 接收方接收的时候，数据是否存在边界**

**发送方：**

- TCP 是有缓冲区的，即滑动窗口，在发送的时候，是按照字节来发送的，跟应用层传输下来的数据的长度无关
- UDP 没有缓冲区，应用层数据下来后，直接加上包头就发送出去了，分片是在网络层，由 IP 进行分片

**接收方：**

- TCP 有缓存，由于是基于字节流，而且说了报文只是一个载体，所以它没有边界，接收方的 TCP 缓冲区将获取到的数据直接拼接起来，然后 java 调用 read(buff, len) 方法指定获取 len 长度的数据放入到 buff 字节数组中，这一次 read 获取的数据可能是半个报文、一个报文、两个报文 的数据，我们用户并不知道它读取的是多少个报文的数据，因为它是字节流的形式

   ![img](https://pic2.zhimg.com/80/v2-d7381f4c782ca5210b548110cd95f240_720w.jpg?source=1940ef5c)

- UDP 是一个报文一个报文的形式的，我们可以当作接收方是将这些报文按照链表，以队列的形式存储起来的，每次 read() 就获取队首的报文，而如果 read(buff, len) 读取的数据长度小于 报文内数据的长度，那么也只是读取 len 长度的数据，剩下的报文中的数据会直接舍弃掉

   ![img](https://pic2.zhimg.com/80/v2-d7381f4c782ca5210b548110cd95f240_720w.jpg?source=1940ef5c)

  

  

  到这里我感觉应该很明白为什么 说 TCP 是基于字节流， UDP 是基于报文段的了 



## 7、TCP 粘包



> ### TCP 为什么会发生粘包？

首先，我们要知道，TCP 是基于字节流的，本身没有数据包（报文段）的概念，数据包只是作为传输过程中字节数组的载体

**而也恰恰正是因为 TCP 是基于字节流的，才会导致粘包问题，因为数据没有边界**



一个字节流数据分为了 1 2 3 4 这四个数据段，将它们封装在数据包中，然后按照顺序进行发送

我们在 6 中说了，TCP 是有缓存的，即滑动窗口

发送方是看滑动窗口中能够发送多少字节，就将对应长度的字节数据 封装进数据包中发送出去

接收方是将发送过来的数据包中的数据拆分，然后放入到缓存中，这样就消去了包的概念，只剩下字节的概念了

这样，当接收方接收到一个数据包，假设长度为 10 个字节，放进缓存中，而用户没有调用 read() 进行处理，当第二个数组包到达，假设为 20个字节，接收方拆分后再放到缓存中，这样由于是字节的形式，不存在边界，用户调用 read(buff, 15)，这样就用到了第一个包的全部数据，以及第二个包的前 5 个字节，**这就是粘包，即数据处理不是按照一个包一个包来使用的**



> ### 发生粘包、拆包的情况



**1、应用层数据过大，无法一次发送**

如果应用层的数据超过滑动窗口的缓存大小，那么消息会被进行分割，导致拆包

当发送了一部分后，另一部分进入缓存中，而后面又加入了新的数据，导致这后半部分数据跟新的数据一起发送出去，导致粘包



**2、接收方处理不及时**

这个就是上面讲的 TCP 为什么会发生粘包问题的例子，接受方处理不及时，发送方的缓存区缓存了多个报文



**3、MUT / MSS 分片**

MTU 是链路层中以太网对传输数据大小的限制

从 传输层出发，封装成 TCP 报文，再到网络层，封装成 IP 报文，再到 链路层，所以到达链路层时是 IP 报文，即 MTU 是限制 IP 报文大小的

而一个 IP  报文包括 IP 头部、TCP 头部、字节数据

因此真正可传输的数据为 MTU - IP 头部大小 - TCP 头部大小，这部分数据称为 MSS，即 TCP 最大可发送数据

当 发送方缓存中的数据大小超过 MSS 时，那么就会进行分片，这样就会导致拆包



**4、TCP 默认使用的 Nagle 算法**

无论发送多少数据，到达 链路层都是 IP 报文，都会存在 IP 头部 和 TCP 头部

这样即使从键盘输入 1 个字节，发送出去，那么到达 链路层就是 41 个字节，其中 1 个字节是真正的数据，40 个字节分别是 IP 头部 和 TCP 头部，这种情况对于网络来说是完全不值得的，为了 1 个字节的数据竟然额外占用了网络 40 个字节的带宽

因此，TCP 的 Nagle 算法 就是为了避免网络中充斥着许多这种小块数据，它会等待缓存中的数据长度到达 MSS，然后再进行发生，而这样也就会导致粘包



> ### 粘包、拆包问题解决

- 在一个数据的尾部加上结束符，比如 \n\r，这样接收方可以根据结束符进行分割，目前这个感觉最好

- 关闭 Nagle 算法，这其实就是相当于关闭了 TCP 的确认延迟机制

  

**确认延迟机制**

接收方收到数据包以后如果暂时没有数据要发给发送方，它可以等一段时再确认（Linux上默认是40ms）。

如果这段时间刚好有数据要传给发送方，ACK 就随着数据传输，而不需要单独发送一次 ACK 。

如果超过时间还没有数据要发送，也发送 ACK ，避免发送方以为丢包。
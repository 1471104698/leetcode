# TCP 的基础知识



## **TCP 和 UDP 区别 和 使用场景：**

> ### 区别

**TCP ：**

面向连接的、基于字节流，提供可靠性传输，因为是数据是字节流的形式，所以没有固定大小，可分割

并且存在流量控制、拥塞控制，网络拥堵会较少或停止发送数据

并且是 点对点 的连接

传输的数据是有序的，这里的有序并不是有序到达，而是接收端能够通过序列号对数据进行拼接，使得无序的数据变成有序的



**UDP：**

无连接，尽最大努力交付，基于报文传输

由于在报文中存储了该数据报的大小，因此不会进行分割，当传输过程中发现数据报超过  MTU（最大传输单元） 大小，那么数据报会直接丢弃

没有拥塞控制等功能，无论网络多么拥堵， UDP 都不会减慢发送速率

并且是 一对一、一对多、多对多的连接

传输的数据不能保证有序，比如最先发送了数据报 A，然后再发送数据报 B，本来数据报 A 应该先于数据报 B 被接收方接收才能保证数据的有序性，但是由于网络拥堵等问题，导致数据报 B 先被接收方接收，由于不存在序列号，所以不接收方就不知道哪个数据是在前面的了



![img](https://pic3.zhimg.com/80/v2-4ddab99ec7f379dcefd209805643e76c_720w.jpg)

> ### 使用场景

由于 TCP 需要经过握手连接、以及数据重传之类的，效率较低，因此适合电子邮件、QQ 聊天之类的

而 UDP 实时性高，效率高，适合 直播、电话会议之类的要求实时性高的，即使丢点包也不会太影响用户体验



**这里需要说明一下：微信视频聊天是UDP，信息是TCP**



## **标志位：**

通过标志位的变化来标识某个报文字段什么类型的

对应类型的报文的标志位为 1，其余为 0

- *ACK*：该位为 `1` 时，「确认应答」的字段变为有效，TCP 规定除了最初建立连接时的 `SYN` 包之外该位必须设置为 `1` 

- *RST*：该位为 `1` 时，表示 TCP 连接中出现异常必须强制断开连接。

- *SYC*：该位为 `1` 时，表示希望建立连，并在其「序列号」的字段进行序列号初始值的设定。

- *FIN*：该位为 `1` 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 `FIN` 位置为 1 的 TCP 段。

  

## 如何确定一个 TCP 连接

通过 TCP 四元组可以确定一个 TCP 连接：源地址、源端口号、目的地址、目的端口号

源地址、目的地址 是确定报文通信的主机

源端口号、目的端口号 是确定报文发送给哪个进程

**注意：**UDP 只有 端口号，没有地址，因为不是面向连接的，可以进行广播，不需要发送给特定的主机



## TCP 三次握手



> ### 三次握手过程

- 第一次握手：客户端随机初始化一个序号，记作 `client_isn`，将它放在 TCP 报文的序列号部分

  然后将 SYN 标志位  置为 1，发送给服务端**（该报文不包含应用层数据）**

  

- 第二次握手：服务端接收到客户端的报文，然后随机初始化一个序号，记作 `server_isn`，将它放在 TCP 报文的序列号部分，再将从客户端报文获取的 `client_isn` + 1 放到 确认号 上，然后将 SYN、ACK 标志位      置 1，发送给客户端**（该报文不包含应用层数据）**

- 第三次握手：客户端接收到服务端的报文，然后将从服务端报文获取的 `server_isn` + 1 放到 确认号 上，然后将 ACK 标志位  置 1，发送给客户端，这次可以将数据放到报文顺便传输给服务端**（该报文包含应用层数据）**
  

**第一、二次握手没有传输数据，第三次握手可以传输数据**



![img](https://pic1.zhimg.com/80/v2-c2602875a99f219451bb5d9fe087812c_720w.jpg)





> ### 为什么是三次握手？不是两次、四次？

有 4 个原因：

- 最基本的原因就是确保双方的发送和接收能力都正常

- 三次握手才可以阻止历史连接（主要原因）
- 三次握手才可以同步双方的初始序列号
- 三次握手才可以避免资源浪费



**原因①：*避免历史连接***

网络环境错综复杂，往往并不是如我们期望的一样，先发送的 SYN 数据包，一定能够在特定时间内到达服务端

可能由于网络堵塞等原因，一直没发送到服务端，而这时客户端发送了新的 SYN 数据包，结果旧的数据包先到达服务端，那么 TCP 三次握手是怎么避免这个旧的连接的呢？

*![image.png](https://pic.leetcode-cn.com/1597933110-JHiQec-image.png)*

假设新的数据包的 `client_isn`  = 100，而旧的 SYN 数据包的  `client_isn`  = 90，如果旧的 SYN 先到达了服务端，然后服务端第二次握手根据   `client_isn`  返回确认码 90 + 1，客户端接收到后，发现和预期的 100 + 1 不一样，发现这是历史序列，那么客户端发送 标志位为 RST 的数据包，告诉服务端中止这个历史连接

如果是两次握手，那么在 服务端发送数据包后，客户端并不能判断是否是历史连接，并且告知服务端

因此三次握手，客户端能够在第三次发送数据报前，有足够的时间判断是否是历史连接，并根据结果发送对应的数据包告知服务端

- 如果是历史连接（序列号过期或超时），则第三次握手发送的报文是 `RST` 报文，以此中止历史连接；
- 如果不是历史连接，则第三次发送的报文是 `ACK` 报文，通信双方就会成功建立连接；



**原因②：同步双方的初始序列号**

首先在说明这个原因之前，我们应该先明白 **序列号** 的作用，这样才能知道为什么这是原因之一

它的作用：

- 接收方能够去除重复的数据
- 接收方可以根据序列号判断哪些数据是被对方收到的，比如你收到了 100 + 1 的 ACK 确认号，表示 你发的 100 序列号的数据包被接收了

而三次握手，第一次服务端能够获取客户端的初始序列号，并给客户端发送服务端的初始序列号，以及收到的 ACK 确认，客户端收到服务端的初始序列号，并确认了 ACK 正确，再发送对服务端的初始序列号的 ACK

**这样一来一回，才能确保双方的初始序列号进行同步，方便后续传输**

*![image.png](https://pic.leetcode-cn.com/1597971889-ZdSYRM-image.png)*

实际上，服务端的第二次握手是发送 SYN 和 ACK，而由于 TCP 报文里有 序列号 和  确认号两部分，因此可以直接一次放到 TCP 报文内部，将 ACK 和  SYN 作为一个握手发送给客户端，简化了 **四次握手**

**两次握手** 只能确保服务端同步了客户端的初始序列号，却不能确保客户端同步了服务端的初始序列号，因为客户端没有发送 ACK 给服务端



***原因三：避免资源浪费***

跟原因 ① 一样，同样的因为网络拥堵等原因，客户端第一次握手发送的 SYN 数据包在网络中逗留，服务端没有收到客户端的 SYN，自然也不会发送  ACK，而客户端没有收到服务端的 ACK 请求，就会 **超时重发**，重新发送 SYN

（注意，发送的每个 SYN 的序列号都是一样的，因为是超时重发，是发送原来的那个数据包，而不是重新初始化一个序列号再发）

如果全部在网络中逗留，发送了很多的 SYN，那么当这些 SYN 报文在接连时间内到达服务端，而服务端对某个 SYN 连接，发送 SYN + ACK 给客户端

由于没有第三次握手，即客户端不会发送 ACK 给服务端，因此服务端不知道自己发送的 SYN + ACK 客户端是否收到了，因此它会对每个 SYN 连接都发送 SYN + ACK，这样的话，**服务端在收到请求后会跟 同个客户端建立了多个冗余的连接，造成不必要的资源浪费**

*![image.png](https://pic.leetcode-cn.com/1597973491-PDMNeu-image.png)*

**综上：**

- 不使用两次握手的原因：无法避免历史连接，无法确保双方同步初始序列号，造成资源浪费

- 不使用四次握手的原因：三次已经可以确保可靠连接了，无需更多的通信次数

**即上面的原因都是针对 两次握手 提出的**



## SYN 攻击

服务端存在两个队列，一个是 SYN 连接队列（半连接队列），一个是 Accept 队列（连接队列）

SYN 队列是存储第一次握手接收到的客户端的 SYN 请求，将这个请求放到 SYN 队列中

Accept 队列是 第三次握手，服务端收到客户端的 ACK 后，将连接从 SYN 队列移除，放到 Accept 队列 中，然后应用程序通过调用 `accept() ` 来获取 Accept 队列 中的连接



正常流程：

- 当服务端接收到客户端的 SYN 报文时，会将其加入到内核的「 SYN 队列」；
- 接着发送 SYN + ACK 给客户端，等待客户端回应 ACK 报文；
- 服务端接收到 ACK 报文后，从「 SYN 队列」移除放入到「 Accept 队列」；
- 应用通过调用 `accpet()` socket 接口，从「 Accept 队列」取出的连接。

![1597974574685](C:\Users\蒜头王八\AppData\Roaming\Typora\typora-user-images\1597974574685.png)



SYN 攻击是针对三次握手的，假设攻击者短时间伪造不同 IP 地址的`SYN` 报文，服务端每接收到一个 SYN 报文后，会将这个连接放到 SYN 队列

当 服务端 发送 ACK + SYN 却没有收到 ACK ，那么这个连接会一直待在 SYN 队列，导致队列被塞满，无法响应正常用户的连接请求



**防止 SYN 攻击：**

- 当 SYN 队列满时，后续的 SYN 请求不进入 SYN 队列
- 而是计算出一个 cookie 值，再将 SYN + ACK 放到 cookie 中，发送给客户端
- 当服务端收到 ACK 后，会检查合法性，如果合法，直接放到 Accept 队列中
- 省去了放入 SYN 队列 和 从 SYN 队列移除的过程



## 四次挥手



> ### 四次挥手过程

客户端和服务端都可以主动断开连接



现在假设：

- 客户端要断开连接，那么它会发送一个 FIN = 1 的报文给服务端，告知要关闭连接
- 服务端收到报文后，会发送一个 ACK 报文给客户端，表示自己收到了
- 客户端收到 ACK 报文后，会进入等待状态
- 等到服务端处理完数据后，会发送一个 FIN 报文给客户端
- 客户端接收到后，会发送一个 ACK 报文给服务端，然后进入 TIME_WAIT 状态
- 这时，服务端接收到 ACK 报文后，会关闭连接，而 客户端还在 等待
- 过了 2MSL 后，客户端关闭连接

一个来回都需要一个 FIN 和 ACK，称作四次挥手

（FIN 为正常终止连接，RST 为异常中止连接，比如上面的历史连接）

**需要注意的是**：谁先发起的关闭连接谁就有 TIME_WAIT 状态



![img](https://picb.zhimg.com/80/v2-083462b035aeaa02bbf10f67ab78f51f_720w.jpg)





> ### 为什么需要四次挥手？

客户端发送 FIN 给服务端，表示所有数据都传输完毕了，可以关闭连接了，但仍然能够接收消息

服务端接收到 FIN 后，会发送一个 ACK ，但可能还有数据没有处理完，因此需要等到数据处理完毕后，才发送 FIN 给客户端，告知客户端数据处理完毕，可以关闭连接

对比三次挥手，因为服务端中间可能存在数据没有处理，因此 ACK 和 FIN 需要分开发送，所以需要四次挥手







## 为什么需要 TIME_WAIT 状态？

原因有二：

- 防止旧的数据包被 相同的 【四元组】 接收
- 确保 被动关闭的一方 能够接收 ACK，正确关闭连接



> ### 原因一：防止旧连接的数据包

如果在客户但未发起 FIN 的时候，服务端发送一个数据包 x，由于网络拥堵等原因， x 一直未到达客户端

而客户端觉得自己数据传输完了，那么发送 FIN 请求关闭连接，然后一直来来回回，客户端 2MSL 过后都关闭了连接，而这时，又有一个新的客户端，使用了原本相同的四元组，那么当建立起连接后，这个旧的数据包 x 发送给了 这个新的客户端，那么客户端是有可能正常接收的（即当序列号巧合的一致时），那么就会导致数据错乱

因此，等待这个 2MSL，可以让旧的数据全部无效，保证新的连接接收到的必定是新的数据

![image.png](https://pic.leetcode-cn.com/1597979904-bDiuAM-image.png)

### 

> ### 原因二：保证连接正常关闭

如果 TIME_WAIT 过短或者没有的话，有什么问题呢？

假设客户端取消了 TIME_WAIT 

当客户端发送 ACK 后，立马关闭了，那么如果 ACK 在 MSL 内没有到达 服务端

那么服务端会重新发送 FIN 给客户端，但是由于客户端关闭连接了，那么就会导致服务端无法正常关闭，

**一直处于 LAST_ACK 状态，持续几分钟**，那么对于后续的相同 【四元组】的连接，服务端会发送 RST 表示中止连接，影响了后续的正常连接





![1597980047007](C:\Users\蒜头王八\AppData\Roaming\Typora\typora-user-images\1597980047007.png)





## 为什么 TIME_WAIT 等待的时间是 2MSL？

假设 客户端为主动关闭端，服务端为被动端，这里我们需要先知道：

1、**MSL：报文的最大生TIME_WAIT存时间，如果超过这个时间，那么报文就无效了，会被丢弃**

2、服务端在 收不到 ACK 时，会一直重新发送 FIN ，尝试几分钟后才自动关闭

3、客户端重新收到 FIN 报文后，会重新开始计时

4、服务端在收到 ACK 报文后，不会再发送任何报文，直接进入 CLOSED 状态



客户端给服务端发送 ACK 报文后，假设经过 t 时间后被服务端接收，存在 0 < t <= MSL

因为客户端不知道服务端多久才会收到 ACK，假设服务端在收到 ACK 前的一瞬间，发送了 FIN 报文，

那么这个报文 那么临界时间内最多需要一个 MSL 的时间才会无效或被接收，那么客户端就需要再等待一个 MSL 的时间，确保接收这个 FIN，因为如果只等待 1MSL 之类的，客户端关闭了，那么 FIN 到达时客户端无法接收，会回发一个 RST 包，让服务端以为出现了错误，但实际上是正常关闭



## TIME_WAIT 过多的问题？

首先存在的一点：内存资源占用，一个 TIME_WAIT  4KB



其次，很多人都说端口被占用，一旦端口被占用后，就会导致新的连接无法建立，**这个说法是有问题的**



对于普通的连接，是【五元组】，即 协议，客户端 IP，客户端 端口，服务端 IP，服务端 端口

而单单说 TCP 连接，因为已经指定了协议，所以只剩下 【四元组】

我们需要先知道，服务端固定监听的是某个端口，比如我们自己写的服务，就是监听的 8080，运行起来它是不会变的

当建立起一个连接的时候，服务端会把这个连接给内部的线程进行管理，然后自己再去监听这个端口

因此，服务端是不存在 端口被占用，然后无法建立新连接这个问题的，问题是出在客户端

对于同个服务，【四元组】中，服务端 IP 和 服务端 端口 不会发生改变

改变的是客户端的 IP 和 客户端的 端口，

对于某个客户端来说，它的 IP 不变，如果它向服务发起多个连接，然后自己主动关闭，进入 TIME_WAIT 状态，那么就会导致这些端口这段时间内无法使用，那么当端口全部被占用时，这个客户端就无法再建立新的连接了

**综上，TIME_WAIT 过多，导致端口全部被占用时无法建立新连接的说法是针对客户端的**

**而 服务端 的 TIME_WAIT 过多 ，就是占用 内存资源 以及 占用线程资源（因为服务器每次 accept() 一个 socket，都是交给线程池中的线程去处理，当进入 TIME_WAIT 时，表示任务没完成，线程仍不能去执行其他任务）**

**而 TIME_WAIT 的时候服务端还是能够建立连接的，因为是内部线程在处理，监听端口没啥问题**
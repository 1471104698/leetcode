# Mysql 索引



## 1、为什么会出现索引

mysql 存储大量数据，底层的存储数据结构和查找结构 的设计 显得十分重要

索引是用来做数据的快速查找的，而快速查找的底层本质涉及到的是数据结构，通过不同数据结构的选择，可以实现不同的快速查找

在数据库中，使用高效的查找算法显得十分重要，当不使用索引的时候，那么查找 id = 7 的数据，只能通过暴力查找，找到 id = 7 的数据需要比较 7 次，如果表存储的是 1000W 的数据，那么查找 id = 1000W 的数据需要比较 1000W 次，这显然是无法接收的

因此，就出现了索引，用来加速查找

而选择哪种数据结构 作为索引的底层实现，就显得格外重要了

需要考虑到查找某个数据、范围查找 等各种查找条件的效率，除此之外，索引数据本身很大，所以不可能存储在 内存中，因此需要存储在硬盘中，这样的话查询 索引 就需要进行 磁盘 IO，而一次磁盘 IO 的消耗比内存存取要高几个数量级，因此，使用索引要尽量减少 磁盘 IO，即 磁盘 IO 的次数也成了索引 数据结构的选择之一



> ### 局部性原理

**局部性原理：当某个位置的数据被使用时，那么在不久的将来它附近的数据也会被使用**



由于磁盘 IO 中，寻道（磁头旋转到数据所在位置）时间消耗的时间最长，因此一般数据读取都会用局部性原理

每次磁盘 IO 读取数据往往不是按需读取，而是每次都会预读，假设本次 磁盘 IO 只需要一个字节，那么也会从这个字节的位置开始，往后读取一定长度的数据放入内存，由于操作系统的内存是分页管理的，因此每次预读的长度都是 页 的整数倍。

这样的 磁盘 IO 是顺序 IO，不需要进行寻道，直接往下读就行了，顺序 IO 下，从磁盘读取 1 B 的数据和 读取 1 KB 的数据花费的时间基本上是一致的



**因此，索引的底层数据结构选择要能够进行满足局部性原理的**



综上，索引的选择需要满足以下条件：

- 快速定位到某个值
- 能够进行范围查询，效率要高
- 磁盘 IO 次数少
- 利用磁盘每次预读 页 的整数倍的局部性原理，减少磁盘 IO



## 2、索引的底层数据结构选择



> ### 1、哈希表

通过 hash 算法 O(1) 定位到某个位置

假设我们求 id = 7 的数据，先通过 hash 算法求 7 映射的地址，然后获取对应的数据

但是 hash 算法会存在数据冲突，即两个以上的数据经过 hash 计算出的结果是一样的，这样就产生 哈希冲突

常见的做法是使用链地址法，这样的话，遍历数据就需要 从链表头遍历到链表尾



可以看出，哈希表能够 O(1) 查找数据，效率很高，但为什么索引不使用 哈希表呢？

- 不支持范围查询，哈希表等值查询效率最高，但是如果涉及到范围查询，由于哈希表之间的数据并无关联，因此一个可行的方法是查询出所有的数据，然后进行筛选，这样无异于就是暴力解法，效率极低
- 哈希冲突降低效率，当数据量大，链表长度长的时候，比如 100 个节点，最坏情况需要比较 100 次，这效率也是低。(虽然可以转换为红黑树，不过后面也会将为什么不使用红黑树)
- 哈希表不支持多列联合索引的最左匹配原则



> ### 2、二叉查找树

很简单，由于不会自己保持平衡，所以可能会退化成链表，查询效率低



> ### 3、AVL 树 和 红黑树

AVL 树 和 红黑树的区别就是 AVL 树是高度平衡的，保持平衡的开销比 红黑树大，但是由于保证了平衡，因此 AVL 的树的高度一般比 红黑树 低，这样的话，磁盘 IO 的次数也就比 红黑树少了



但是不使用它们的原因是因为它们是二叉树，本身节点存储的数据量少，导致当节点个数多的时候，树的高度很大，导致磁盘 IO 次数增加，降低效率

基本 AVL 和 红黑树都是数据存储在 内存中才会使用到的数据结构，因为这样可以避免磁盘 IO



> ### 4、B 树

B 树 是一棵平衡的多叉查找树，它与二叉树最大的不同就是，每个节点可以存储多个数据，而二叉树每个节点只能存储一个数据



当我们设置 B 树的每个节点可存储 key 的个数越多时，那么高度越小，比如 存储 16 个数据的 B 树，只需要 2 次 磁盘 IO，效率超过 AVL 树一半

![img](https://pic3.zhimg.com/80/v2-7d5e34c698b1e4192ad0ff93c2c897d0_720w.jpg)





B 树作为索引树，是通过 增加节点存储的数据量来减少树的高度，进而减少磁盘 IO

并且他每个节点都存储数据行，因此不会存在 聚簇索引 和 非聚簇索引 的概念

![img](http://cdn.17coding.info/WeChat%20Screenshot_20190620221029.png)



mysql 中的 B 树有几个特点：

- B 树查找效率为  O(hlogn)，h 为树的高度，n 为每个节点关键词的个数，当我们找到某个节点的时候，可以通过二分查找判断某个关键词是否存在，这样的话就是 O(logn)，而高度为 h，最坏需要 h 次，因此时间复杂度为 O(hlogn)
- 减少了磁盘 IO
- 每个节点既存储索引，又存储数据



```java
这里需要说下，B 树扩充每个节点存储的 key 的个数也同样利用了局部性原理加快速率

因为磁盘预读每次都是以 页的整数倍进行读取的，因此 B 树将每个节点的大小设置为页
这样每次读取的话就是刚好按照页为单位，读取一整个节点，既一次 IO 获取了整个节点
而这个节点中又存储了很多的 key，提高了查询的数据量，因此提高了查询的效率
```



> ### 5、B+ 树

B 树每个节点存储的都是索引和数据，而 B+ 树除叶子节点外，每个节点存储的都是索引，不包括数据，数据只存在于叶子节点上

B+ 树非叶子节点的 key 在叶子节点上都能找到，因为非叶子节点不存在数据，所以对应 key 的数据必须存在于叶子节点中

![img](http://cdn.17coding.info/WeChat%20Screenshot_20190621220003.png)



由于 B 树每个节点存储了索引和数据，而 B+ 树除叶子节点外每个节点只存储 索引，而 mysql 中每个节点的大小固定设置为 一个页的大小，因此 B 树每个节点所能存储的 key 比 B+ 树少，因此 B+ 树一个节点能存储更多的 key，借此可以直接通过 一次 磁盘 IO 和 二分查询 判断更多的数据

并且由于每个节点能够存储的 key 更多，导致每一层的数据量就更多，从而使得树的高度减少，磁盘 IO 数量减少



而 B+ 树的叶子节点是通过指针相连来构成链表的，这样直可以很方便进行范围查询



B+ 树 相对 B 树的优点：

- 除叶子节点外其它节点都是存储索引，这样在每个节点都是固定一页的情况下，能够存储的 key 更多，一层能够存储的数据量比 B 树大得多，从而使得树的高度更低，磁盘 IO 的次数更少
- B+ 树的叶子节点使用 链表串起来，范围查询的效率更高

B 树 和 B+ 树的节点上面也说了，就是利用局部性原理，才设置大小为 一页的



**综上，不选择其他数据结构，就是因为 B+ 树满足索引所需的全部优质条件：范围查询性能好，树的高度低，磁盘 IO 次数少，且支持 多列联合索引的最左匹配原则**





## 3、索引 的 种类

> ### 1、聚簇索引

聚簇索引 表示索引树的叶子内的数据就是完整的数据行

如果表设置了主键，那么主键构成的索引树就是 聚簇索引，它的叶子节点存储完整的数据行

如果没有设置主键，那么找到第一个 not null 属性 的唯一索引作为聚簇索引

如果还没有，那么使用 InnoDB 在每行数据后面 生成的隐藏字段之一的 row_id 作为 聚簇索引



如下图就是 聚簇索引 的索引树，叶子节点就是完整的数据行

*![image.png](https://pic.leetcode-cn.com/1599556528-sXLuAF-image.png)*



> ### 2、非聚簇索引

除 聚簇索引 索引外的其他所有，都是 非聚簇索引

比如设置了主键为 聚簇索引 后，那么剩下的唯一索引也会称为 非聚簇索引

它的特点是叶子节点存储的是 对应所在数据行的 聚簇索引

意思是我们查找 非聚簇索引 的话，需要进行两次查找才能得到完整数据行

- 第一次查找 非聚簇索引 的索引树，在叶子节点处得到 聚簇索引 的值
- 第二次查找 聚簇索引 的索引树，在叶子节点处得到完整的数据行

因此查找 聚簇索引 效率比 查找 非聚簇索引 效率高



**拿着 从 非聚簇索引 的索引树上查找到的 聚簇索引 的值，再从 聚簇索引 的索引树上查找数据，这个过程叫做回表**



下图就是查找 非聚簇索引 的索引树，以 age 字段构成的索引，对比上述的 聚簇索引的索引树看，叶子节点对应的是上述 聚簇索引 的值

*![image.png](https://pic.leetcode-cn.com/1599556509-eedyXk-image.png)*



> ### 3、为什么一个表只存在一个 聚簇索引 ？多设置几个提高查询效率不好吗？

我们需要知道，聚簇索引 它的叶子节点存储的是完整的数据行，当一个表的数据量达到 上千万，上亿 的时候，那么对应的这个 索引文件将会是非常大，如果多设置几个，并且还有多个表，这空间占用，这谁顶得住？？？





> ### 4、联合索引

联合索引说的是多个列组成一个索引，构建一棵索引树

比如 (id, age, name) 就是将 id、name、age 三个列建立成一个索引树，数据存放 以及 查询的顺序从左到右，因为 索引树是 B+ 树，它是一棵多路平衡查找树，内部自动是有序的，而这个排序则是按照 联合索引的列的定义顺序来的，因此排序是先按照 id，如果 id 相同再按照 age，如果 age 相同则再按照 name

因此，当我们使用联合索引进行查询的时候，需要注意查询条件的使用，因为索引树内部是有排序的，因此表面看来，所有数据的排序初始是根据索引的第一个列来进行排序的，尔后才是根据第二个列。因此如果第一个列没有使用到，这就意味着这棵索引树某种意义上就变成了无序的了

因此，联合索引 满足最左匹配原则

![img](https://pic2.zhimg.com/80/v2-b2506d877144b08f52f46d1f2157ce35_720w.jpg)



比如 `idx_a_b_c` (`a`,`b`,`c`) 

```java
 select  * from test where a = '333' and b = '333' and c = '333'; //走索引，走 a b c

 select  * from test where a = '333' and b = '333'; //走索引，走 a b 

 select  * from test where a = '333' and c = '333';//走索引，走 a

 select  * from test where  b = '333' and c = '333'; //不走索引，因为索引树是按照 a 排序的，a 不查询的话 索引树就无序了

 select  * from test where c = '333' and b = '333' and a = '333'; //走索引，走 a b c，这也表示了联合索引的查询跟 where 语句中条件的出现顺序无关，内部会自动调整，只要出现即可

 select  * from test where a = '333' and b like '%3' and c = '333'; //走索引，只走 a，因为 b 无法确定前面的数值，这样的话就是无序的了

 select  * from test where a = '333' and b like '3%' and c = '333'; //走索引，走 a 和 b，因为 b 能够确定前面的数值，因此还是有序的
```



> ### 5、覆盖索引

覆盖索引是针对某种 select 来说的 联合索引

就是查询的字段全部在索引上，这样的话就无需回表



比如 `idx_a_b_c` (`a`,`b`,`c`) 

```java
 SELECT a,b,c from test where a = '333'; //无需回表，因为 a b c 三个列构成了一棵索引树，而查询的字段 a b c 都在这棵索引树上，因此无需再去 聚簇索引 的索引树上进行回表查询

 SELECT a,b,c,d from test where a = '333'; //需要回表，因为查询的字段 a b c d 中，只有 a b c 在索引树上，而字段 d 没有，因此需要到 聚簇索引 的索引树上获取对应的完整数据行，然后获取字段 d 的值
```



**由此可知，身为 聚簇索引一定只需要查询一遍索引树，而非聚簇索引 的可能只需要查询一遍索引树（覆盖索引），也可能需要查询两边索引树**

**因此，一般我们建立索引，查询字段尽可能满足 覆盖索引，这样可以少一遍 索引树的查询**





## 4、索引无效情况

- 比如上面的联合索引情况中，不满足最左匹配原则的，以及 使用 like 的部分情况

- 联合索引中，只要有一列出现 NULL 值，那么索引也会失效，因此平常注意设置为 非 NULL

- 查询条件 IS NULL 、 IS NOT NULL、!= 这些 有时候走索引，有时候不走，看 mysql 查询优化器的优化，判断哪种成本低**（在 B+ 树中，将 NULL 值认为是最小值，因此它会在 索引树的最左边）**

- or 字段会使索引失效，因为两个满足其一就算是结果，不能够在索引树上查询，直接走全表，如果连接的是同一个字段，那么有可能走索引，看查询优化器

- 对于可以使用索引的，查询优化器根据查询条件获取对应的索引，计算扫描全表的成本，如果发现扫描全表的代价更低，那么不走索引，索引失效

  

  
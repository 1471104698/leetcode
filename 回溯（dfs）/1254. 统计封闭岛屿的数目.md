## **[1254. 统计封闭岛屿的数目](https://leetcode-cn.com/problems/number-of-closed-islands/)**

```java
有一个二维矩阵 grid ，每个位置要么是陆地（记号为 0 ）要么是水域（记号为 1 ）。

我们从一块陆地出发，每次可以往上下左右 4 个方向相邻区域走，能走到的所有陆地区域，我们将其称为一座「岛屿」。

如果一座岛屿 完全 由水域包围，即陆地边缘上下左右所有相邻区域都是水域，那么我们将其称为 「封闭岛屿」。

请返回封闭岛屿的数目。
```

##   

## **示例 1：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/11/07/sample_3_1610.png)

```java
输入：grid = [[1,1,1,1,1,1,1,0],[1,0,0,0,0,1,1,0],[1,0,1,0,1,1,1,0],[1,0,0,0,0,1,0,1],[1,1,1,1,1,1,1,0]]
输出：2
解释：
灰色区域的岛屿是封闭岛屿，因为这座岛屿完全被水域包围（即被 1 区域包围）。
```



## **示例 2：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/11/07/sample_4_1610.png)

```java
输入：grid = [[0,0,1,0,0],[0,1,0,1,0],[0,1,1,1,0]]
输出：1
```





## **实现思路**

```java
题目要求的封闭陆地是四周都有水域，即陆地不能是靠近边界，因为边界外面没有水域

使用 dfs，找到陆地位置，然后深搜，当遇到水域的时候返回 true，只有 4 个方向都存在水域，才是封闭陆地
1、如果到达边界了，意味着不是封闭陆地
2、或者 4 个方向存在一个方向不是水域，那么也不是封闭陆地，但是这时候先不返回结果，而是记录下去，将与当前陆地连通的其他陆地都置为 1 表示已经遍历过了
	防止造成错误结果
	
错误原因：
如以下例子
[1,1,1,1,1]
[1,1,0,1,1]
[1,1,0,1,1]
	 👆
	如果我们先遍历的是这个位置，发现它靠近边界，那么我们是先置为 1 ，如果直接返回，那么数组就变成以下情况：
[1,1,1,1,1]
[1,1,0,1,1]
[1,1,1,1,1]
	这样对下次遍历找到中间那块陆地的时候会发现四周都是水域，导致错误，因此我们直接将周围连通的陆地都置为 1
```





## **实现代码**

```java
class Solution {
    public int closedIsland(int[][] grid) {
        /*
        dfs
        封闭岛屿必须上下左右都存在水域，如果岛屿是在边界，那么也不能算是封闭，因为边界外面没有水域
        */
        rlen = grid.length;
        llen = grid[0].length;
        int c = 0;
        for(int i = 0; i < rlen; i++){
            for(int j = 0; j < llen; j++){
                //如果当前位置是陆地并且是周围都是水域，那么表示是封闭陆地
                if(grid[i][j] == 0 && dfs(grid, i, j)){
                    c++;
                }
            }
        }
        return c;
    }
    
    int rlen;
    int llen;
    int[][] pos = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
    /*
    是否是一个封闭的岛屿
    */
    private boolean dfs(int[][] grid, int i, int j){
        //如果到达了边界 表示没有遇到水域，不是封闭的
        if(i < 0 || i == rlen || j < 0 || j == llen){
            return false;
        }
        //遇到水域
        if(grid[i][j] == 1){
            return true;
        }
        grid[i][j] = 1;
        boolean flag = true;
        for(int[] p : pos){
            //四个方向有一个方向不是水域，那么就构不成封闭陆地，但是我们先不返回，而是记录结果，然后继续 dfs，将周边连通的陆地都置为 1
            if(!dfs(grid, i + p[0], j + p[1])){
                flag = false;
            }
        }
        return flag;
    }
}
```


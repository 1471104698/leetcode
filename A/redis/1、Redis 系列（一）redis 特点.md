# redis 特点



## 1、为什么使用 redis?

因为 redis 是基于内存实现的，单单在数据存储方面无论是查找还是别的，都比 mysql 数据库快，因为 mysql 数据库的数据存储在 磁盘中，每次都需要进行 I/O 操作，寻道时间 redis 就不知道能够执行多少条命令了，效率相差太多

并且它内部自己实现了很多简洁高效的数据结构，应用场景广泛



## 2、redis 快的原因

- 完全基于内存操作，不需要进行 磁盘 IO，因为 磁盘 IO 比 内存操作的时间要高出很大的数量级
- 单线程，避免了频繁的线程上下文切换和锁的竞争（比如 dict 不够用进行 rehash 的时候，无需加锁，因为不存在别的线程）
- 网络层 使用 epoll 模型
- 高效的数据结构 + 合理的编码格式，redis 内部自己实现的数据结构，简单而且效率高，根据数据的情况会进行转变



> redis 为何使用单线程？

[何种情况下 单线程 比 多线程更好？](https://www.cnblogs.com/caihuafeng/p/5438753.html )



首先我们要明白多线程的使用意义，只有在 IO 操作的时候，CPU 会空闲，这样的话就需要让 CPU 去执行别的线程，这样 CPU 才不会浪费

如果任务都是 CPU 密集型（计算密集型）的，CPU 不会空闲，这样的话如果使用多线程这里执行一点，那里执行一点，由于存在进程/线程上下文切换，这就导致比 单线程顺序执行还慢了（线程上下文切换时间足够 CPU 执行 几万条指令了）

同时，多线程的情况下还需要防止共享资源的数据错乱，所以又需要加锁，又会产生锁的争夺



需要注意的是， redis 的单线程不包括后台的一些操作，比如 AOF 重写、生成 RDB 之类的，对于这些操作是会重新开一个子进程的

**redis 的单线程 是 使用一个线程处理三方面的数据：从 socket 读取数据 + 处理用户请求 + 将数据写回 socket**

对于 用户请求处理，由于完全是 CPU 密集型的，不涉及任何的 IO 操作，所以不需要使用多线程

但是对于 socket 读取数据 和 数据写回 socket，虽然使用的是 IO 多路复用模型，但是 读取和写回 都涉及到 用户态 和 内核态 的数据拷贝，一旦某个 socket 需要读取或者写回大数据，那么就会影响其他 socket 操作

因此，**在 redis 6.0 就 另开一组多线程 来处理 socket 读写了，但是 处理用户命令 仍然是单线程**



> redis 6.0 的多线程处理模式

redis 6.0 使用的 IO 多路复用模式类似 Reactor 的 多线程 IO 单线程业务处理

它使用一个 主 Reactor 来监听 socket 的建立，然后使用 socket IO 分摊到各个 从 Reactor 上，不过每个 从 Reactor 没有维护一个线程池，它们的 socket IO 自己处理，而业务逻辑则是交到同一个线程去处理，即 redis 的用户请求处理仍然是单线程的





## 3、Redis 使用场景

- session 共享
- 缓存
- 排行榜
- 分布式锁
- 数据库分布式 id 生成器（使用 incr and get 命令，因为单线程，不存在线程安全问题）
## **[498. 对角线遍历](https://leetcode-cn.com/problems/diagonal-traverse/)**

```java
给定一个含有 M x N 个元素的矩阵（M 行，N 列），请以对角线遍历的顺序返回这个矩阵中的所有元素，对角线遍历如下图所示。

示例:

输入:
[
 [ 1, 2, 3 ],
 [ 4, 5, 6 ],
 [ 7, 8, 9 ]
]

输出:  [1,2,4,7,5,3,6,8,9]
解释:
```

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/diagonal_traverse.png)





## **实现代码**

```java
class Solution {
    public int[] findDiagonalOrder(int[][] matrix) {
        /*
            行索引和列索引的总和相等的数字属于同一对角线。
            我们使用 map 记录某个 索引和（即某个对角线） 的结果集

            如果索引和 为偶数，那么反序添加，如果为 奇数，那么正序添加
        */

        Map<Integer, List<Integer>> map = new HashMap<>();

        int rlen = matrix.length;
        if(rlen == 0){
            return new int[0];
        }
        int llen = matrix[0].length;

        //索引和最大值
        int maxIdxSum = 0;

        for(int i = 0; i < rlen; i++){
            for(int j = 0; j < llen; j++){
                int sum = i + j;
                if(!map.containsKey(sum)){
                    map.put(sum, new ArrayList<>());
                }
                maxIdxSum = Math.max(maxIdxSum, sum);
                map.get(sum).add(matrix[i][j]);
            }
        }
        int[] res = new int[rlen * llen];

        for(int i = 0, j = 0; i <= maxIdxSum; i++){
            List<Integer> list = map.get(i);
            if((i & 1) != 0){
                for(int val : list){
                    res[j++] = val;
                }
            }else{
                for(int k = list.size() - 1; k >= 0; k--){
                    res[j++] = list.get(k);
                }
            }
        }

        return res;
    }
}
```


# 并发标记产生的问题 - 浮动垃圾 和 对象消失

## 1、三色标记

GC 中定义了三种颜色：白色、灰色、黑色

白色：没有 GC roots 链引用的对象或者还没有扫描的对象

灰色：已经扫描过的对象，但是还存在引用没有扫描

黑色：已经扫描过的对象，并且它的所有引用都已经扫描了

**在 GC 中，最终标记还是只会剩下 白色 和 黑色，灰色扫描完后最终会变成黑色**

**GC 标记结束时，标记为白色的对象，表示不可达，会被回收**

![img](https://user-gold-cdn.xitu.io/2020/2/23/170726139d42da78?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

 ![img](https://upload-images.jianshu.io/upload_images/7779607-eecbd09f81b721f8.gif?imageMogr2/auto-orient/strip|imageView2/2/w/706/format/webp) 



## 2、并发标记的问题二：对象消失

正常情况下是这样的

![img](https://user-gold-cdn.xitu.io/2020/2/23/1707265e1a8f8b43?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



但是，并发标记的过程中，用户可能会修改引用，使得尚未扫描到的存活对象扫描不到了，导致它被垃圾回收

比如下图：当  5 扫描完成后，接着是扫描 6 的，而本来 6 是指向 9 的，但是由于用户线程的修改了引用，导致 6 和 9 间的引用断开了，而 5 指向了 9，因为 5 已经标记为黑色，而 6 不存在与 9 的引用，这意味着 9 不会被标记，而最终只能是白色，而被回收掉，但实际上它是存活的对象

![img](https://user-gold-cdn.xitu.io/2020/2/23/1707266cd4d9d2fb?imageslim)





## 3、并发标记的问题一：浮动垃圾

浮动垃圾的产生就是已经扫描过变成黑色的认为可达的节点，由于用户线程引用关系的变化，使得这些节点不可达，但是由于是黑色的，所以在此次 GC 中不会被回收，导致变成浮动垃圾，比如下面的 节点 7、8、4、10、11 都是浮动垃圾

![img](https://user-gold-cdn.xitu.io/2020/3/1/17093d3d3ee999f4?imageslim)





## 4、解决 对象消失一：增量更新

它关注的是引用的增加，不关心引用的删除

它规定，黑色对象一旦插入 白色对象后，它就会重新变成灰色

在重新标记阶段，**重新扫描一遍 GC roots，遇到黑色节点会直接跳过**，而遇到白色和灰色的节点就会被标记，不会出现漏标的对象消失问题



由于 CMS 使用的是增量更新，只关心引用的增加，不关心引用的删除

CMS 从 GC roots 重新扫描一遍，为了防止漏标的代价比较大，但是浮动垃圾少，只有在已经扫描过的黑色节点被删除引用的时候会产生浮动垃圾



## 5、解决 对象消失二：快照 SATP

它关注引用的删除

在 并发标记时，每当存在引用类型的变更（这里的变更不是增加，而是删除 或者 删除当前引用然后指向别的对象），那么就会使用  pre-write barrier 把旧的引用关系 记录下来，将旧的引用关系存储到队列中，然后在 remark 中处理这些旧关系，防止对象消失

但是 SATP 会导致相比 CMS 来说更多的浮动垃圾的存活，比如用户线程修改了引用，这个对象已经没有引用了，是需要回收的，但是按照快照又给它恢复成有引用的样子，导致它在此次 GC 中不会被回收

但是优点在于 在重新标记阶段不会扫描整个 GC roots，只会处理 SATP，所以 STW 比 CMS 更短，但是浮动垃圾比 CMS 多，留到下一次 GC 处理



![img](https://user-gold-cdn.xitu.io/2020/2/23/170726d12a19361a?imageslim)





# 
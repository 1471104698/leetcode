# TCP 的可靠性实现



## 1、确认应答机制

TCP 是面向字节流的传输，对每个字节都进行了编号

比如 客户端 这次传输了 [1,100]，那么序列号就是 1，然后服务端接收后发送一个 ACK = 101 ，表示下次期望收到 101 的序列号数据报

 ![img](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeuicRMlA8rKvl5AVLibhibDhg7rhicME5YSPXZCicwvDpdicChuibpe3AbuavGsDNz5ibPIicibF6wiaJHlKlFQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1) 



## 2、重传机制

> ###  超时重传

当

- 发送端发送的数据包丢失，接收方没有接受到数据所以没有发送 ACK
- 接收方发送的 ACK 丢失

上面两种情况都导致发送方没有收到 ACK

在发送方发送完一个包后，会启动重传计时，如果在超时等待时间内，收到了 ACK，那么就无需重传

如果是超过 超时时间，那么认定为数据包丢失



超时时间如何设置？

通过 RTT（报文往返时间） 来计算 RTO（超时时间）

（RTT 是通过 TCP 上面选项的时间戳来计算的，TCP 报文头部的选项字段有一个 时间戳，是报文发送时的时间）

每次超时重传的超时等待时间，是先前设置的两倍，因此多次超时重传等地的时候周期会很长



**超时重传存在重传的等待的时间过长，因此就出现了快速重传**

> ### 快速重传

快速重传的出现是为了减少超时重传的超时等待情况，因为在特定情况下，很大概率是出现了丢包问题，这样的话就无需超时等待，直接重新发送数据包就行了，去掉了超时等待的时间

也说了，只有在特定情况下，才会是快速重传，其余情况下是超时重传

而这个特定情况就是：在超时重传等待时间内，收到 3 个重复的 ACK



![img](https://pic2.zhimg.com/80/v2-0434a2de30645ee6d809bb30f0ad551c_720w.jpg)

- 数据发送使用的是滑动窗口，发送方发送窗口内的多个数据：seq1、seq2、seq3、seq4、seq5，假设 seq2 在网络中丢失了
- 然后接收方按照顺序，只接收到了 seq1、seq3、seq4、seq5，没有接受到 seq2 的数据，因此它接收到 seq1 后期望收到的是 2 号数据，因此 发送 ACK 2，而后续数据可以接收处理，但仍然回送 ACK 2，表示没有接收到 seq2
- 而发送方在 se3、seq4、seq5 这 3 个 ACK，而且都是 ACK 2的，表示 seq2 在网络中丢失了，因此重新发送 seq2
- 当接受方接受到 seq2 时，由于之前已经处理了 seq3、se4、seq5，因此这次无需再发送 ACK 3，而是表明下次接收的是 ACK 6 了



> ### 为什么  快速重传是 通过 3 个 重复 ACK 来判断丢包的

两次 重复 ACK 肯定是数据包乱序造成的

三次 重复 ACK 可能是数据包乱序造成的，也可能是数据包丢失造成的

而反过来说，数据包丢失必定会造成 三次重复 ACK，即三次重复 ACK 我们按照概率问题，忽略掉数据包乱序的情况，直接判定为数据包丢失，懒得等待超时了，直接重发数据，这也就是快速重传的思想



**为什么 丢包必定会造成 3 次 ACK ？**

这个前提下，是对发送了 4 个以上数据包来说的，因为一般情况下的通信，发送肯定超过 4 个数据包，因此是满足条件的

A 为发送方，B 为接收方

假设 A 按照顺序发送了 N - 1、N、N + 1、N + 2 号的数据包，我们探讨 A 收到 ACK(N) 的情况

B 方到达的顺序有

- N-1，N，N+1，N+2   这种情况 A 会收到 1 个 ACK(N) 
- N-1，N，N+2，N+1   这种情况 A 会收到 1 个 ACK(N) 
- N - 1，N + 2，N，N+1   这种情况 A 会收到 2 个 ACK(N) 
- N - 1，N + 1，N，N+2   这种情况 A 会收到 2 个 ACK(N) 
- N - 1，N + 2，N + 1，N   这种情况 A 会收到 3 个 ACK(N) 
- N - 1，N + 1，N + 2，N   这种情况 A 会收到 3 个 ACK(N) 

上面的是数据包乱序 收到的 ACK 个数的各种情况

如果是丢包的情况，假设 N 号数据包丢了（要看 ACK(N)，就只能第一个是 N - 1，如果第一个不是 N - 1，那么发出的就是 ACK(N - 1) 了），那么 B 收到的顺序只剩下两种情况：

- **N-1，N+1，N+2**，收到 3 个 ACK(N)
- **N-1，N+2，N+1**，收到 3 个 ACK(N)



可以发现

- 1 - 2 个 ACK 只能发生在乱序的情况下
- 乱序的所有情况下，收到 3 个重复 ACK 的概率为 2 / 6 = 33%

- 而 丢包的概率下 100% 会收到 3 个 重复的 ACK，基于此，舍弃掉 33% 概率的超时等待，直接重发数据包







## 3、滑动窗口



> ### 为什么需要滑动窗口

因为 TCP 使用了确认应答机制，每发送一次数据都需要接收到 ACK 后再发送下一部分数据，效率过低

如果没有滑动窗口的话，那么发送数据的过程如下：

- TCP 是每发送一次数据，都要进行一次应答确认，即得到 上一个数据包的 应答，才发送下一个数据包

- 如果每次数据发送的大小都是一个 TCP 报文的话，那么就有点像你我两个人聊天，你一句我一句的，你说我回，我回了你才能继续说

- 如果你说了一句话，而我在干别的事，那么你需要等待我干完，你还必须重新说那句话，这样效率低下



因此，引入了滑动窗口，根据接收端的接收处理能力，来发送更多的数据

**当使用窗口的时候，无需等待收到确认应答，只要在窗口大小内还有可发送数据，那么可以直接发送**



窗口的实现实际上是操作系统内部的一个缓存空间，当你发送出数据后，直到收到确认应答，才可以删除对应的数据缓存，否则，那么需要根据缓存的数据进行重发



**累计确认：**

发送方发送了 【100，299】的数据，然后再发送【300，599】的数据，然后再发送【600，699】的数据

按理说发送方是需要收到 ACK = 300，ACK = 600，ACK = 700 这三个 ACK 包的，但是

接收方的接收缓冲区中有 【100，699】字节范围的数据，当接收方处理了 【100，599】的数据，会发送一个 ACK  = 600，当发送方收到 ACK = 600 时，表示【100，599】都已经处理完毕了，那么就没必要再等 ACK = 300 了

如果 ACK = 600 在网络中丢失了，客户端重发，而接收方处理完【600，699】的数据后发送了 ACK = 700，那么当客户端收到 ACK = 700 后，即使没有收到 ACK = 600 也没关系，因为已经知道 接收方已经处理了。而**接收方接收到客户端重发的数据（即收到重复的报文），发现已经处理过了，也不会再处理了，但是会回发一个 ACK = 600 再次告知 发送方，防止发送方重发报文**



> ### 窗口发送大小由哪一方决定？

窗口大小由接收端决定

TCP 中有 窗口大小  这个字段，接收方会在 ACK 中设置该字段，告诉发送方自己现在还能接收多少数据

发送端就可以根据服务端的接收能力来发送对应大小的数据，而不会一股脑的发送数据，超出服务端的处理能力





> ### 发送方的滑动窗口

发送方的窗口分为四个部分：

- 已发送并且已经收到 ACK（处理完毕， #1： 1 - 31 字节）

- 已发送但未收到 ACK（服务端尚未处理完毕，或者 ACK 还在路上，#2：32 - 45 字节）

- 未发送但是可以发送（服务端还能接收数据，这些数据现在可以发送给服务端，但是现在还没有发送，

  #3 ：46 - 51 字节）

- 未发现并且现在不能发送（后面的这些数据不能发送，因为超出了服务端的接收能力，#4 ：52 - 56 字节）



*![image.png](https://pic.leetcode-cn.com/1597993856-goRUji-image.png)*



如果 32 - 36 字节收到 ACK 后，那么缓存空间中会删除掉这些数据，并且窗口会往右边移动，到达 56

*![image.png](https://pic.leetcode-cn.com/1597994071-LvuLnd-image.png)*



滑动窗口 4 个部分的表示是使用 3 个指针来区分的，即相当于我们使用 write 和 read 指针来压缩字符串一样

SND.WND：窗口大小变量

SND.UNA：第一个指针，位于窗口的第一个字节，表示窗口的起始位置

SND.NXT：已发送数据的末尾位置，同时也是可发送数据的起始位置，SND.NXT - SND.UNA 即为 #2 的大小

*![image.png](https://pic.leetcode-cn.com/1597994129-NGveQS-image.png)*



> ### 接收方的滑动窗口

没啥好说的，比较简单

*![image.png](https://pic.leetcode-cn.com/1597994365-FJXXeT-image.png)*





## 4、流量控制

如果发送方不考虑接收方的处理能力，发送数据过快，那么接收方的接收缓冲区数据堆积，当满了的时候就无法获取到新的数据，那么存在以下问题：

- 发送方后面发送的数据全部都会丢失，然后发送方会由于无法收到 ACK 而一直超时重发，拥堵网络**（主要问题）**
- 接收缓冲区数据堆积，发生 TCP 粘包（当然这个是可以简单解决的）



流量控制是基于滑动窗口实现的， **接收方会告诉发送方自己的接收缓冲区还能够接收多少数据，发送方根据接收方告知的大小进行数据发送**





## 5、拥塞控制

 [滑动窗口 和 拥塞窗口的关系](https://www.zhihu.com/question/264518499)



<img src="https://img-blog.csdnimg.cn/20190731155254165.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDMxNDA2,size_16,color_FFFFFF,t_70" style="zoom:80%;" />



计算机网络都处在一个共享的环境。因此也有可能会因为其他主机之间的通信使得网络拥堵。 

如果网络拥堵的话，发送方继续发送大数据，那么很可能会导致数据包延迟、丢失等问题，这时候发送方会超时重传，继续发送大数据，但是一旦重传，又会加重网络拥堵，导致更多数据丢包，然后又重传，恶性循环不断加大

因此出现了拥塞控制算法：**慢启动、拥塞避免、快重传、快恢复**



### 5.1、慢启动

TCP 在最开始建立好连接后，不会立马发送大数据，而是会一点一点提高数据量

- 最开始指定拥塞窗口 cwnd = 1，表示只能发送一个 MSS（最大报文长度） 大小的数据
- 当收到 1 个 ACK 后，cwnd +1，一次能够发送 两个 MSS 大小的数据
- 当收到 2 个 ACK 后， cwnd +2, 一次能发送 4 个MSS 大小的数据
- 当收到 4 个 ACK 后， cwnd +4，，，， 当收到 8 个ACK 后，cwnd +8

拥塞窗口 cwnd，同时也是该阶段的慢启动的数据发送量，它是按指数增长的，但是它有一个阈值 ssthresh 



**只要 cwnd 小于 ssthresh ，那么就使用慢启动**



### 5.2、拥塞避免

慢启动很明显可能让 TCP 连接的传输速率到达一个很理想的值，但是通道的宽度是有限的，不可能一直这么指数增长下去

因此当慢启动到达阈值 ssthresh ，那么就开始 拥塞避免 算法，拥塞避免是**线性增长**的

比如 ssthresh = 8，那么 此时 cwnd = 8：

- 那么后续每次收到一个 ACK 时，cwnd 就会增加 1 / cwnd，即 1 / 8（八分之一）

- 那么意思就是需要接收到 8 个 ACK，才能凑齐一个 1，cwnd 才能变成 9

- 后续就需要接受到 9 个 ACK，才能凑齐一个 1，cwnd 才能变成 10



### 5.3、快重传 和 快恢复



[TCP reno版本的快恢复算法最后一步为什么重置窗口？ - 网聚金水的回答 - 知乎](https://www2.zhihu.com/question/53168634/answer/154822905 )

 [拥塞控制算法，讲得挺不错](https://zhuanlan.zhihu.com/p/59656144)



早期的 TCP 拥塞控制，并没有 快重传和快恢复，

因此，有报文在网络中丢失时，就会导致发送方超时重传，而误认为发生了网络拥堵，

**重新开始慢启动**，将 cwnd 重新设置为 1，这表示数据发送又只能从 1 开始了，传输效率降低了

如图：

<img src="https://img-blog.csdnimg.cn/20190731165605396.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDMxNDA2,size_16,color_FFFFFF,t_70" style="zoom:80%;" />



因此，为了解决一出现丢包就重新开始慢启动而导致传输效率大幅度降低的问题，出现了快重传和快恢复

快重传 和 快恢复 是同时发生的

快重传：

```java
因为出现 3 个重复的 ACK，那么就非常可能是报文丢失（具体看上面的重传机制讲解），因此当收到 3 个 重复 ACK 时，不会等待超时时间到，直接重传丢失的报文
```

快重传同时进入快恢复，这里不进入到慢启动的理由是：

```java
重复收到 3 个 ACK，表示接收方实际上是收到了别的报文，但是收到的报文序列号不连续，所以判断丢失了报文返回丢失的报文 ACK，因此可以断定 发送方 和 接收方 网络环境可能拥堵，但是不会完全拥堵，因为接收方还可以接收报文回送 ACK，因此没必要进入慢启动
```

快恢复：

```java
1、将慢启动阈值 ssthresh 设置为 cwnd（拥塞窗口）的一半，即 ssthresh = cwnd / 2，然后将 cwnd 设置为 ssthresh + 3，即 cwnd = cwnd / 2 + 3 = ssthresh + 3
2、快重传丢失的报文后再次收到重复的 ACK，那么 cwnd + 1
3、如果收到新的数据包的 ACK，表示接收方已经收到了丢失的数据包，那么将 cwnd 设置为前面的 ssthresh，重新开始拥塞避免算法

1 中为什么最开始 cwnd = ssthresh + 3 中要 + 3？
	因为它认为收到 3 个重复的 ACK，表示网络中离开了 3 个旧的数据包，那么久可以再塞 3 个新的数据包进去，因此这里 + 3  
```


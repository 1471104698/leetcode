# redis 的 keys 和 scan 指令





有这么一道题：

假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？

答案：

使用 keys 指令可以扫描出指定的 key 列表，但是会使得线程阻塞，即这段时间 redis 不能提供服务

使用 scan 指令可以无阻塞的提取出指定的 key 列表，但是可能会有重复的 key，需要在服务器后台做一次去重，整体花费的时间会比 keys 长



上面的 scan 指令出现 key 重复的原因跟 dict 的渐进式 rehash 有关

具体看 <https://zhuanlan.zhihu.com/p/40681473>



## 1、keys

```test
keys *
```

![1600843929506](C:\Users\蒜头王八\AppData\Roaming\Typora\typora-user-images\1600843929506.png)



keys 按照正则匹配，会一直性把所有的数据都查询出来，因此如果有几百万条数据，也会全部显示出来

keys 执行的过程中直接停止 redis 服务，不会处理用户的请求，因而统计出来的 key 不会存在重复

时间复杂度 O(n)



## 2、scan

具体看 <http://chenzhenianqing.com/articles/1101.html>



scan 的时间复杂度也是 O(n)，但是跟 keys 的不同在于：

- scan 有一个游标，用于控制下次获取数据的位置
- scan 有一个 count，可以空着每次获取的数据集的数据数



### 1、scan 重复 key 的问题

scan 在扫描的过程中会继续处理用户的请求，即 scan 和 用户指令是并发执行的

这样的话，如果 scan 的是 hash 的 dict，就会存在三种情况：

- scan 整个过程中，没有发生过 rehash
- scan 整个过程中，在用户没有调用 scan 时，进行过 rehash，并且完成了扩容 或 收缩
- scan 整个过程中，遇到正在执行 rehash



> ### 情况①

对 scan 没什么影响，直接 O(n) 扫描 ht[0] 即可



> ### 情况②

```java
发生的原因是 scan 是等待用户调用的，如果不设置 count 默认返回 一个游标 和 10 条数据
游标是下次访问的位置，而如果在用户还没有再次调用 scan 的时候发生了 rehash，这样的话就导致游标的位置对不上了
```

**扩容：**

数组长度变为了原来的 2 倍，假设原来的 table 长度为 4，后面的长度变成了 8.

假设扫描完 3 号槽位，这时发生 rehash

将已经扫描过的 0、1、2、3  号槽位元素部分迁移到 ht[1] 4、5、6、7 号槽位，然后完成 rehash，将 ht[1] 赋值给 ht[0]，清空 ht[1]

这样的话，scan 在不知情的清空下遍历的对象变成了新数组，它会再去扫描 4 5 6 7 号槽位，这样导致扫描了重复的 key



**收缩：**

数组长度收缩为原来的一半，假设原来的 table 长度为 8，后面的长度变成了 4

假设扫描完 3 号 槽位，这时发生 rehash 

将 5 6 7 8 号槽位上的元素迁移到 ht[1]，然后赋值给 ht[0]，清空 ht[1]，完成 rehash

这样的话，scan 在不知情的清空下遍历的对象变成了新数组，对于迁移到 0、1、2、3 号槽位的新数据不会再去扫描，导致缺失了部分 key



> ### 情况③

如果在用户调用 scan 时发生了 rehash， ht[0] 中的 1 号槽位数据会被迁移到 ht[1] 中的 1 号 和 5 号槽位，这样 scan 就必须扫描 ht[0] 和 ht[1],如果 scan 扫描完 ht[0] 的 1 号槽位了，后面 rehash 将 1 号槽位上的数据转移到 ht[1] 上，这样后面扫描 ht[1] 会出现重复 key





### 2、解决问题



先贴下源码

```C
unsigned long dictScan(dict *d,
                       unsigned long v,
                       dictScanFunction *fn,
                       void *privdata)
{
    dictht *t0, *t1;
    const dictEntry *de;
    unsigned long m0, m1;

    if (dictSize(d) == 0) return 0;

    if (!dictIsRehashing(d)) {//没有在做rehash，所以只有第一个表有数据的
        t0 = &(d->ht[0]);
        m0 = t0->sizemask;
		//槽位大小-1,因为大小总是2^N,所以sizemask的二进制总是后面都为1,
		//比如16个slot的字典，sizemask为00001111

        /* Emit entries at cursor */
        de = t0->table[v & m0];//找到当前这个槽位，然后处理数据
        while (de) {
            fn(privdata, de);//将这个slot的链表数据全部入队，准备返回给客户端。
            de = de->next;
        }

    } else {
        t0 = &d->ht[0];
        t1 = &d->ht[1];

        /*
        将 t0 设置为小表，即 table 长度小的，将 t1 设置为大表
        主要是在收缩的时候，t0 是大表，t1 是小表，下面为了统一，进行交换
        */
        if (t0->size > t1->size) {
            t0 = &d->ht[1];
            t1 = &d->ht[0];
        }

        m0 = t0->sizemask;
        m1 = t1->sizemask;

        /* Emit entries at cursor */
        de = t0->table[v & m0];//处理小一点的表。
        while (de) {
            fn(privdata, de);
            de = de->next;
        }

        /* Iterate over indices in larger table that are the expansion
         * of the index pointed to by the cursor in the smaller table */
        do {//扫描大点的表里面的槽位，注意这里是个循环，会将小表没有覆盖的slot全部扫描一次的
            /* Emit entries at cursor */
            de = t1->table[v & m1];
            while (de) {
                fn(privdata, de);
                de = de->next;
            }

            /* Increment bits not covered by the smaller mask */
			//下面的意思是，还需要扩展小点的表，将其后缀固定，然后看高位可以怎么扩充。
			//其实就是想扫描一下小表里面的元素可能会扩充到哪些地方，需要将那些地方处理一遍。
			//后面的(v & m0)是保留v在小表里面的后缀。
			//((v | m0) + 1) & ~m0) 是想给v的扩展部分的二进制位不断的加1，来造成高位不断增加的效果。
            v = (((v | m0) + 1) & ~m0) | (v & m0);

            /* Continue while bits covered by mask difference is non-zero */
        } while (v & (m0 ^ m1));//终止条件是 v的高位区别位没有1了，其实就是说到头了。
    }

    /* Set unmasked bits so incrementing the reversed cursor
     * operates on the masked bits of the smaller table */
    v |= ~m0;
	//按位取反，其实相当于v |= m0-1 , ~m0也就是11110000,
	//这里相当于将v的不相干的高位全部置为1，待会再进行翻转二进制位，然后加1，然后再转回来

    /* Increment the reverse cursor */
    v = rev(v);
    v++;
    v = rev(v);
	//下面将v的每一位倒过来再加1，再倒回去，这是什么意思呢，
	//其实就是要将有效二进制位里面的高位第一个0位设置置为1，因为现在是0嘛

    return v;
}
```





下面为数组大小为 4、8、16 时 scan 的游标顺序值

```java
0				2				1				3
0		4		2		6		1		5		3		7
0	8	4	12	2	10	6	14	1	9	5	13	3	11	7	15
```



游标更新代码

```C
v |= ~m0;
//按位取反，其实相当于v |= m0-1 , ~m0也就是11110000,
//这里相当于将v的不相干的高位全部置为1，待会再进行翻转二进制位，然后加1，然后再转回来

/* Increment the reverse cursor */
v = rev(v);
v++;
v = rev(v);
//下面将v的每一位倒过来再加1，再倒回去，这是什么意思呢，
//其实就是要将有效二进制位里面的高位第一个0位设置置为1，因为现在是0嘛

return v;
```



以下的解决方法都是基于 高位 +1 更新游标来解决的



> ### 1、没有发生过 rehash

判断如果没有进行 rehash，那么定位到指定的槽位，获取所有的 key

这时访问的顺序是按照 高位+1 的游标顺序进行访问的，这个游标值的变化对顺序访问没有什么影响



> ### 2、rehash 扩容

假设最开始 size = 8，游标顺序：0 4 2 6

当扫描完 slot = 0 的时候，游标到达 4 的位置

这时候发生了 rehash 扩容， size = 16

那么 0 号槽位的元素部分迁移到 8 号槽位，1 号槽位部分迁移到 9 号槽位，4 号槽位部分迁移到 12 号槽位上

因此，由于新迁移的 8 号槽位上的数据在是已经访问过的 0 号槽位迁移过去的，所以是旧数据，无需再次扫描

而对于原来的游标顺序：0 4 2 6，由于扩容变成了 0 8 4 12，因此完美的跳过了 8 号槽位，接下来只需要扫描 4 号 和 12 号槽位，即可扫描完原本数据上 4 号槽位的完整数据，这样就保证了 key 既不会丢失，也不会重复



扩容是将原本一部分的数据给分散出去，

如果分散出去的内容如果是已经访问的，那么会按照游标的顺序跳过，不会重复访问

如果分散出去的内容还没有访问，那么会按照游标的顺序进行访问，不会缺失

**扩容原理如下：**

```java
//size = 8
0		4		2		6		1		5		3		7
		↑
		i
访问完 0，游标到达 4 位置，这时候发生扩容
//size = 16
0	8	4	12	2	10	6	14	1	9	5	13	3	11	7	15
    	↑
    	i
通过设置游标规则，将 0 分裂出来的部分卡在 4 的前面，比如 最开始是 0 4，然后 0 分裂出 8，
只要设置新的游标规则，将 8 卡在 0 和 4 的中间，这样从 4 前面的都是已经访问过的了，而后面的是未访问过的，因此不会重复访问
```



> ### 3、rehash 收缩

假设最开始 size = 16，游标顺序：0 8 4 12



当扫描完 slot = 0 的时候，游标到达 8 的位置

这时候发生了 rehash 收缩，size = 8

那么原本 8 号槽位的数据会被合并到 0 号槽位中，在使用游标进行定位的时候，8 的高位 1 会被 & 给注释掉，因此得到的槽位是 0，因此会重新再次访问 0 号槽位，使得原本已经访问过的 旧数组中的 0 号槽位数据被重新扫描，造成重复 key

然后游标的顺序由于收缩变成了 0 4 2 6，因此下一个游标位置是 4 号槽位



当扫描完 slot = 8 的时候，游标到达了 4 的位置

这时候发生了 rehash 收缩，size = 8

那么原本 8 号槽位的数据会被合并到 0 号槽位中，那么由于 0 和 8 都已经访问了，因此可以直接访问 4 号槽位，这样的话就不会造成任何的 key 重复 以及 缺失



收缩是将两部分内容进行合并

如果当前游标位置是合并的下半部分，即上半部分访问过了，合并起来的话就是下半部分的key 合并到访问过的上半部分中，而这个 游标通过 hash 会定位到上半部分的已经扫描过的 key，因此会造成重复的 key，但也只是一小部分，因为后面的 key 会按照游标顺序进行访问

如果当前游标位置是合并的上半部分，表示前面访问的在合并后都是一个完整的 key，不存在缺失问题，因此无需重复访问，按照新的游标顺序继续访问即可

**收缩原理如下：**

```java
//size = 16
0	8	4	12	2	10	6	14	1	9	5	13	3	11	7	15
    	↑
    	i
访问完 8，游标到达 4 的位置，发生收缩
//size = 8
0		4		2		6		1		5		3		7
		↑
		i
跟扩容的原理一样，通过同样的游标规则，由于 0 和 8 已经访问过了，并且 8 会合并到 0 上，因此无需进行重复访问
后续的 12 会 合并到 4 上，10 会合并到 2 上，因此按照新的游标规则进行访问即可


//size = 16
0	8	4	12	2	10	6	14	1	9	5	13	3	11	7	15
    ↑
    i
访问完 0，游标到达 8 的位置，发生收缩
//size = 8
0		4		2		6		1		5		3		7
    ↑
    i
由于 0 已经访问过了，而 8 会合并到 0 上，这时候游标停留在 8 上，并且 原本 8 的部分还没有访问
解决方法就是通过特定的 hash 规则，使得 8 hash 到 0 号槽位上，这样重新访问一遍 0 号槽位读取为扫描的部分，但同时也会读取到已经扫描的部分，造成重复 key，但也只是这原本的一个 槽位大小而已，因为后面的只需要按照新的游标规则进行访问即可
```



**由此我们也可以看到，扩容 和 收缩的游标都是遵循的 高位 +1 的规则，收缩后的游标规则是扩容前的游标规则**



> ### 4、scan 过程中发生 rehash 

如果在 scan 的过程中发生 rehash，那么会扫描 ht[0] 和 ht[1]，这样可以做到 不重复 和 不缺失



无论是扩容还是收缩都是通用的，如果是收缩，那么它会在开始前进行交换，将 t0 设置为小表，将 t1 设置为大表

```C
/*
        将 t0 设置为小表，即 table 长度小的，将 t1 设置为大表
        主要是在收缩的时候，t0 是大表，t1 是小表，下面为了统一，进行交换
        */
if (t0->size > t1->size) {
    t0 = &d->ht[1];
    t1 = &d->ht[0];
}
```



```C
do {//扫描大点的表里面的槽位，注意这里是个循环，会将小表没有覆盖的slot全部扫描一次的
    /* Emit entries at cursor */
    de = t1->table[v & m1];
    while (de) {
        fn(privdata, de);
        de = de->next;
    }

    //下面的意思是，还需要扩展小点的表，将其后缀固定，然后看高位可以怎么扩充。
    //其实就是想扫描一下小表里面的元素可能会扩充到哪些地方，需要将那些地方处理一遍。
    //后面的(v & m0)是保留v在小表里面的后缀。
    //((v | m0) + 1) & ~m0) 是想给v的扩展部分的二进制位不断的加1，来造成高位不断增加的效果。
    v = (((v | m0) + 1) & ~m0) | (v & m0);

    /* Continue while bits covered by mask difference is non-zero */
} while (v & (m0 ^ m1));//终止条件是 v的高位区别位没有1了，其实就是说到头了。

```

假设 t0.size = 8，t1.size = 64

scan 扫描的游标顺序为 0 4 2 6

假如 v = 0，它会先扫描 t0 的 0 号槽位，然后 do while 再扫描所有可能迁移到 t1 的槽位 0 8 16 24 32 64

这样的话，如果已经迁移过去的会被扫描到

能够做到不重复 和 不丢失

*![image.png](https://pic.leetcode-cn.com/1600860577-oUqbxU-image.png)*




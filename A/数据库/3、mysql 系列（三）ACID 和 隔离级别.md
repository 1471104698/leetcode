# ACID 和 隔离级别



## 1、数据库（事务）的四个特性（ACID 原则）

A：原子性，在事务 begin 和 commit 的过程中，所有的操作要么全部 commit 成功，要么全部 rollback 失败，成功就要应用于数据库，失败就不能对数据库有任何影响，基于 redo/undo 机制

C：一致性，你转给我 100，你那边就必须减100，我这边就必须加100，否则回滚，可以理解为数据一致性

I：隔离性，事务与事务之间是相互隔离的，即各自操作各自的数据，不能干扰，或者说 一个事务的数据修改不能反映到其他事务数据中，相当于事务之间使用的是数据的副本，互不影响

D：持久性：一个事务一旦被提交，在数据库中的数据改变就应该是永久有效的



原子性、隔离性、持久性 是为了保障一致性，即一致性是最终目的





## 2、脏读、不可重复读、幻读

脏读：当前事务能够读取到别的事务还没有提交的脏数据，由于读得到，所以可能会被当前事务使用，但是如果别的事务将这个数据回滚，那么就意味着当前事务是用了不存在的数据，问题很大

不可重复读：第一次 select 的某个数据行的数据 跟第二次 select 的相同数据行的数据不同，即别人 commit 后将这个数据行的数据修改了，结果被当前事务读取到了

幻读：当前事务第一次查询的数据只有 3 条，第二次查询的数据出现了 4 条，或者 变成了 2 条，跟出现幻觉一样，跟 不可重复读差不多，不过是别人添加和删除的数据被当前事务读取到了





## 3、四个隔离级别

四个隔离级别：读未提交、读已提交、可重复读、串行

四个问题现象：ABA 问题、脏读、不可重复读、幻读（不可重复读 和 幻读有点容易混淆）



以下的普通的隔离级别以及对应的问题，但是 Mysql 的可重复读已经解决了幻读现象，即跟串行化一样了，但是效率比串行化高![为了让你彻底弄懂 MySQL 事务日志，我通宵肝出了这份图解！](https://www.cxyxiaowu.com/wp-content/uploads/2020/06/1591519982-c25f8307996ae1d.png) 



> ### 读未提交

一个事务执行过程中，可以读取到另外一个事务修改的未提交的数据



假设 x = 100

事务 A 和 事务 B 都在操作 x，事务 A将 x 改为 50，但是还没有提交

而事务 B 获取 x 值，这时读取到的是 x = 50

这时候如果 事务 B 执行 x - 50 这个操作的话，那么 x 变成 0

而如果 事务 A 没有提交，而是回滚，那么意味着 x = 50 这个值是不成立的，而事务 B 在不成立的值上做了修改，导致最终的结果也是不成立的，因为事务 A 回滚了，表示 x 应该还是 100，那么事务 B 执行的 x - 50 的话，结果应该是 50

这个 隔离性最差，基本事务之间就没有隔离



这个在自己事务中能够读取到别的事务修改的数据，就是脏读



> ### 读已提交

一个事务执行过程中，不可以读取另一个事务修改未提交的数据，但可以读取到已提交的数据



假设 x = 100

事务 A 和 事务 B 两个事务并发执行，事务 B 使用 select 查询 x = 100，事务 A 修改了 x = 50，然后提交，事务 B 使用 select 再次查询 x = 50，发现前后两次查询结果不一样，这就是不可重复读（按照字面意思就是不能够重复读取之前的值，即之前读的值会被修改）



假设 x > 50 的有 3 条数据

事务 A 和 事务 B 两个事务并发执行，事务 B 查询 x > 50，发现有 3 条数据，事务 A 插入了 x = 60 的一条数据，事务 B 再次查询 x > 50 ，发现有 4 条数据，前面查询的数据量不一样，这就是幻读



读已提交能够解决脏读的问题，即读取到的都是提交的，已经确定的值，但因此会产生 不可重复读 和 幻读

其中，不可重复读是针对 update 的，单单是修改值，幻读是针对 delete 和 insert 的，会改变数据量



> ### 可重复读

一个事务执行过程中，不能读取其他事务未提交以及已提交的数据，相当于事务之间操作的都是数据的副本



其中是通过 MVCC（多版本并发控制）来实现的，因为别的事务提交了数据，数据已经更新了，怎么保证自己能够读取到自己原来的值呢？就是指定版本



> ### 串行

这个隔离级别就严重了，可以解决上述问题的任何问题，因为每次只允许一个事务执行，即是串行的，没啥用吧，在如今这个要求效率的时代，基本不会去用这种拖慢下来的东西


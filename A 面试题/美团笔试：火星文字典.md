# [美团笔试：火星文字典](<https://www.nowcoder.com/questionTerminal/29d1622d47514670a85e98a1f47b8e2d>)

## 题意描述

已知一种新的火星文的单词由英文字母（仅小写字母）组成，但是此火星文中的字母先后顺序未知。给出一组非空的火星文单词，且此组单词已经按火星文字典序进行好了排序（从小到大），请推断出此火星文中的字母先后顺序。  

#### **输入描述:**

```
一行文本，为一组按火星文字典序排序好的单词(单词两端无引号)，单词之间通过空格隔开
```

#### **输出描述:**

```
按火星文字母顺序输出出现过的字母，字母之间无其他字符，如果无法确定顺序或者无合理的字母排序可能，请输出"invalid"(无需引号) 
```



## 示例1

```
输入
z x

输出 
zx
```



## 示例2

```
输入
wrt wrf er ett rftt

输出 
wertf
```



## 示例3

```
输入
z x z

输出 
invalid
```



## 方法一：拓扑排序

### 实现思路

 拓扑排序，找入度为 0 的点
    输入
   `wrt wrf er ett rftt`
    输出
   `wertf`

####  过程：

- 由于所有单词都已经按照字典序排好序了
       并且排序的规则是按照第一个不同字符的大小进行排序的
       这意味着对于相邻字符，只有第一个不同的字符具有比较价值，其他的字符不能进行比较
       我们查找相邻字符串第一个不同的字符，比如上面的 wrt 和 wrf
       第一个不同的字符是 t 和 f，由于是按字典序排好序的，表示 t < f
       那么对于 f 来说，入度 +1
       同样进行对比，我们可以得出：
       wrt wrf -> t < f
       wrf er  -> w < e
       er ett  -> r < t
       ett rftt-> e < r
       使用数组 inpoint[i] 表示某个字符的入度
       那么 
       inpoint[w] = 0, inpoint[r] = 1, inpoint[t] = 1
       inpoint[e] = 1, inpoint[f] = 1
       当某个点的入度为 0，表示没有任何字符指向它，也就意味着它是最小的
       那么，我们将它所连接的边断开，将它指向的字符的入度 -1
       比如上面的 e，它的入度为 1 是因为有 w 指向它
       当我们处理完 w 的时候，将 e 的入度 -1，此时 e 的入度为 0
       表示小于 e 的所有字符都处理完了，当前最小的字符可以确定是 e
- 当不存在 0 入度 或者 存在多个 0 入度的情况
      不存在 0 入度的情况：
          比如 z x z
          z 指向了 x, x 也指向了 z
          它们的入度都不为 0，那么意味着它们之前都存在比它小的字符，那么就无法进行排序
      存在多个 0 入度的情况：
          比如 tr ef
          我们可以得知 
          inpoint[t] = 0, inpoint[e] = 1
          inpoint[r] = 0, inpoint[f] = 0
          存在多少 0 入度的情况，因为只有两个字符串，并且它们第一个字符就不相同
          那么根据字典序排序规则，只根据第一个不同的字符进行比较排序
          那么对于后面的字符来说，就不存在比较的价值
          那么后面的 r 和 f 它们无法进行比较

#### 数据结构：

​    1、使用一个 int 数组记录字符的入度
​    2、当需要删除边的时候，我们需要知道某个字符指向了哪些字符，
​        因此需要一个 List[26] 记录某个字符指向的字符列表
​    3、我们需要知道最终是否所有的节点都已经处理完毕，因此我们记录所有存在的字符数 set



### 实现代码

```java
import java.util.*;

public class Main{
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        Main main = new Main();
        //根据空格拆分
        String[] strs = sc.nextLine().split(" ");
        for(int i = 0; i < 26; i++){
            points[i] = new ArrayList<>();
        }
        //构建有向图
        main.build(strs);

        System.out.println(main.helper());
    }
    static List<Integer>[] points = new List[26];
    static boolean[] exist = new boolean[26];
    static int[] inpoint = new int[26];
    private String helper(){
        //出现的字符个数
        int size = 0;
        for(int i = 0; i < 26; i++){
            if(exist[i]){
                size++;
            }
        }
        
        List<Character> res = new ArrayList<>();
        
        //当已经添加的字符个数小于全部字符个数时，继续查找
        while(res.size() < size){
            //入度为 0 的节点个数
            int num = 0;
            int ch = -1;
            for(int i = 0; i < 26; i++){
                if(inpoint[i] == 0 && exist[i]){
                    num++;
                    ch = i;
                    exist[i] = false;
                }
            }
            //入度为 0 的字符不为 1
            if(num != 1){
                return "invalid";
            }
            res.add((char)(ch + 'a'));
            //将 ch 指向的字符入度 -1
            for(int c : points[ch]){
                inpoint[c]--;
            }
        }
        StringBuilder sb = new StringBuilder();
        for(char ch : res){
            sb.append(ch);
        }
        return sb.toString();
    }
    //构建图
    private void build(String[] strs){
        int len = strs.length;
        String pre = strs[0];
        for(char ch : pre.toCharArray()){
            exist[ch - 'a'] = true;
        }
        for(int i = 1; i < len; i++){
            String cur = strs[i];
            for(char ch : cur.toCharArray()){
                exist[ch - 'a'] = true;
            }
            for(int j = 0; j < Math.min(pre.length(), cur.length()); j++){
                int pch = pre.charAt(j) - 'a';
                int cch = cur.charAt(j) - 'a';

                if(pch == cch){
                    continue;
                }
                //cch 入度 +1
                inpoint[cch]++;
                //pch 指向的字符 +1
                points[pch].add(cch);
                break;
            }
            pre = cur;
        }
    }
}
```


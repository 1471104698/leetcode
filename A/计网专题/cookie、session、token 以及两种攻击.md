

## 1、cookie、session、token 的关系

> ### cookie、session、token 产生的背景

具体看：

 https://zhuanlan.zhihu.com/p/63061864 

 https://zhuanlan.zhihu.com/p/66754258 



最开始的互联网时代，服务器和客户端并不会去存储用户的状态。这段时间对服务端和客户端来说都很 happy

随着互联网的发展，像购物网站之类的兴起，越来越需要记住用户的状态，比如哪些人登录了系统，哪些人在购物车中放了哪些东西，这些全部需要将每个人区分开来，由于 HTTP 是无状态的，因此出现了一个新的事物 sessionID，作为一个会话的唯一标识，简单讲就是一个独一无二 的字符串，每个人收到的都不一样。因此发送 HTTP 请求的时候，只需要将 sessionID 一起发送过来，就知道是谁是谁了

但是，这样对用户来说爽了，对服务器来说可不是，因为用户只需要存储自己的 sessionID 即可，而服务器需要存储所有用户的 sessionID，当存在几千万，几亿个用户的时候，那对服务器内存来说就是一个巨大的开销

并且，在后来，出现了分布式，多台机器作为一个集群提供同一个服务，这样不同的用户就会被 推送 到不同的机器上去，而每台内存是不共通的，这样的话，假设 用户 A 在第一次请求同时进行登录，被推送到机器 1，机器 1 存储了用户 A 的 sessionID，用户 A 第二次请求被推送到机器 2，而机器 2 没有 用户 A 的 sessionID，因此会要求 用户 A 进行登录，这样显然是不友好的。因此就出现了这么几个方法：

- **粘性 session：**固定将某个用户推送到固定的某台机器上去
- **session 复制：**一个用户的 session 通过复制发放到每台机器上去
- **session 共享：**通过 redis 等缓存中间件存储 session，这样每台机器只需要到对应的 缓存中间件上去访问 session 即可，不过需要做成集群防止宕机

但是，有人就开始思考，为什么 tm 的服务器要保存这些可恶的 session 呢？只让每个客户端去保存多好

可是如果 服务端不保存 session，怎么验证客户端发送过来的 sessionID 是服务端生成的而不是伪造的呢？

嗯，只需要验证即可，只要能够做到验证，就可以舍弃掉 session

用户 A 登录了系统，服务端生成一个 token(n令牌)，里面包含了用户 A 的 userId，下次用户 A 再次请求的时候，直接将 token 发送过来，服务端进行验证即可。。。但是这本质上和 sessionId 没有什么区别，任何人都可以伪造啊。。。得想点办法

加密就行了，做成类似 CA 证书的那种，自己生成一个密钥，然后对混合到用户数据中，使用特定的 加密算法加密，做成一个 token，发送给客户端，让客户端自己存储，等到下次请求的时候，客户端将 token 发送回来，这样的话，服务端只要 使用对应的密钥 和 用户数据混合，再使用相同的加密算法加密，判断生成的 token 和 客户端发送过来的 token 是否一致，如果一致，则验证通过

这样的话，服务端就无需保存什么东西了，使用 token 代替 session，只需要让 客户端自己保存 token，服务端进行验证即可



> ### cookie、session、token 是什么？

**cookie**：cookie 是浏览器的一段纯文本信息，用户第一次访问时服务端会生成一个 cookie 和 一个 session，然后将 session 中的 JSESSIONID存储在 cookie 中，返回给客户端存储，**浏览器上每个域名对应一个 cookie**，每次发送请求前浏览器会自动去查看 是否缓存了对应域名的 cookie，如果有则获取然后一并发送给服务端



**session：**session 是存储在服务端的，session 可以存储某个用户的很多数据，这样在用户登录查询的时候就减少对数据库的操作，但是占内存；客户端只存储一个 JSESSIONID，并且如果开启了 cooike 那么就存储在 cookie 中，如果没有那么客户端就单纯存储一个 JSESSIONID 字符串



**token：**解决 服务端存储 session 的问题，服务端不保存，只需要将 token 发送给客户端，后续用户登录的时候将 token 发过来按照一定规则进行验证即可



当浏览器禁用 cookie 时，存在两种验证方式：

- 浏览器保存 sessionID，然后在请求的时候直接发送 sessionID，这种的服务器需要存储 session
- 浏览器保存 token



> ### token 相比 session 的优点

session 

- 需要服务端存储，当有大量用户的时候会占内存
- 在分布式的情况下需要考虑 session 共享问题
- 可能会发生 CSRF 攻击







## 2、CSRF 攻击

CSRF 就是未经本人许可以本人的名义发送恶意请求（修改密码，银行转账等）

CSRF 攻击原理是 **浏览器分不清发起请求的是否是用户本人，每次请求都会带上 cookie，而 cookie 内部又有用于验证身份的 sessionid**



**CSRF 攻击模拟：**

- 用户 X 登录了某银行网站 A，这时候银行后台会发送一个 cookie 给 X，浏览器会保存这个 cookie
- X 被一个危险的网站 B 诱导访问
- 网站 B 中内部有一个隐藏的 form 表单，是 POST 请求的，当用户 X  点击了某些东西的时候，就会触发这个表单的提交事件，表单提交的内容是向 银行网站 A 要求将 X 的 1000 元转账到 中间人 F 账户中
- 这时候由于 X 访问 网站 B 的浏览器同时也是之前访问 银行网站 A 的浏览器，因此浏览器会将 cookie 跟着请求一起发送给银行网站 A，网站 A  收到后发现有 cookie 就不再进行登录验证，而是执行转账
- 这样， X 的 1000 元就没有了

我们可以看出，中间人 F 他并没有获取 X 的 cookie，他并不知道 X 的 cookie 的内容，只是通过 X 点击了某些东西触发了表单提交，使得浏览器发送出请求；这相当于是 存在一个转账请求按钮，不过不是 用户 X 自己点的，而是 中间人 F 帮助 用户 X 点的，因此浏览器无法察觉这是否是来自用户的请求，只是一味的将请求发送出去



CSRF 防范手段：

- 使用验证码：比如转账这种重要请求，就不能单单只是靠 cookie，而是需要发送验证码让用户自己确认是否执行这个请求，在一定强度的验证码下，中间人机器是无法识别的，比如图片高斯模糊，然后给定很多个文字，让点某个文字
- 添加 Referer 字段：从上面的 HTTP 请求报文头部我们可以看出来存在这么一个字段，它指向的是发起请求的来源地址，对于本次转账请求，来源地址就是 网站 B；服务端需要做的是就是验证这个网站是否是信任网站，不是的话则拒绝响应
- token 验证：





## 3、XSS 攻击 - 脚本注入攻击

百度百科：

```
“XSS是跨站脚本攻击(Cross Site Scripting)，为不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故将跨站脚本攻击缩写为XSS。恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页之时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。”
```

简单讲就是 js 注入



XSS 攻击的危害：

- 使用  document.cookie 命令获取用户的 cookie，这样就无需用户的密码即可登录用户的账号
- 劫持流量恶意操作：参考 2011年微博 XSS 攻击，大量的用户受到 XSS 攻击自动发布微博，关注用户等



XSS 防范手段：

- 过滤 <script> 等标签
- 对 <> 等符号进行编码转换
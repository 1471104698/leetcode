## **[剑指 Offer 59 - I. 滑动窗口的最大值](https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/)**

```java
给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。

你可以假设 k 总是有效的，在输入数组不为空的情况下，1 ≤ k ≤ 输入数组的大小。
注意：本题与主站 239 题相同：https://leetcode-cn.com/problems/sliding-window-maximum/
```



## **示例:**

```java
输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3
输出: [3,3,5,5,6,7] 
解释: 

  滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
```





## **方法①、双端队列**

## **实现思路**

```java
        使用双端队列，记录某个滑窗内的最大值的索引
            为什么记录最大值的索引，而不是记录最大值？
            因为为了方便判断某个最大值元素是否属于该滑窗范围内的，如果不是，那么直接弹出

        注意：队列是先进先出，那么队首就是最先进入的元素，队尾就是最后进入的元素
        以下我们将队内元素这样看： tail（队尾） - xxx - head（队首）

        [1,3,1,2,0,5] k = 3
        1、遍历 1，队列为空，直接添加
            deque = {1}
        2、遍历 3，队尾元素 1 比 3 小，因此对于滑窗范围来说，最大值肯定是 3，由于 1 比 3 更快出现，因此 1 会比 3 先弹出，那么无论 1 弹不弹出，最大值都会是 3，				那么后面必定不会用到这个 1，那么直接将 1 弹出
            deque = {3}
        3、遍历 1，队尾元素 3 比 1 大，因为 3 比 1 更快出现，因此 3 会比 1 先弹出，那么当 3 弹出后，1 可能会成为 滑窗的最大值，因此需要将 1 添加进去
            deque = {1, 3}
        4、遍历 2，首先判断了 3 的索引位置超过了滑窗范围，因此将 3 弹出
            deque = {1}
            队尾元素 1 比 2 小，因为 1 比 2 更快出现，因此 1 会比 2 先弹出，但是对于滑窗来说，2 的出现会导致 1 必定不会是最大值，那么将 1 弹出
            deque = {2}
        5、遍历 0，队尾元素 2 比 0 大，由于 2 比 0 更快出现，因此当 2 弹出后，可能 0 会成为滑窗最大值，因此将 0 入队
            deque = {0, 2}
        6、遍历 5，队尾元素 0 比 5 小，5 的出现会导致滑窗最大值不会是 0，因此将 0 弹出，
            deque = {2}
            继续判断，由于队尾元素 2 比 5 小，因此将 2 弹出，将 5 入队
            deque = {5}
```



## **实现代码**

```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        int len = nums.length;
        if(len == 0){
            return new int[0];
        }
        //双端队列，接口 和 栈一样
        Deque<Integer> deque = new LinkedList<>();

        int[] res = new int[len - k + 1];
        int j = 0;
        for(int i = 0; i < len; i++){
            //队首元素超过滑窗范围，直接弹出
            if(!deque.isEmpty() && i - deque.peek() >= k){
                deque.poll();
            }
            //从队尾开始看，如果队尾元素比当前元素小，那么弹出
            while(!deque.isEmpty() && nums[deque.peekLast()] < nums[i]){
                deque.pollLast();
            }
            deque.add(i);
            if(i >= k - 1){
                res[j++] = nums[deque.peek()];
            }
        }
        return res;
    }
}
```


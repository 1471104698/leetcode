# TCP 问题

## 1、SYN Flood（攻击 SYN 半连接队列）

**服务端存在两个队列，一个是 SYN 队列（半连接队列），一个是 Accept 队列（连接队列）**

SYN 队列是存储第一次握手接收到的客户端的 SYN 请求，将这个请求放到 SYN 队列中，

Accept 队列是 第三次握手，服务端收到客户端的 ACK 后，将连接从 SYN 队列移除，放到 Accept 队列 中，然后应用程序通过调用 `accept() ` 来获取 Accept 队列 中的连接



正常流程：

- 当服务端接收到客户端的 SYN 报文时，会将其加入到内核的「 SYN 队列」；
- 接着发送 SYN + ACK 给客户端，等待客户端回应 ACK 报文；
- 服务端接收到 ACK 报文后，从「 SYN 队列」移除放入到「 Accept 队列」；
- 应用通过调用 `accpet()` socket 接口，从「 Accept 队列」取出的连接。

![1597974574685](C:\Users\蒜头王八\AppData\Roaming\Typora\typora-user-images\1597974574685.png)



**SYN 攻击是针对三次握手的**

攻击者伪造不同 IP 地址 发送 SYN 报文请求连接，当 服务端 收到 SYN 后会 回发 SYN + ACK ，然后将这个半连接放到 SYN 队列中，由于 IP 地址是伪造的，所以 服务器发送了 SYN + ACK 后是不会收到 ACK 回应的，那么这些连接会一直待在 SYN 队列，导致队列被塞满，**后续对于其他用户的连接请求只能丢弃**



> ### 解决方法：SYN cookie

在 SYN 队列满了的时候，其他用户的 SYN 请求不直接丢失，而是使用 SYN cookie 的方式来解决

- 在 SYN 队列没有满之前，服务器发送 SYN + ACK 报文内的初始序列号 seq 是一个随机数

- 当 SYN 队列满了之后，不直接舍弃掉其他的 SYN 连接，而是对这个 seq 进行改造，通过客户端 IP 地址、端口号、服务器 IP 地址、端口号 以及 其他的一些安全数值 等进行 hash 运算，然后进行加密，得到的结果 称作 SYN cookie，然后使用它作为 SYN + ACK 报文的初始序列化 seq

- 当服务器收到客户端的 ACK 报文时，将报文的 确认号 - 1 得到 s1，然后通过再使用相同的信息进行一次 hash 运算，加密，得到 s2，然后将 s1 和 s2 进行对比，如果相同，那么连接成功



**不直接舍弃 SYN 队列，然后全部使用 SYN cookie 的原因：**使用 SYN cookie 需要使用 CPU 进行大量计算，当高并发情况下，如果对每个 SYN 连接都进行 CPU 计算，那么显然 CPU 效率就低了





## 2、TCP 半打开连接 和 半关闭连接

TCP 连接是全双工的

全双工：一个端点 既能够发送数据又能够接收数据

半双工：一个端点 只能够发送数据或者接收数据

半打开连接和半关闭连接就是相对全双工来说的，TCP 连接的端点中存在一个端点只能发送数据或者接收数据



> ### 半打开连接

从 TCP 协议上看，半打开连接是指 TCP 其中一个端点 A 异常断电 或者 关闭时未告知另外一个端点 B，这种情况下 端点 A 就不能正常接收数据，如果 B 给 A 发送数据，那么 A 会回发一个 RST 包

从 Linux 实现的角度看，Linux 上 三次握手时有个 SYN 队列，这时没有收到 ACK 包的 TCP 连接都存储在 SYN 队列里，称作半连接，应该可以叫做半打开连接



> ### 半关闭连接

一个端点 A 发送了 FIN 包，一个端点 B 还没有发送 FIN 包，这样的话，端点 A 是不会发送用户数据，但可以发送 FIN 包 和 接收数据，端点 B 可以发送数据也可以接收数据，这样的 TCP 连接就处于半关闭状态

比如四次挥手（FIN - ACK - FIN - ACK），发送方发送了 FIN 包，而接收方可能还有数据要处理，因此不会立马发送 FIN 包，只会发送一个 ACK 包，这时候 TCP 连接是 半关闭连接；等到接收方处理完数据完，发送 FIN 包





## 3、MSS 如何确定

MTU：数据链路层中以太网对传输数据大小的限制

MSS：TCP 最大报文段长度，即除去 TCP 头部、IP 头部 后 TCP 所能发送的真正的用户数据

在 数据链接层上转发 的 IP 报文是有一定的长度限制的，这个长度限制就是 MTU（最大传输单元），当 IP 报文超过这个长度，那么就会进行 IP 分片，使得每一片都小于 MTU，才能进行转发

因此，**MSS = MTU - TCP 头部（20字节） - IP 头部（20字节）**



使用 MSS 是为了在 TCP 层进行分片，而避免在 IP 层进行分片，因为一旦在 IP 层进行分片，那么只要存在任何一片丢失，整个 TCP 报文就需要重新发送一次，这样重发的概率就加大了，明显不划算





## 4、长连接、短连接

所谓的连接指的是 TCP 连接，而不是 HTTP 连接

短连接就是 TCP 短连接，长连接就是 TCP 长连接

HTTP 协议实际上没有连接一说，平常所说的 HTTP 连接实际上就是 TCP 连接，

HTTP 协议是基于 请求/响应的，当收到一个请求，返回一个响应后，这个 HTTP 请求就结束了



当使用短连接时， 三次握手后，一般是进行一次 HTTP 请求/响应后就发起 close()，然后进行四次握手，即一个 TCP 短连接对应一个 HTTP 请求，

```
HTTP 1.0 的时候使用的就是短连接，由于一个 HTTP 请求/响应表示一个短连接，也导致了一个请求在没有得到响应前是不能发送另外一个请求的
```



当使用长连接时，三次握手后，这个 TCP 连接可以复用，即可以进行多次 HTTP 请求/响应，当一段时间没有 HTTP 请求/响应时，这个长连接就会断开

```
HTTP 1.1 使用的管道就是建立在长连接的基础上的，可以同时发送多个请求，然而响应的顺序还是根据请求的顺序来的
```





HTTP 协议是运行在应用层上的协议，它不会管数据的传输，它只负责告诉 TCP 哪些数据要发送，以及从 TCP 那接收数据

而 TCP 来保证数据的可靠传输，作为发送方就需要保证数据的可靠发送，作为接收方就需要保证数据的有序

HTTP 将数据交给 TCP，TCP 会按照特定情况进行封装，标记上序列号之类的，然后进行发送，丢失了还会进行重发

TCP 接收方获取到数据后，会根据序列号进行拼接，然后将拼接好的有序数据交给 HTTP

而实际数据的传输是 TCP 交给 IP 来做的



## 5、TCP 保活定时器

保活计时器是建立在长连接的基础上的，即开启  Keep Alive 来使用长连接的时候同时也会使用这个功能，即是跟长连接绑定的



服务端存在一个计时器，当一个 TCP 连接在一段时间内（默认 2h）没有任何 HTTP 请求/响应时，那么服务端会发送探测报文给客户端，一共会发送 10 次，每次间隔 75s，客户端有以下几种状态：

- 客户端正常，那么会回应探测报文，服务端收到回应报文后会重新开始计时
- 客户端断电或者正在重启，无论是哪一种，客户端都不会回应报文，因此服务端发送完 10 次探测报文后会认为客户端已经断开了，那么就将 TCP 连接断开
- 客户端断电后重启，那么对于客户端来说连接失效，这时收到探测报文，客户端会发送一个 RST 报文，告知服务端发生异常，直接断开连接
- 客户端正常，但是网络拥堵，导致服务端发送 10 次后没有收到回应报文，那么断开连接

**保活计时器的作用就是避免客户端出现问题了，而服务端不知道，一直在保持着连接，浪费资源**





## 6、CLOSE_WAIT 状态

**前置知识点：**

- CLOSE_WAIT 是被动关闭一方存在的状态，TIME_WAIT 是主动关闭一方的状态
- 调用 close() 后内核会发送一个 FIN + ACK 报文



**CLOSE_WAIT 状态的产生：**

发送方调用 close()，发送一个 FIN + ACK 报文（第一次挥手），接收方当收到 FIN + ACK 后，会先发送一个 ACK 给发送方（第二次挥手），告知自己确认收到关闭消息，由于自己可能还有数据没有处理 或者 还没有发送完毕，因此不会立马发送 FIN + ACK，此时处于 CLOSE_WAIT 状态，等到数据都处理和传输完毕了，接收方调用 close() ，发送 FIN + ACK （第三次挥手），此时从 CLOSE_WAIT 转换为 LAST_ACK 状态



因此我们可以看出，接收方只有在调用 close() 后才会从 CLOSE_WAIT 状态 解脱，如果一直没有调用 close()，那么接收方将长时间处于 CLOSE_WAIT 状态，直到过了超时时间，异常关闭，发送 RST

因此 **服务器产生大量 CLOSE_WAIT 状态的主要原因就是 服务器数据传输完毕都忘记在最后调用 close()**





## 7、TIME_WAIT 状态

> ### 为什么需要 TIME_WAIT  状态？

- 确保 TCP 全双工正常关闭

  ```
  比如客户端发起 FIN，这时候客户端关闭了发送数据的能力，服务端接收到后发送 ACK，后续再发送 FIN，这时候服务端也关闭了发送数据的能力，如果客户端收到服务端的 FIN 后回应一个 ACK 后就断开连接，那么如果由于网络拥堵等问题服务端没有收到 ACK，服务器就会重发 FIN，而客户端关闭连接后不会保存上一个连接的信息，因此收到后会发现这是一个不存在的连接，因此会发送一个 RST 包，服务端收到 RST 包后就会触发异常，不能正常关闭
  ```

- 确保旧数据包不会应用到新的连接中

  ```
  如果客户端第一次发送 FIN，但是由于网络问题没有到达服务端，超时重发 FIN 包，而后收到服务端的 ACK 和 FIN 包后回应一个 ACK 客户端就关闭了，然后后面客户端又用这个相同的【四元组】起一个新的连接，此时如果刚刚最开始发送的 FIN 到达服务端，并且序列号也对的上，那么就会导致新建的连接出现了混乱。。。
  ```



> ### 为什么 TIME_WAIT 是 2MSL？

一个包的最大存活时间为 MSL
客户端给服务端发送 ACK 报文后，假设经过时间 t

- 如果服务端能够接收到 ACK 报文，存在 0 < t < MSL
- 如果服务端没接收 ACK 报文，存在 t >= MSL



服务端等待 ACK 报文时间最大为 MSL，而如果等不到发送了 FIN 报文 或者在接收到 ACK 报文的一瞬间发送了 FIN 报文，这个 FIN 到达客户端的时间最大也为 MSL

因此在 ACK 发送到 服务端，再到服务端重发 FIN 到达客户端的这个时间端，临界逼近 2MSL，因此 TIME_WAIT 设置为 2MSL



**在这 2MSL 里，这个【四元组】是不能被建立起新的连接的，因此就防止旧的 FIN 包影响到新的连接**

2MSL 是考虑最坏情况下的时间，尽管很多时候都是不存在这个极端情况的，但是总归是要防止 "万一"



**服务器高并发情况下容易出现大量 TIME_WAIT**



> ### 大量 TIME_WAIT 的问题

客户端一个 socket 连接占用一个端口，当大量 TIME_WAIT 导致客户端端口占满时，那么客户端就无法建立新的连接

服务端一个 socket 连接占用一个文件描述符 和 4KB 内存，文件描述符的个数是有限的，因此当大量 TIME_WAIT占满了文件描述符，那么就无法建立起新的连接，并且还占据内存



> ### 大量 TIME_WAIT 解决

- 调整参数缩短 TIME_WAIT 时间
- 使用长连接代替短连接（不过一般不这么用，长连接只是取消了 TIME_WAIT 的状态，在没有请求的情况下照样是 占用一个文件描述符）
- 开启 TIME_WAIT 快速回收与重用





## 8、糊涂窗口综合征

**糊涂窗口综合征 是由于发送方的发送速率 和 接收方的处理速率 不对等产生的**

有时候由于 发送方一直发数据，而接收方处理不及时，导致发送方的可发送窗口逐渐减少，可能直至关闭

极端情况下，接收方每次只处理 1B，导致发送方的可发送窗口一直为 1B，这样的话，当发送方有很多数据需要发送，而发送窗口只有 1B 时，这样每次发送都为 1B，而加上 TCP 报文头部 和 IP 报文头部 40B 后整个报文大小 共 41B，这 41B 在网络上传输，真正有意义的数据只有 1B，而频繁发送这种小包，网络带宽中被 TCP 报文头部 和 IP 报文头部 占用的开销就很大了

**这种情况叫做糊涂窗口综合征**



因此为了解决 大量小包在网络中传输的情况，出现了 **Nagle 算法**，它指定满足任意一个条件时才会将窗口的数据发送出去：

- 缓冲区的数据达到 MSS
- 缓存区的数据存在 FIN 标志位
- 超时可等待的时间（即等很久了数据还没到 MSS，那么就不等了，直接发送了）





## 9、TCP 拆包/粘包



> ### TCP 为什么会发生 拆包/粘包？

TCP 是基于字节流的，本身没有 界限 的概念，报文 只是作为传输过程中字节数组的载体，所以 TCP 字节流是可以进行分割的，也可以跟别的数据合并到一个报文中进行发送，究其原因就是 **字节流可分割，并且没有标明数据的界限**

而 UDP 是基于报文的，一个报文内部就是一个完整的 UDP 数据，不可分割，一旦分割那么该数据就作废，所以必须在一个包中



> ### 发生粘包、拆包的情况

1、**发送方需要发送的数据太大，超过了发送缓冲区的大小**，无法一次发送，这时候就需要将数据作为多次发送，导致拆包；

而最后发送的数据可能还没有发送 就来了新的数据，新的数据 和 这个旧数据混合在一个发送缓冲区中，合并到一个报文发送出去，导致粘包

2、**发送方需要发送的数据超过了MSS**，这样数据就需要分片，情况就跟上面的一样了

3、**接收方处理不及时：**接收方没有及时处理数据，导致几个数据包堆积在接收缓冲区中，产生粘包

4、**Nagle 算法：** TCP 默认开启了 Nagle 算法来解决糊涂窗口综合征，所以如果某个报文数据小于 MSS，同时又不是 FIN 包，同时在超时时间内又来了一个新的数据，那么会发生粘包（新的数据可能发生拆包）



> ### 粘包、拆包问题解决

- TCP 头部添加报文长度
- 发送方 和 接收方 约定 报文固定长度，数据不够长度的使用填充，数据超过长度的分为多个包

- 在一个数据的尾部加上结束符，比如 \n\r，这样接收方可以根据结束符进行分割

- 关闭 Nagle 算法





## 10、收到重复报文怎么做？

接收方接收到客户端重发的数据（即收到重复的报文），发现已经处理过了，也不会再处理了

但是会回发一个 ACK = 600 再次告知 发送方，防止发送方重发报文
# sync 和 volatile



## 1、CPU 缓存模型 和 JMM



> ### CPU 缓存模型

早期的 CPU 的 速度 和 内存是差不多的， CPU 处理完 能很快写入内存

但是如今，CPU 的指令执行速度快得一批，内存的速度跟不上了，比如 1s CPU 需要写入 100 个数据，而 内存 1s 只能写入 1 个数据，这样的话，如果 CPU 就相当于降低速度去写数据，效率降低

为了解决这个问题，在 CPU 和 内存 中间引入了 cache，即高速缓存，它的速度跟 CPU 差不多，CPU 只需要将数据复制到 cache 中，然后去干自己的事，让 cache 慢慢将数据写入到内存中

需要注意的是：现在每台计算机不再是单核 CPU ，而是多核 CPU，每个 CPU 多对应一个自己的 cache

这样的话，就涉及到 **缓存一致性**

 ![img](https://pic2.zhimg.com/80/v2-3caf591483d67ccfd6ca01ef054a146f_720w.jpg) 

> ### JMM（Java 内存模型）

JMM 又叫 Java 内存模型，它跟 `jvm` 不一样啊。别搞错了啊。。。



它会规定了 内存只要有两种：主存 和 工作内存

主存 就是 物理内存，一般是堆栈内存空间（堆栈都存在 变量和对象）， 工作内存是 CPU 缓存、寄存器

工作内存 中的数据是对主存中的 一部分数据的 拷贝，线程 不能直接操作主存的数据，需要先将主存的数据拷贝到 工作内存中，然后在工作内存中修改完数据，再将工作内存中的数据写回主存

这么做的原因是可以控制多个线程的 读写操作，免得多线程操作主存数据需要对主存数据加锁，这样降低了并发效率



但是，由于 CPU 使用了缓存，所以在存在多个 CPU 的情况下，会由于 数据不可见 从而导致 数据不一致的问题

比如 CPU1 将缓存行写回主存，但是 CPU2 中的缓存中还是旧数据，在不需要访问新数据的情况下，CPU2 是不会再去访存的，它只会默默使用自己的缓存数据。

因此，我们需要有一种手段，当更新了数据的时候，需要告知 别的 CPU 需要去更新数据了

在 Java 中使用的 volatile 变量，在 GC 中使用的是 写屏障

 ![img](https://picb.zhimg.com/80/v2-f0364f6f863d5730e2b962ac6b3387e2_720w.jpg) 





## 2、volatile 实现原理

volatile 是用来保证 数据可见性的，但不能保证原子性



在 JDK 1.5 的时候，volatile 变量是禁用 CPU 缓存的，CPU 每次使用只能去主存里读，这样就保证了 volatile 变量一定都是最新值，但是这样明显效率很低

之后 volatile 保证可见性是通过 happens-before 规则实现

但 happens-before 规则实际上也仅仅是一个规则，真正实现该规则的是 **缓存行失效 + 立即写回内主存 + 禁止指令重排序**



> ### 缓存行失效 + 立即写回内主存

```java
private volatile int a = 1;
```

当 CPU1 控制的线程 A 修改了 a 变量，由于它是 volatile 修饰的，那么 CPU 会立马将 修改后的 a 的值从工作内存（缓存）中写回主存，其他 CPU 通过嗅探总线发现自己缓存行中存在任意一个内存地址中的数据被修改过，那么就会无效该缓存行，在使用的时候重新读取数据



volatile 保证可见性有两个方面：

- 修改完会立即写入主存
- 会通知其他 CPU 对应缓存行无效

**volatile 不仅仅保证 修饰变量 的保证可见性，它还会保证在 修饰变量 之前修改的变量的可见性**

比如下面的 f 和 a 和 b，由于 a 和 b 在 f 之前修改，那么 f 写回主存的时候，会一并将 a 和 b 写回主存，同时使得其他 CPU 中存在 a 和 b 的缓存行无效，保证了它们的可见性

```java
class Main{
    private volatile boolean f = false;
	private int a = 2;
	private int b = 3;
    
    public void set(){
        a = 3;
        b = 4;
        f = true;
    }
}
```



> ### 指令重排序

volatile 能够 **禁止 指令重排序**



JVM 会将代码编译成一条条的指令，指令重排序就是 修改指令的执行顺序 来提高性能

下面是一段 C 语言代码：

```C
int a, b;
void foo(void)
{
	a = b + 11;
	b = 0;
}

```

通过工具查看编译结果：

```C
0000000000000750 <foo>:
 750:   90000080        adrp    x0, 10000 <__FRAME_END__+0xf6b8>
 754:   90000081        adrp    x1, 10000 <__FRAME_END__+0xf6b8>
 758:   f947dc00        ldr     x0, [x0, #4024] // 取b内存地址
 75c:   f947e821        ldr     x1, [x1, #4048] // 取a内存地址
 760:   b9400002        ldr     w2, [x0]        // 寄存器w2 = b(内存地址)
 764:   b900001f        str     wzr, [x0]       // b(内存地址) = 0
 768:   11002c40        add     w0, w2, #0xb    // 寄存器w0 = b + 11 
 76c:   b9000020        str     w0, [x1]        // w0寄存器的值存入a(内存)
 770:   d65f03c0        ret
 774:   d503201f        nop

```

**编译得到的汇编代码和我们原本的C语言代码不顺序并不一致**，相当于是下面的 C 语言代码：

```java
int a, b;
void foo(void)
{
    b = 0;
    a = b + 11;
}

```



在单线程时代这个没有什么问题，如果是在多线程环境下，指令重排序可能还是会造成数据不可见

```java
class Main{
    private volatile boolean f = false;
	private int a = 2;
	private int b = 3;
    
    //线程 A 调用
    public void set(){
        a = 3;
        b = 4;
        f = true;
    }
    //线程 B 调用
    public void get() throw Exception{
        while(!f){
            Thread.sleep(100);
        }
        System.out.println(a);
        System.out.println(b);
    }
}
```

由于编译器是面向单线程的，只要对于单线程的上下文逻辑不变，就可能发生指令重排序

如果发生指令重排序使得 set() 中代码顺序改为：

```java
public void set(){
    a = 3;
    f = true;
    b = 4;
}
```

那么这就可能会导致 a 和 f 都写回主存，并且通知缓存行无效，但是 b 没有写回主存，或者 没有通知缓存行无效，这就导致 b 的数据不可见了，导致其他线程在 get() 中输出的 b 是一个旧值 3

 

通过添加 volatile 保证不会发生指令重排

编译器会在 volatile 写前后各加一道内存屏障，保证不会跟其他代码进行重排序

![img](https://picb.zhimg.com/80/v2-1c459334f09b418add91ac2831f4113f_720w.jpg)

可以转换为上面的例子看：

```C
class Main{
    private volatile boolean f = false;
	private int a = 2;
	private int b = 3;
    
    public void set(){
        a = 3;
        b = 4;
        barrier(); // 插入编译器内存屏障，禁止指令重排序
        f = true;
        barrier(); // 插入编译器内存屏障，禁止指令重排序
    }
    
    public void get() throw Exception{
        while(!f){
            Thread.sleep(100);
        }
        System.out.println(a);
        System.out.println(b);
    }
}
```





## 3、synchronized 实现原理

> ### synchronized 原理

**synchronized 锁实际上是靠 Java 对象头中的 markOop**

Mark Word 记录了当前对象的锁的状态：已经加锁 或者 无锁，以及 偏向锁的标识

**重量级锁** 的底层是 JVM 基于 monitor 对象来实现的（注意只有重量级锁才会使用 monitor ），它内部还有一个 count 字段，表示重入度，当持有锁的线程再次需要获得锁的时候，可以直接获取，然后 count +1，当计数器为 0 的时候，那么释放锁（原理跟上面的 ReentrantLock 的可重入实现差不多）

**OOP 对象头中的 markOop 维护了一个 monitor 对象**



> ### 2、锁升级过程

后续版本的 JDK 对 synchronized  进行了优化，使得 synchronized  的性能跟 ReentrantLock 差不多，差别主要是 ReentrantLock 用户能够自行释放锁

原本的 synchronized  只有两个状态：无锁，重量级锁；

后续再添加了两种状态，变成了 四种状态：**无锁、偏向锁、轻量级锁、重量级锁**

**偏向锁、轻量级锁 都是 乐观锁， 重量级锁 是 悲观锁**



偏向锁是 认为大多数的锁都不会存在竞争，一般都是由一个线程持有

轻量级锁是 认为两个线程使用锁的时间是错开的，即基本不会同时使用，最多也就通过 CAS 等待一会而已

重量级锁是 锁竞争激烈的情况下，为了不让 其他线程 CAS 浪费 CPU 空转，直接阻塞线程，同时它重量级的原因就是，阻塞了线程后需要去唤醒线程，然后再去切换线程，线程切换是用户态和内核态的切换，时间花费大



**锁升级过程：**

- 对象初始化的时候，没有被其他线程占有，那么这时**这个对象是 可偏向 状态**，也就是它只认为只有一个线程会来访问它，当**第一个线程来访问它的时候，它会通过 CAS 将 Mark 中的线程 ID 设置为该线程**，**该对象 从 可偏向状态 转换为 偏向状态**，以后，该线程再来访问该对象时，只需要对比 ID 即可，如果一样则可以直接获取，无需 CAS
- 可能过了很久很久，当第二个线程来访问对象时，发现 该对象 是 偏向状态，表示在以前有线程访问这个对象了，导致它变成了 偏向状态，那么检查下该对象的 线程 ID 对应的线程 是否还存活（因为即使线程消亡了，对象的偏向状态也不会主动改变，需要别的线程来这样帮它改变），如果存活，那么检查下该线程是否仍然持有这个偏向锁，如果持有，那么该锁会升级为轻量级锁，此时锁仍由原来的线程持有，而第二个线程会 CAS 自旋，等待获取锁；；； 如果没有存活 或者 不持有，那么不会升级为轻量级锁，表示该对象可以重新偏向，将锁的 线程 ID 设置为 自己
- 当升级为轻量级锁后，此时也同样是自旋锁，如果 CAS 自旋次数到达阈值（默认 10 次），而第一个线程还没有释放锁，或者 有第三个线程来访问 了，那么就会升级为重量级锁，阻塞线程，避免不持有锁的其他线程 无意义的 CAS 自旋，浪费 CPU





## 4、单例 之 双重检查



在 8 种单例模式写法中，有这么一种写法：

```java
class Singleton{
    //volatile 修饰，保证可见性和禁止指令重排
    private volatile static Singleton instance = null;
    
    //构造方法私有化
    private Singleton(){}
    
    public static Singleton getInstance(){
		//双重检查
        if(instance == null){
            //锁住 Class 对象，类锁（同时还有对象锁，注意，对象有多个，Class 类只有一个）
            synchronized(Singleton.class){
                if(instance == null){
                    //赋值方法非原子性
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```



> ### **上面 volatile 有什么作用？**

很容易看出的是保证可见性，但是这个 禁止指令重排有什么作用呢？

我们需要先知道，上面那个赋值语句的执行 跟 i++ 一样不是原子性的，它分为如下操作：

- 分配内存空间
- 调用构造方法，创建实例对象
- 将对象所在地址返回给引用

如果发生指令重排的话，那么将 2 3 步调换，先分配内存空间，然后再直接将地址返回给引用，最后再创建实例对象

假设在将地址返回给引用，这时候 instance 引用指向了一个地址，不再为空

地址上的实例对象还没有创建的时候，这里也不说什么多线程和单线程，假设是单线程，那么到这一步前 CPU 调用其他的线程，发现 instance 不为空，那么直接拿去用了， 那么就自然存在空指针异常了，多线程同样问题

**注意：其他线程在判断的时候是在第一个判断 if(instance == null) 的时候发现不为空的，还没有到 synchronized，这时候跟 synchronized 保证的原子性无关**



> #### **上面 synchronized 有什么作用？**

保证赋值语句的原子性，上面也说了赋值语句 本身是非原子性的

因此需要赋值语句来保证原子性，这个不用讲



简单讲，volatile 主要是禁止指令重排序，防止 其他线程在第一个 if 判断处获取一个空对象

synchronized 是保证赋值语句的原子性，不会多个线程创建多个对象，这就不是真正意义上的单例



## 5、volatile、synchronized 和 lock 的区别

> ### volatile

- 保证可见性
- 禁止指令重排
- 不能保证原子性，并且只能修饰 共享变量

在只需要保证可见性 或者 禁止指令重排的时候可以使用，比如 CAS 中的 state 和 单例模式 进行 赋值语句指令重排



> ### synchronized

- 修饰方法和代码块
- 可见性（**线程获取锁前会清空工作内存，读取主存新值**）
- 原子性
- 可重入，并且有 偏向锁、轻量级锁、重量级锁 三种，会根据竞争情况进行锁升级
- 发生异常时会自动释放锁（在异常结束处加了一条字节码指令 monitorexit），但是如果捕获了异常就不会提前释放锁，会继续等待执行完毕才释放锁

如果仅仅需要同步线程，而不需要什么其他操作，使用 synchronized  就行了

**但 synchronized 锁不够灵活，获取锁的时候只能一直阻塞，不能够中断，因此容易造成死锁，在某些需要中断等待的场景也不能使用**



> ### lock

- 具有灵活性，**灵活性在于可以手动上锁和释放锁，并且可以指定等待锁的时间，不会死等**，线程池中 Worker 类 就继承了 AQS，赋予了 tryAcquire() 锁的语义，当调用 shutdown() 的时候线程池可以调用 teyLock() 判断线程是否空闲
- 能够保证可见性（**由于 state 是 volatile 的，所以释放锁，即修改 state 的时候，会将前面的操作一并刷新入内存，这样其他线程看得到了**）
- 可重入
- 可以配套使用 `lock.newCondition()` 来指定不同类型的锁对象，可以方便唤醒某种类型的线程，用于生产者消费者模式
- 发生异常不会自动释放锁，所以需要记住在 finally 处调用 unlock()

lock 的灵活性使得可以避免无限期的阻塞，以及可以用来线程池判断线程的状态

**使用 tryLock() 可以被中断**




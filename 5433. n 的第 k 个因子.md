## **[5433. n 的第 k 个因子](https://leetcode-cn.com/problems/the-kth-factor-of-n/)**

```java
给你两个正整数 n 和 k 。

如果正整数 i 满足 n % i == 0 ，那么我们就说正整数 i 是整数 n 的因子。

考虑整数 n 的所有因子，将它们 升序排列 。请你返回第 k 个因子。如果 n 的因子数少于 k ，请你返回 -1 。
```



## **示例 1：**

```java
输入：n = 12, k = 3
输出：3
解释：因子列表包括 [1, 2, 3, 4, 6, 12]，第 3 个因子是 3 。
```



## **示例 2：**

```java
输入：n = 7, k = 2
输出：7
解释：因子列表包括 [1, 7] ，第 2 个因子是 7 。
```



## **示例 3：**

```java
输入：n = 4, k = 4
输出：-1
解释：因子列表包括 [1, 2, 4] ，只有 3 个因子，所以我们应该返回 -1 。
```



## **示例 4：**

```java
输入：n = 1, k = 1
输出：1
解释：因子列表包括 [1] ，第 1 个因子为 1 。
```





## **方法①、暴力法**

### **实现思路**

```java
直接找出所有的因子，然后获取第 k 个
时间复杂度 O(n)
```



### **实现代码**

```java
无
```



## **方法②、存储后半部分因子**

### **实现思路**

```java
通过 for 循环，for(int i = 2; i * i <= n; i++) 遍历前半部分因子，同时添加后半部分因子
如果第 k 个因子在前半部分中，那么直接返回
否则，从后半部分中查找倒序 第 k 个返回

时间复杂度 O(sqrt(n))，空间复杂度 O(sqrt(n))

//为什么是倒序第 k 个？
比如 n = 12 ，因子有 {1, 2, 3, 4, 6, 12}，k = 4，那么遍历的前半部分因子顺序为 {1, 2, 3}
那么添加的后半部分因子顺序为 {12, 6, 4}，因此第 4 个因子为除去前半部分因子数 3 后，k = 1，即后半部分倒序第 1 个

//注意（易错点）：
添加后半部分因子的时候，需要判断是否是 i * i == n，如果是，那么不重复添加
```



### **实现代码**

```java
class Solution {
    public int kthFactor(int n, int k) {

        List<Integer> res = new ArrayList<>();
		
        for(int i = 1; i * i <= n; i++){
            if(n % i == 0){
                //如果当前因子为第 k 个，那么直接返回
                if(k == 1){
                    return i;
                }
                k--;
                //易错点：如果 i * i == n ，那么不必重复添加
                if(i * i != n){
                    res.add(n / i);
                }
            }
        }
		//上述我们通过 k-- 去除了前半部分因子，剩下的 k 即为后半部分的第 k 个
        return k <= res.size() ? res.get(res.size() - k) : -1;
    }
}
```


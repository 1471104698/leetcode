# rand(N) 生成 rand(M)



*![image.png](https://pic.leetcode-cn.com/1602169342-ZYoWZQ-image.png)*



**示例 1:**

```java
输入: 1
输出: [7]
```

**示例 2:**

```java
输入: 2
输出: [8,4]
```

**示例 3:**

```java
输入: 3
输出: [8,1,10]
```



**提示:**

1. rand7 已定义。
2. 传入参数: n 表示 rand10 的调用次数。



**进阶:**

1. rand7()调用次数的 期望值 是多少 ?
2. 你能否尽量少调用 rand7() ?





## 思路

### Part1 

现在有 rand2() 可以生成 [1, 2] 的随机数，rand4() 可以生成 [1, 4] 的随机数

那么我们如何使用 rand2() 实现 rand4() ？

最简单的想法就是调用两次 rand2() ，结果为 a 和 b，然后 a + b 即为结果

```mathematica
rand2() + rand2() ---> rand4()
	1	+	1		=	2
	1	+	2		=	3
	2	+	1		=	3
	2	+	2		= 	4

在上面的方法中，只能生成 [2, 4]，那么如果想要生成 1，就将一边的结果 -1
rand2()-1 + rand2() ---> rand4()
	0	+	1		=	1
	0	+	2		=	2
	1	+	1		=	2
	1	+	2		= 	3
```

但是我们可以看到，最终没有生成 4，而且它们生成的结果 **不是等概率的**，这个是最致命的，我们要求的结果必须所有的数都是等概率出现的，因此这种 -1 方法不可行



当我们将 rand2() - 1 乘以 2 变成 (rand2() - 1) * 2，可以发现：

```mathematica
(rand2()-1)*2 + rand2() ---> rand4()
	0		  +	  1		=	  1
	0		  +	  2		=	  2
	2		  +	  1		=	  3
	2		  +	  2		= 	  4
```

奇怪的知识增加了 ，它能够生成 [1, 4]，并且都出现了一次，是等概率的，因此，使用这个方法，可以使用 rand2() 实现 rand4()



因为可能上述存在巧合，所以需要判断是否出现普遍性：

```mathematica
(rand9() - 1) * 7 + rand7()
```

为了方便，rand9() - 1 表示为 a，把 rand7() 表示为 b

![image.png](https://pic.leetcode-cn.com/b3a6cfbc8e1c07a46db94f2af7b45935daf0b65c26649ce1b564e6ccfdf5cecf-image.png)

可以发现，生成了 [1, 63] 随机数，并且全部都是等概率的，而这里面 7 * 9 = 63，刚好就是等概率的最大数

因此我们可以总结出一条规律：

```mathematica
randN 可以等概率的生成 [1, N] 
那么有：
(randX() - 1) * Y + randY()
它可以生成 [1, X * Y] 的等概率的数
即实现了 randXY()
```



### Part2

上面是 randX() 实现 randY()，其中 X < Y

那么对于 X > Y 的情况呢？

比如 rand4() 实现 rand2()，这个就很简单了，rand4() 等概率生成 [1, 4] 的随机数，只需要 % 2 + 1 就可以了：

```mathematica
rand4() % 2 + 1 ---> ?
  1	% 2 	+ 1  =	2
  2 % 2		+ 1  =  1
  3 % 2		+ 1  =  2
  4 % 2		+ 1  =  1
```

实际上，只要 randN() 是 2 的倍数，那么就可以通过 randN() % 2 + 1 来实现 rand2()

因为 randN() 是等概率生成 [1, N]，只要 N 是 2 的倍数，那么最后的 N 就是偶数，而从 1 -> N 就存在 N / 2 个偶数 和 奇数

这样的话 % 2 后就存在相同个 0 和 1，再 + 1 后就存在相同个 1 和 2，因此是等概率的

但如果 N 不是 2 的倍数，那么就是不行的，因为这意味着 N 是奇数，那么就表示最后 1 的个数会比 2 的个数 多 1，比如：

```mathematica
rand6() % 2 + 1 = ?
   1 % 2    + 1 = 2
   2 % 2    + 1 = 1
   3 % 2    + 1 = 2
   4 % 2    + 1 = 1
   5 % 2    + 1 = 2
   6 % 2    + 1 = 1

rand5() % 2 + 1 = ?
   1 % 2    + 1 = 2
   2 % 2    + 1 = 1
   3 % 2    + 1 = 2
   4 % 2    + 1 = 1
   5 % 2    + 1 = 2
```

这样可以推理出：

如果 X >= Y 并且 X % Y == 0，那么意味着 randX() % Y + 1 能够等概率生成 [1, Y]，即实现 randY()



### Part3

上面存在两条公式：

```mathematica
(randX() - 1) * Y + randY() 可以等概率生成 [1, X * Y]
如果 X 是 Y 的整数倍，那么 randX() % Y + 1 可以等概率生成 [1, Y]，即实现 randY()
```

我们要使用 rand7() 实现 rand10()，由于只有 rand7()，意味着 X = Y = 7，要使用 7 拼凑出大于等于 10 的倍数 N

这样就能通过 randN() % 10 + 1 等概率生成 [1, 10] 了

由于只有 7，所以我们只能使用

```mathematica
(rand7() - 1) * 7 + rand7()
```

它能够等概率生成 [1, 7 * 7] = [1, 49]

这样的话，最大的 10 的倍数是 40，而超出的 [41, 49] 是不需要的

因此，我们可以采用 **拒绝采样** 的策略，即如果遇到我们不需要的样本直接忽略掉，然后重新采样

```java
class Solution extends SolBase {
    public int rand10() {
        int num = 0;
        do{
            num = (rand7() - 1) * 7 + rand7();
            if(num <= 40){
                return num % 10 + 1;
            }
        }       
    }while(true);
}
```





### Part4

这里是对 Part3 的优化，每次舍弃掉 9 个数，导致 while 次数增加，实际上可以再重用这 9 个数

当我们对 [41, 49] - 40 后就变成了 [1, 9]，即 rand9()，那么就转变成使用 rand9() 来实现 rand10() 了

```mathematica
(rand7() - 1) * 9 + rand9()
```

我们可以发现 7 * 9 = 63，这样可以复用 60，舍弃 3 个数，后续可以使用 rand3() 再实现 rand10()，跟 rand7() 组合舍弃 1 个数

```java
class Solution extends SolBase {
    public int rand10() {
        while(true){
            int a = rand7();
            int b = rand7();
            int num = (a - 1) * 7 + b;	//rand49()
            if(num <= 40){
                return num % 10 + 1;
            }
            a = num - 40; //rand9()
            b = rand7();
            num = (a - 1) * 7 + b;	//rand63()
            if(num <= 60){
                return num % 10 + 1;
            }
            
            a = num - 60;
            b = rand7();
            num = (a - 1) * 7 + b;	//rand21()
            if(num <= 20){
                return num % 10 + 1;
            }
        }
    }
}
```

当然，如果发现复用后剩余的数比 9 大，那么就没必要复用了

比如 rand35() 实现 rand47()

```mathematica
(rand35() - 1) * 35 + rand35() 等概率实现 [1, 1225]
而 1225 mod 47 = 26 ... 3

这样就存在
if(num <= 1222){
	return num % 47 + 1;
}
如果重用舍弃的三个数，那么就存在
(rand3() - 1) * 35 + rand35() 等概率实现 [1, 105]
这样发现舍弃的数 比 3 还多，因此不需要复用了
```


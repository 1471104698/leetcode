# select 执行流程





流程存在以下几个步骤：

- 1）服务器连接数据库
- 2）查询缓存
- 3）SQL 解析（词法解析、语法解析、预处理）
- 4）查询优化器 选择 执行计划
- 5）执行计划

**这些动作都是在 Server 层（服务层）执行的，存储引擎层 负责数据的存储和提取**

即无论使用的是什么存储引擎，这些步骤都是不变的，当得到执行计划后，执行器会根据执行计划去调用 存储引擎层 对外开放的接口获取数据

这时候读取数据的差异就出现在 存储引擎层，不同的存储引擎层对数据读取和处理的方式不同。

当存储引擎层 获取到数据后，返回给 Server 层，然后 Server 层再进行过滤，返回给客户端



## 1、服务器连接数据库

最开始，服务器会通过我们在 spring.yml 中指定的 user 和 password 跟 数据库的连接器 建立连接，当数据库身份校验成功后，服务器 和 数据库就可以创建 connection 进行数据通信了

**服务器和数据库之间的 connection 使用的是 TCP 连接**，所以为了防止 无限制的建立连接 并且 频繁的创建和销毁连接，所以使用数据库连接池 管理和复用连接（参考线程池），因此数据库并发度是看数据库连接池的连接数量的



数据库和服务器 的 TCP 连接是 **半双工** 的，同一时间只能有一方发送数据，一方接收数据，不能同时进行



## 2、查询缓存

当建立好 connection 连接后，可以执行 select 语句请求数据库进行查询

**Mysql 内部维护了一个哈希表 作为缓存区，将 select 语句作为 key，将查询结果作为 value**

Mysql 在获取 select 语句后，不会直接去解析执行这个 sql，而是会查看内部缓存，看看之前是否执行过这条 sql 语句

如果执行过，那么通过 select 语句可以获取到查询的数据

如果没有执行过，获取执行过但表被修改过了缓存清空了，那么就会去解析执行 sql



但一般不建议使用缓存，因为如果表需要频繁的修改，那么每次 select 查询完，将查询结果放入到缓冲中，还没有使用到缓存时该表就被更新了，那么会导致缓存中关于该表的缓存数据全部失效。**对于频繁更新的表，缓存的命中率非常的低**，因此缓存的作用几乎为零，同时还需要耗费资源去处理缓存，得不偿失

只有在不需要频繁更新的表上使用缓存才有意义，但是在 Mysql 8.0 上删除了缓存这一功能，Mysql 设计者也觉得这个功能鸡肋



当查询缓存无果后，会进入到 sql 解析的步骤，这里涉及到 语法解析器 和 预处理器



## 3、SQL 解析：语法解析器 和 预处理器

[词法解析 和 语法解析](https://tech.meituan.com/2018/05/20/sql-parser-used-in-mtdp.html)



语法解析器会完成两个动作：

- **词法解析**

词法解析就是将一个完整的 sql 语句 按照分隔符（空格）分割成一个个的 token，同时会对关键字进行校验：

- 判断关键字顺序是否正确,比如 from 在前，select 在后，这就不行了

- 判断关键字是否欠缺，比如只有 select，没有 from

```sql
比如一个简单的 SQL 语句：

select name from user where id = '1' and age > 20;

它会打碎成 12 个 token，同时还记录每个 token 的类型
当分割出所有的 token 后，会检查其中哪些为关键字，其中 有 4 个是 keyword(关键字)，分别为 select、from、where、and
```

如果词法解析过程存在错误，那么就会收到如下提示：

```
You have an error in your SQL syntax
```



- **语法解析**

```sql
select username, ismale from userinfo where age > 20 and level > 5 and 1 = 1 
```

将词法解析得到的 token，经过 语法解析 后，生成以下语法树：

![图2 语法树](https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/a74c9e9c.png)



语法解析会将每个关键字后面的参数放到不同的数据结构中

比如 select 后面的字段被放到了 item_list 中，from 后面的字段被放到了 table_list 中，where 后面的字段被放到了 Item 中

![图3 SQL解析树结构](https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/8eafb088.png)

where 后面的查询条件最为复杂，所以 item 存储的数据也最为复杂：

![图4 where条件](https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/0adcdb23.png)





当语法解析 和 词法解析结束后，将得到的 参数 都发送给 预处理器

**预处理器会检查 参数 数据结构内部的数据 是否正确，比如 item_list 中的列名是否存在，table_list 中的表是否存在，同时会解析别名**

如果存在字段不存在之类的，那么就会收到如下提示：

```
Unknown column xxx in ‘where clause’
```





## 4、查询优化器

当 SQL 解析完成后，查询优化器 会收到解析出来的 **语法树**，此时的语法树是合法的

一条 sql 存在不同的执行方案，执行顺序不同但是最终结果相同，然后效率也不同



比如你执行下面这样的语句，这个语句是执行两个表的 join：

```sql
select * from t1 join t2 using(ID) where t1.c=10 and t2.d=20;
```

既可以先从表 t1 里面取出 c=10 的记录的 ID 值，再根据 ID 值关联到表 t2，再判断 t2 里面 d 的值是否等于 20。

也可以先从表 t2 里面取出 d=20 的记录的 ID 值，再根据 ID 值关联到 t1，再判断 t1 里面 c 的值是否等于 10。

逻辑结果一样，但执行效率不同，优化器就是抉择使用哪个



**最终选定的执行计划就是我们 explain 显示的结果**



## 5、执行器 执行 执行计划

执行器 收到从 查询优化器 发送过来的执行计划

首先会判断当前用户是否存在对 该表 的访问权限，如果没有，那么报错：

```sql
RROR 1142 (42000): SELECT command denied to user 'b'@'localhost' for table 'user'
```

如果有权限，那么开始查询操作，跟 存储引擎层 进行交互



**没有索引的表**

假设 user 表中，userId 字段没有索引，那么执行器的执行流程是这样的：

1. 调用 InnoDB 引擎接口获取这个表的第一行（实际上是扫描聚簇索引树），判断 userId 是不是10，如果不是则跳过，如果是则将这行存在结果集中
2. 调用引擎接口获取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行
3. 执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。



**有索引的表**

第一次调用存储引擎的 " 取满足条件的第一行 " 的接口，存储引擎会定位到满足条件的 ”第一行“，之后循环读取，直到下一条数据不满足条件

这些接口都是引擎中已经定义好的。



## 6、Server 层 和 存储引擎层 的交互

 [MySQL的server层和存储引擎层是如何交互的 -- CSDN博客](https://blog.csdn.net/wanghao112956/article/details/90714806) 



存在这么一张表：

该表有两个索引：id 聚簇索引， (a, b) 非聚簇索引（二级索引）

```shell
CREATE TABLE hero (
    id int,
    a int
    b int,
    PRIMARY KEY (id),
    KEY idx_a_b (a, b)
) Engine=InnoDB CHARSET=utf8;
```



表中数据如下：

*![image.png](https://pic.leetcode-cn.com/1606397574-qHtJxI-image.png)*



存在以下 select 语句：

```sql
explain SELECT * FROM user WHERE a < 4 AND b = 3;
```



这里有一个疑惑：存储引擎 是一次将所有满足的数据查询出来再返回给 Server 层的，还是查询出一条数据返回给 Server 层，然后再进行查询？实际上 Server 层 和 存储引擎层 的交互是以一条数据作为单位的

整个交互过程如下：

1. 执行器发现存在索引，因此调用 存储引擎接口，把 索引对应的查询列 `a < 4` 这个查询条件交给存储引擎，让存储引擎定位到第一行
2. 很显然，在 name 这棵非聚簇索引树中，通过二分查找得到的第一条数据是 `a = 1, b = 1`，此时 select *，所以需要回表查询，然后将回表查询出来的结果返回给 Server 层
3. Server 层获取到数据后，会再根据其他的 where 查询条件判断返回的数据是否满足条件，如果不满足那么直接忽略，如果满足那么 **返回给客户端显示 或者 作为下一条 select 语句需要匹配的行数据**，然后继续调用存储引擎接口继续读取下一条数据，直到数据不满足条件为止

上面存在两个注意点：

- 存储引擎索引下推

  ```java
  索引下推 作用于 联合索引
  我们上面的查询中，存储引擎查询出了第一条数据 a = 1，b = 1，但是我们实际上进行对比的只有 a 列，而 b 列没有起到作用
  但是在我们的 sql 中是存在 b 列的查询条件 b = 3 这个限制的
  因此，在没有索引下推的情况下，存储引擎需要将 (a, b) = (1,1)(2,2)(3,3) 这三条数据都进行回表，然后再返回给 Server 层进行过滤
      
  而如果使用了索引下推，执行器可以根据使用的索引，判断如果 where 查询条件中有多个条件是在索引中的，那么可以将这多个查询条件都作为参数传入存储引擎
  这样存储引擎可以根据 b = 3 这个查询条件排除掉 (1,1)(2,2) 这两行数据，减少了两条数据的回表，从而减少了 IO 次数，提高了效率
  ```

- Server层数据返回客户端

  ```java
  我们上面说，Server 层每次获取到一条数据就直接返回客户端
  但是我们每次看到的都是所有数据，这是因为客户端只有获取了所有数据的时候才会显示给我们程序员，是客户端自己的问题
  ```



以下是 Server 层 和 存储引擎层 交互的伪代码：

```java
/*
这里是 Server 层
*/
boolean first_read = true;  //是否是第一次读取
while (true) {

    if (first_read) {
        first_read = false;
        //调用存储引擎接口方法获取数据
        err = index_read(...);  //调用存储引擎接口，定位到第一条符合条件的记录;
    } else {
        err = index_next(...); //调用存储引擎接口，读取下一条记录
    }
    
    if (err = 存储引擎的查询完毕信息) {
        break;  //结束查询
    }
    
    if (是否符合 where 条件) {
        send_data();    //将该记录发送给客户端;
    } else {
        //跳过本记录
    }
}
```


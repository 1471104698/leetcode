#  CRSF 攻击 和 XSS 攻击

## 3、CSRF 攻击（ *跨站请求伪造*）

CSRF 攻击 就是黑客 未经本人许可 以 本人 的名义发送恶意请求（修改密码，银行转账等）

CSRF 攻击原理是 **浏览器分不清发起请求的是否是用户本人，每次请求都会带上 cookie，而 cookie 内部又有用于验证身份的 sessionid**



**CSRF 攻击模拟：**

- 用户 X 登录了某银行网站 A，这时候银行后台会发送一个 cookie 给 X，浏览器会保存这个 cookie
- X 被一个危险的网站 B 诱导访问
- 网站 B 中内部有一个隐藏的 form 表单，是 POST 请求的，当用户 X  点击了某些东西的时候，就会触发这个表单的提交事件，表单提交的内容是向 银行网站 A 要求将 X 的 1000 元转账到 中间人 F 账户中
- 这时候由于 X 访问 网站 B 的浏览器同时也是之前访问 银行网站 A 的浏览器，因此浏览器会将 cookie 跟着请求一起发送给银行网站 A，网站 A  收到后发现有 cookie 就不再进行登录验证，而是执行转账
- 这样， X 的 1000 元就没有了

我们可以看出，中间人 F 他并没有获取 X 的 cookie，他并不知道 X 的 cookie 的内容，只是通过 X 点击了某些东西触发了表单提交，使得浏览器发送出请求；这相当于是 存在一个转账请求按钮，不过不是 用户 X 自己点的，而是 中间人 F 帮助 用户 X 点的，因此浏览器无法察觉这是否是来自用户的请求，只是一味的将请求发送出去



CSRF 防范手段：

- 验证码或密码验证：比如转账这种重要请求，就不能单单只是靠 cookie，而是需要发送验证码或者输入密码，让用户自己确认是否执行这个请求
- 添加 Referer 字段：从上面的 HTTP 请求报文头部我们可以看出来存在这么一个字段，它指向的是发起请求的来源地址，对于本次转账请求，来源地址就是 网站 B；服务端需要做的是就是验证这个网站是否是信任网站，不是的话则拒绝响应
- 使用 token 验证：
  - 在用户访问某个页面的时候，提交 get 请求，服务器生成对应的 token，将 token 和 页面返回给 用户，token 不要存放在 cookie 中，这样每个点击提交时都带上这个 token（手动带上），这样由于黑客不知道 token 值，如果使用 CSRF 攻击时无法知道 token 的值，这样就无法带上这个 token 值，那么服务器验证的时候发现没有 token 值就会拒绝处理；
  - 但是一个页面很多的提交按钮，如果一个个手动显然很麻烦，因此服务器在生成 token 的时候，前端在返回的页面中每个提交按钮中设置了一个 hidden 标签，内置了对应生成的 token，这样每次提交的时候自动就会带上 token，而对于黑客的网站，由于不是前端返回的页面，所以它不会存在这个内置的 token
  - token 的生成 跟 JWT 类似，使用 userId 和 时间戳 以及一个服务器内部的密钥 使用加密算法生成一个签名作为 token，后续用户请求带上这个 token，服务器只需要获取 userId 和 时间戳 以及自己密钥使用相同的加密算法进行验证即可





## 4、XSS 攻击 （ *跨站脚本攻击* ）

百度百科：

```
“XSS是跨站脚本攻击(Cross Site Scripting)，为不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故将跨站脚本攻击缩写为XSS。恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页之时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。”
```

简单讲就是 js 注入，比如  `http://xxx/search?keyword="><script>alert('XSS');</script> `

XSS 攻击的危害：

- 使用  document.cookie 命令获取用户的 cookie，这样就无需用户的密码即可登录用户的账号
- 劫持流量恶意操作：参考 2011年微博 XSS 攻击，大量的用户受到 XSS 攻击自动发布微博，关注用户等



XSS 防范手段：

- 过滤 <script> 等标签
- 对 &、<> 等符号进行转义，让它们失去 前端语言代表的语义
# HTTP



## 1、一次HTTP的完整请求过程

- 通过 DNS 解析域名，获取 IP 地址
- 客户端获取 IP 地址，向目的 IP 地址的服务端发起 TCP 连接（三次握手）
- 建立连接后，客户端向服务端发起 HTTP 请求（比如 get 请求获取静态资源）
- 服务端接收这个请求，在后台进行处理，比如请求某个页面，那么将 HTML 页面代码返回给浏览器
- 浏览器获取到完整的 HTML 页面代码，进行渲染，里面的图片等静态资源也通过一个个 HTTP 请求 进行加载（可以看出 HTML 代码 和 图片之类的是分开获取的，需要多次 HTTP 请求）
- 浏览器渲染完成，将页面展示给用户，如果没有后续请求，浏览器会向服务器发起断开连接（四次挥手）



## 2、HTTP 常见的状态码 

## ![img](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfXG1113Sjm0iaOXfoOv0tlUfV6qkzg4yHtOibAfTv6hTicOx73F55WWl4nW2FWlXnDJ7Igd9kvrrRnA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1) 



**1xx**

提示信息，中间状态，比如我转账给你，钱转过去需要一段处理时间，这段时间可以理解为 1xx



**2xx**

成功状态码，我们最愿意看到的

 「**200 OK**」是最常见的成功状态码，表示一切正常 ，响应体 中可能会有数据

 「**204 No Content**」 也是是最常见的成功状态码，服务器不会返回数据

 「**206 Partial Content**」是 **应用于 HTTP 分块下载 或 断电续传**，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。 



**3xx**

表示用户请求的资源位置发生了改变，告知用户需要向新的 URL 发送请求（即旧的 URL 不再提供服务）

 「**301 Moved Permanently**」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。 

 「**302 Moved Permanently**」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。

上面这两个服务器会将新的 URL 一同返回，客户端自动进行访问



**4xx**

客户端方面的错误，服务端不能处理

 「**400 Bad Request**」表示客户端请求的报文有错误，服务器无法理解

 「**403 Forbidden**」表示服务器禁止访问资源

 「**404 Not Found**」表示请求的 url 在服务器上不存在或未找到



**5xx**

客户端方面没有错误，而是服务端内部出现 了错误

 「**500 Internal Server Error**」与 400 类似，服务器内部错误

 「**502 Bad Gateway**」网关错误或者网关无效，网关或者代理服务器从上游收到无效的响应 ，可能是服务器连接太多，无法处理当前的请求

   [**504 Gateway Time-out**]：网关超时，网关或者代理向上游服务器请求，但没有及时收到上游服务器（DNS 服务器之类的）的响应



## 3、HTTP 几种请求类型

**get 和 post 的区别：**

- get 是请求资源，请求参数会放在 url 后面，即放在请求行上，post 是上传数据，上传的数据会存储在 请求体中
- get 是幂等的，无论请求多少次都不会对服务器资源造成影响， post 不是幂等的，因为它涉及到修改和添加数据
- get 提交的数据有限制，因为是放在 url 的，而 post 存储在请求体中，所以没有限制



**post 和 put 的区别：**

post 和 put 都是可以用来 更新和创建资源，但是 put 是幂等的，post 是非幂等的

比如我们贴吧回帖，点击回帖的时候由于网络问题，多次重复点击，如果是 POST 的话，刷新后可以发现自己发送了很多条相同的回帖，如果是 PUT 的话，可以发现只有一条回帖

如果是发表博客也一样，应该用的是 PUT，而非 POST，主要是看是不是需要幂等

但是**一般情况下用 POST 也可以，需要在后台进行幂等校验（比如建立流水表）**



**delete**：用来删除某个指定资源



## 4、HTTP 报文

HTTP 请求报文包括：

- 请求行（Request Line）
- 请求头（Header）
- 请求体（Request Body）

> ### 抓包分析

![1601992003965](C:\Users\蒜头王八\AppData\Roaming\Typora\typora-user-images\1601992003965.png)

第一行是 请求行：

- 请求方法类型 get/post
- 请求的 url
- HTTP 版本

接着是请求头：

- host：要访问的域名 
- cookie
- referer：从哪个 url 过来的 
- Content-Type：上传数据的数据类型（Post 才有的，比如 图片就是二进制格式）
- Connection ：处理完请求之后是否保持连接，如果为 Keep-Alive 值 或者 是 HTTP 1.1，那么就保持连接
- Accept：告知自己可以接收的数据类型

最后是请求体：

- Post 上传的数据存储在请求体中，而 get 将请求参数直接挂在 url 上，对于 get 来说是不需要用到请求体的





HTTP 响应报文包括：

- 响应行
- 响应头
- 响应体

> ### 抓包分析

![1601992795130](C:\Users\蒜头王八\AppData\Roaming\Typora\typora-user-images\1601992795130.png)

第一行是响应行：

- HTTP 版本
- 响应码
- 响应码的描述

后面是响应头：

- Date：当前的时间戳
- Content-Type：返回的数据类型
- Coonection：是否保持连接

最后是响应体：

- 如果是请求的数据，那么存储的就是数据（比如我们查询数据库的那种数据），如果请求的是 HTML 代码，那么返回就是 HTML 代码







## 5、HTTP 各个版本的区别 以及 演变的逻辑



### 1、HTTP 0.9

最原始的 HTTP 版本

- 只 支持 GET 请求：由于不支持其他请求，而 GET 是在 URL 中携带请求信息的，因此客户端无法向服务端发送太多信息
- 没有请求头/响应头 概念：不能指定版本号，同时只有一个版本，也无需指定，服务端只有返回 HTML 字符串的能力
- 短连接，即响应请求后，无需再进行通信，断开连接



HTTP 0.9 的局限性很大，能做的事很少



### 2、HTTP 1.0

- 新增了 POST、DELETE、PUT 等方式
- 增加了 请求头/响应头的概念，在请求/响应头 中指定 HTTP 版本号，以及状态码、权限、编码等
- 扩充了传输内容，可以传输图片、音频、二进制数据等

- 无状态：服务端不会保存客户端的信息，这样就不会占用服务器内存
  - 可以通过 cookie/session 机制来做身份认证和状态记录



HTTP 1.0 的缺点：

- 使用的是短连接，一次  HTTP 请求后都会断开连接（可以通过服务器配置支持多次），每次都需要进行 三次握手、慢启动、四次挥手，频繁通信情况下效率低，   其中 慢启动 主要对文件类大的传输影响大
- 存在 HTTP 队头阻塞





> ### 队头阻塞

- TCP 队头阻塞：即使使用滑动窗口，当一个数据包丢失，它将会导致后续的数据包无法发送，该数据包会重传直到接受方接收到发送 ACK 并且发送方接收到 ACK 为止
- HTTP 队头阻塞：请求 和 请求之间是有顺序的，下一个请求必须在上一个请求得到服务端响应后才能发出去，如果上一个请求阻塞了，那么后面的请求都会阻塞





### 3、HTTP 1.1



- 新增长连接：新增了一个 Connection 字段，里面有个 keep-alive 字段，可以设置保持连接不断开，以此成为长连接，因此一个  TCP 连接可以处理多个请求；HTTP1.1 是默认长连接的
- 管道化：对 HTTP 1.0 的修改，**管道化使得每个请求可以无需等待上一个请求响应即可发出去，不过响应还是按照请求的顺序返回**
- 缓存处理：新增字段：cache-control，对于 get 请求，浏览器会先看看自己是否有缓存，如果有，那么直接用，如果没有再请求，然后进行缓存，通过 cache-control 字段来控制缓存
- 断点传输：资源过大，可以分割传输，并且遇到网络故障的情况下，下次传输也可以从上次传输的地方接着传输



> ### 管道化

基于长连接的基础，我们先看没有管道化请求响应：

TCP 没有断开，用的同一个通道

```
请求1 > 响应1 --> 请求2 > 响应2 --> 请求3 > 响应3
```

管道化的请求响应：

```
请求1 --> 请求2 --> 请求3 > 响应1 --> 响应2 --> 响应3
```



管道化虽然解决了请求阻塞的问题，但是响应返回的顺序还是按照请求的顺序返回

这样的话，即使 响应2 比 响应1 事先准备好，但是还是要等 响应1 整完返回，响应2 才能返回

这是为了防止服务器返回 响应的时候，如果不按照顺序的话，那么服务器不知道相应对应哪个请求

本质上还是没有解决 HTTP 队头阻塞的问题





### 4、HTTP 2.0



HTTP 2.0 进行了全面改造，从数据传输的基本单位 到 使用的 协议 全部发生了改变

在 HTTP 2.0 中，有两个重要的新概念：帧 和 流

HTTP2.0 抛弃了 HTTP/1 使用的文本格式，使用的是二进制数据帧传输



> ### HTTP2.0 新加入的几个概念

连接(Connection)：一个 TCP 连接包含多个 Stream

流（Stream）：一个双向通讯流，代表一个完整的 请求-响应 过程

消息（message）：将每个 HTTP 请求 / 响应 看作一个消息，包含一个或者多个 frame

帧（frame）：数据传输的最小单位

- length：帧的最大长度
- type：帧的类型，比如设置流的优先级之类的
- stream identifier：流的id，即用来标识这个帧是属于哪个流的，**HTTP 1.1 中的队头阻塞就是因为响应和请求没有标识符，不知道怎么对应，所以响应才需要按照顺序返回，而这里给定了标识符了，所以就可以打破这个 HTTP 队头阻塞了**



> ### 上面各个概念的简单描述

首先我们需要搞清楚它们之间的关系

首先 连接(Connection) 就是一个 TCP 连接

那么 流（Stream）是什么？

流 它不是一个具体的事物，它代表着一次完整的 HTTP 请求/响应 过程

当客户端发起请求的时候，就是概念上建立起一个流（Stream），然后 请求/响应 的 帧（frame）进行传输，我们称 帧（frame）是在流上传输的

消息（message）就是每个 请求/响应，将它划分为多个部分，每个部分叫做 帧（frame）

即流上传输的就是 消息的部分，即 帧（frame）

消息（message）分块后是需要按照顺序进行传输的，这样接收方接收到后可以按照接收的顺序进行拼接，保证了有序性



一个 连接(Connection) 可以存在多个流，即用户可以同时发起多个请求，这样的话每个请求对应一个流



> ### 到底什么是流，以及什么是多路复用

**我们还需要再讲明，流，它不是一个具体的事物，既然不是一个具体的事物，那么怎么在 连接(Connection)  表示出 流（Stream）这个东西呢？**



帧（frame）上面有一个 stream identifier 字段，表示它是属于哪个流的

这样的话，其实就是像下面这样，所有的流的帧都在一条道上传输，不过是按照帧上的流的 id，来记录这个帧是属于哪个流的

不同流（Stream）的帧（frame）可以交错传输，而同一个流上的帧需要保证传输的顺序，这样才能够根据接收的顺序进行拼接，保证了有序性



下面的图不管发送还是接收都一条道，不过为了方便指明方向所以画成两条道

![img](https://upload-images.jianshu.io/upload_images/16844918-b13e6490eedb402c.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

*![image.png](https://pic.leetcode-cn.com/1599402910-XBmxXM-image.png)*



由于上面这波操作，将本来只有一条道的，给抽象成了多条流，即每条流的帧都是在各自的道上进行传输

然而，实际上它们还是在一条道上，不过是根据流的不同来区分出不同的道

![img](https://user-gold-cdn.xitu.io/2019/10/12/16dbed8846d82eee?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

而由于它们存在流的 id 标识符，因此可以发送多个请求，以及无需按照请求的顺序进行响应，因为它们有 流 id 进行标记，可以根据这个 流 id 识别出响应是属于哪个请求的，以此来解决了 HTTP 队头阻塞的问题

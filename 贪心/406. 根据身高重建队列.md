## **[406. 根据身高重建队列](https://leetcode-cn.com/problems/queue-reconstruction-by-height/)**

```java
假设有打乱顺序的一群人站成一个队列。 每个人由一个整数对(h, k)表示，其中h是这个人的身高，k是排在这个人前面且身高大于或等于h的人数。 编写一个算法来重建这个队列。

注意：
总人数少于1100人。
```



## **示例**

```java
输入:
[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]

输出:
[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]
```





# **实现思路**

```java
贪心思路

由于 /* 矮个子 对于 高个子 来说是 “看不见” 的*/ 即 矮个子怎么排都不会影响到高个子，而高个子的站位会影响到矮个子，
因此我们先排 高个子，这样后面的 矮个子 就可以根据 高个子 的情况进行 插队站位，而高个子又不会受到 矮个子 插队的影响

//按照身高进行降序，身高相同的按照 k 进行升序

1、对于同等身高的人，那么他们的站位即为 k，
比如 [7,0] [7,1] [7,2]，那么 [7,0] 站在 0 号位置，[7,1] 站在 1 号位置，[7,2] 站在 2 号位置

2、当高身高的排完后，我们再来排低身高的，比如 [6,1]，它应该站的位置是 1 号位置
因为我们前面排了比它高的，因此无论它插在哪个位置，该位置前面的人都比它高，
而它需要 前面 1 个人比他高，因此将它直接插入 1 号位置，那么表示前面只存在一个比它高的人，而同时又不会对后面的高个子产生影响
	结果为 [7,0] [6,1] [7,1] [7,2]
3、以此类推，逐步插入
```



## **实现代码**

```java
class Solution {
    public int[][] reconstructQueue(int[][] people) {
        Arrays.sort(people, (a, b) -> a[0] == b[0] ? a[1] - b[1] : b[0] - a[0]);

        List<int[]> res = new ArrayList<>();
        for(int[] p : people){
            res.add(p[1], p);
        }
        int[][] temp = new int[res.size()][2];
        return res.toArray(temp);
    }
}
```


# BIO、NIO、AIO



[网络 IO 详解](https://zhuanlan.zhihu.com/p/54580385)



IO 即 input/output 的简写，IO 主要分为两种情况：磁盘 IO 和 网络 IO



磁盘 IO 就是直接本地磁盘读写，没什么好说的

网络 IO 就是 socket 通信的 read/write

以下讲的 IO 类型都是 网络 IO

## 1、BIO（阻塞 IO）

BIO 是 同步阻塞 IO，它有两个阶段会存在阻塞

比如用户进程调用 recv() 读取数据

内核就会进入 BIO 的第一阶段：准备数据，如果这时候数据还没有到来，那么内核会等待数据到来，这段时间用户进程是阻塞的

当内核获取到足够的数据时，进入 BIO 的第二阶段：将数据从内核态拷贝到用户态，这段时间用户进程也是阻塞的

BIO 的特点就是用户进程在 **等待数据 和 拷贝数据** 两个阶段都会阻塞





## 2、NIO（非阻塞 IO）

NIO 即 Non Blocking IO，同步非阻塞 IO

比如用户进程调用 recv() 

在第一阶段，内核发现数据还没来，那么会返回一个 error 给用户进程，这样用户进程就会知道没有数据，不会死等

后面用户进程再次调用 recv() ，如果数据来了，那么内核会将数据从内核态拷贝到用户态，用户进程可以自取



由此我们可以看出

- NIO 是在 IO 第一阶段不会发生阻塞，而在 第二阶段还是发生了 数据从 内核态到用户态的拷贝，因此这个阶段用户进程会陷入阻塞，直到数据拷贝完成
- NIO 中的用户进程需要使用轮询的方式 去询问内核是否存在数据，比较耗费 CPU 资源



## 3、IO 多路复用

IO 多路复用模型比如 select，它能够同时处理多个 socket，将需要处理的 socket 交给用户进程

使用 IO 多路复用的时候， socket 都是设置为 NIO 的

但是在调用 select() 的时候，其实 用户进程还是会一直阻塞的，但是阻塞不是因为 io 操作，而是因为 select() 等待内核处理后返回

IO 多路复用使用的是 事件处理器，由于 IO 多路复用是同时处理多个 socket 的，所以有的 socket 是写操作，有的 socket 是读操作，各自的事件都不一样，所以需要针对 socket 的某个事件进行处理

比如在 select 中就是使用 fd_set，将要监听某个事件的 socket 的 fd 放到对应的 fd_set 中



IO 复用模型有 select、poll、epoll

其中 select 和 poll 都是进行轮询的，都需要将需要监听的对应事件的 socket 拷贝到内核态，然后内核态进行筛选，将没有事件的 socket 对应的 fd_set 置为 0，然后将有事件的 socket 个数返回给用户进程（仅仅只告诉个数，不具体到哪个 socket），然后用户进程根据个数对 fd_set 进行遍历

epoll 则是从头到尾都是 内核态控制 socket 列表，因此省去了 用户态到内核态中 socket 列表的拷贝



**使用 IO 多路复用，好处就是不需要每一个 socket 都开一个线程去处理，只需要使用一个线程就可以处理多个 socket**



## 4、AIO（异步 IO，最终目标）

AIO 是 异步 IO，既然是异步那自然是不会阻塞的

当用户进程调用 recv() 时，会直接返回，不会做任何等待

相当于 recv() 是去通知 内核 需要数据，然后就走了

如果内核中没有数据，那么会等待数据到来，如果内核中有数据，那么会将数据从内核态拷贝用户态，然后发送一个 signal 信号给用户进程，告知数据已经准备好了



AIO 跟 NIO 共同点就是 在没有数据的时候都不会进行等待

AIO 跟 NIO 区别就是 AIO 在有数据的时候也不会进行等待数据拷贝，数据拷贝完成是内核发送 signal 通知的，而 NIO 如果有数据则会等待数据拷贝完成然后获取

即 AIO 是完全不存在阻塞的，**它获取数据的时候类似内核的一种回调**
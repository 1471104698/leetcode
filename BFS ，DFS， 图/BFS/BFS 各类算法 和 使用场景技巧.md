## BFS 各类算法 和 使用场景技巧



### 普通的 BFS

```java
1、
普通的 BFS 只适用于 无权图
比如给你一个二维数组，其中有 或 没有障碍物，求到终点的最短路径，这种就是无权图
比如 126. 单词接龙 II，每次进行一次修改变为其他的单词，这种同样是无权图
比如 210. 课程表 II，求课程完成顺序 之类的
比如 994. 腐烂的橘子

它是按层级分的，每一次 while(size-- > 0) 循环结束就多加一层

当第一个到达终点的结果即为最短路径结果，因为是按层级分的，当第一次遇到结果的 level = 3，那么最短肯定为 3，因为后面再遇到 level 肯定 >= 3

BFS 正是因为内部元素是按层级递增的，所以才能够找到最短路径，如果里面不是递增，而是乱序的，那么第一个遍历到的结果不一定是最短路径
也就是说，正是因为 BFS 内部元素层级递增，所以才存在第一个到达终点的结果是最短路径之说


2、
BFS 同时分为 单向 BFS 和 多源 BFS

比如上面的两个示例 就是单向 BFS

而对于像 1162. 地图分析 这种，求 所有海洋区域到离它最近的陆地区域的距离中最大的距离，就是使用多源 BFS ，从各个陆地出发，得到将所有海洋同化为陆地的步数

又比如 同时从起点和终点 出发，直到两个触角相遇，这个就是双向 BFS
```



### 0·1 BFS

```
普通的 BFS 在无权图上秀得飞起，但如果在带权图上，只能让位给 dijsktra 算法，O(n) -> O(nlogn)
但如果权值比较特殊，只有 0 和 1 的情况下（0 1 权值通常需要我们自己观察出来），那么就继续考虑使用 BFS，
但不是上述普通的 BFS， 而是 用双端队列实现的 0-1 BFS
```


# Mysql 索引



## 1、为什么会出现索引

mysql 存储大量数据，底层的存储数据结构和查找结构 的设计 显得十分重要

索引是用来做数据的快速查找的，而快速查找的底层本质涉及到的是数据结构，通过不同数据结构的选择，可以实现不同的快速查找

在数据库中，使用高效的查找算法显得十分重要，当不使用索引的时候，那么查找 id = 7 的数据，只能通过暴力查找，找到 id = 7 的数据需要比较 7 次，如果表存储的是 1000W 的数据，那么查找 id = 1000W 的数据需要比较 1000W 次，这显然是无法接收的

因此，就出现了索引，用来加速查找

而选择哪种数据结构 作为索引的底层实现，就显得格外重要了

需要考虑到查找某个数据、范围查找 等各种查找条件的效率，除此之外，索引数据本身很大，所以不可能存储在 内存中，因此需要存储在硬盘中，这样的话查询 索引 就需要进行 磁盘 IO，而一次磁盘 IO 的消耗比内存存取要高几个数量级，因此，使用索引要尽量减少 磁盘 IO，即 磁盘 IO 的次数也成了索引 数据结构的选择之一



> ### 局部性原理

**局部性原理：当某个位置的数据被使用时，那么在不久的将来它附近的数据也会被使用**



由于磁盘 IO 中，寻道（磁头旋转到数据所在位置）时间消耗的时间最长，因此一般数据读取都会用局部性原理

每次磁盘 IO 读取数据往往不是按需读取，而是每次都会预读，假设本次 磁盘 IO 只需要一个字节，那么也会从这个字节的位置开始，往后读取一定长度的数据放入内存，由于操作系统的内存是分页管理的，因此每次预读的长度都是 页 的整数倍。

这样的 磁盘 IO 是顺序 IO，不需要进行寻道，直接往下读就行了，顺序 IO 下，从磁盘读取 1 B 的数据和 读取 1 KB 的数据花费的时间基本上是一致的



**因此，索引的底层数据结构选择要能够进行满足局部性原理的**



综上，索引的选择需要满足以下条件：

- 快速定位到某个值
- 能够进行范围查询，效率要高
- 磁盘 IO 次数少
- 利用磁盘每次预读 页 的整数倍的局部性原理，减少磁盘 IO



## 2、索引的底层数据结构选择



### 1、哈希表

通过 hash 算法 O(1) 定位到某个位置

假设我们求 id = 7 的数据，先通过 hash 算法求 7 映射的地址，然后获取对应的数据

但是 hash 算法会存在数据冲突，即两个以上的数据经过 hash 计算出的结果是一样的，这样就产生 哈希冲突

常见的做法是使用链地址法，这样的话，遍历数据就需要 从链表头遍历到链表尾



可以看出，哈希表能够 O(1) 查找数据，效率很高，但为什么索引不使用 哈希表呢？

- 不支持范围查询，哈希表等值查询效率最高，但是如果涉及到范围查询，由于哈希表之间的数据并无关联，因此一个可行的方法是查询出所有的数据，然后进行筛选，这样无异于就是暴力解法，效率极低
- 哈希冲突降低效率，当数据量大，链表长度长的时候，比如 100 个节点，最坏情况需要比较 100 次，这效率也是低。(虽然可以转换为红黑树，不过后面也会讲为什么不使用红黑树)
- 哈希表不支持联合索引的最左匹配原则



### 2、二叉查找树

很简单，由于不会自己保持平衡，所以可能会退化成链表，查询效率低



### 3、AVL 树 和 红黑树

AVL 树 和 红黑树的区别就是 AVL 树是高度平衡的，保持平衡的开销比 红黑树大，但是由于保证了平衡，因此 AVL 的树的高度一般比 红黑树 低，这样的话，磁盘 IO 的次数也就比 红黑树少了



但是不使用它们的原因是因为它们是二叉树，本身节点存储的数据量少，导致当节点个数多的时候，树的高度很大，导致磁盘 IO 次数增加，降低效率

基本 AVL 和 红黑树都是数据存储在 内存中才会使用到的数据结构，因为这样可以避免磁盘 IO



### 4、B 树

B 树 是一棵平衡的多叉查找树，它与二叉树最大的不同就是，每个节点可以存储多个数据，而二叉树每个节点只能存储一个数据



当我们设置 B 树的每个节点可存储 key 的个数越多时，那么高度越小，比如 存储 16 个数据的 B 树，只需要 2 次 磁盘 IO，效率超过 AVL 树一半

![img](https://pic3.zhimg.com/80/v2-7d5e34c698b1e4192ad0ff93c2c897d0_720w.jpg)





B 树作为索引树，是通过 增加节点存储的数据量来减少树的高度，进而减少磁盘 IO

并且他每个节点都存储数据行，因此不会存在 聚簇索引 和 非聚簇索引 的概念

![img](http://cdn.17coding.info/WeChat%20Screenshot_20190620221029.png)



mysql 中的 B 树有几个特点：

- B 树查找效率为  O(hlogn)，h 为树的高度，n 为每个节点关键词的个数，当我们找到某个节点的时候，可以通过二分查找判断某个关键词是否存在，这样的话就是 O(logn)，而高度为 h，最坏需要 h 次，因此时间复杂度为 O(hlogn)
- 减少了磁盘 IO
- 每个节点既存储索引，又存储数据



```java
这里需要说下，B 树扩充每个节点存储的 key 的个数也同样利用了局部性原理加快速率

因为磁盘预读每次都是以 页的整数倍进行读取的，因此 B 树将每个节点的大小设置为页
这样每次读取的话就是刚好按照页为单位，读取一整个节点，既一次 IO 获取了整个节点
而这个节点中又存储了很多的 key，提高了查询的数据量，因此提高了查询的效率
```



### 5、B+ 树

B 树每个节点存储的都是索引和数据，而 B+ 树除叶子节点外，每个节点存储的都是索引，不包括数据，数据只存在于叶子节点上

B+ 树非叶子节点的 key 在叶子节点上都能找到，因为非叶子节点不存在数据，所以对应 key 的数据必须存在于叶子节点中

![img](http://cdn.17coding.info/WeChat%20Screenshot_20190621220003.png)



由于 B 树每个节点存储了索引和数据，而 B+ 树除叶子节点外每个节点只存储 索引，而 mysql 中每个节点的大小固定设置为 一个页的大小，因此 B 树每个节点所能存储的 key 比 B+ 树少，因此 B+ 树一个节点能存储更多的 key，借此可以直接通过 一次 磁盘 IO 和 二分查询 判断更多的数据

并且由于每个节点能够存储的 key 更多，导致每一层的数据量就更多，从而使得树的高度减少，磁盘 IO 数量减少



而 B+ 树的叶子节点是通过指针相连来构成链表的，这样直可以很方便进行范围查询



B+ 树 相对 B 树的优点：

- 除叶子节点外其它节点都是存储索引，这样在每个节点都是固定一页的情况下，能够存储的 key 更多，一层能够存储的数据量比 B 树大得多，从而使得树的高度更低，磁盘 IO 的次数更少
- B+ 树的叶子节点使用 链表串起来，范围查询的效率更高

B 树 和 B+ 树的节点上面也说了，就是利用局部性原理，才设置大小为 一页的



**综上，不选择其他数据结构，就是因为 B+ 树满足索引所需的全部优质条件：范围查询性能好，树的高度低，磁盘 IO 次数少，且支持 多列联合索引的最左匹配原则**





## 3、索引 的 种类

### 1、聚簇索引

聚簇索引 表示索引树的叶子内的数据就是完整的数据行

如果表设置了主键，那么主键构成的索引树就是 聚簇索引，它的叶子节点存储完整的数据行

如果没有设置主键，那么找到第一个 not null 属性 的唯一索引作为聚簇索引

如果还没有，那么使用 InnoDB 在每行数据后面 生成的隐藏字段之一的 row_id 作为 聚簇索引



如下图就是 聚簇索引 的索引树，叶子节点就是完整的数据行

*![image.png](https://pic.leetcode-cn.com/1599556528-sXLuAF-image.png)*



### 2、非聚簇索引

除 聚簇索引 索引外的其他所有，都是 非聚簇索引

比如设置了主键为 聚簇索引 后，那么剩下的唯一索引也会称为 非聚簇索引

它的特点是叶子节点存储的是 对应所在数据行的 聚簇索引

意思是我们查找 非聚簇索引 的话，需要进行两次查找才能得到完整数据行

- 第一次查找 非聚簇索引 的索引树，在叶子节点处得到 聚簇索引 的值
- 第二次查找 聚簇索引 的索引树，在叶子节点处得到完整的数据行

因此查找 聚簇索引 效率比 查找 非聚簇索引 效率高



**拿着 从 非聚簇索引 的索引树上查找到的 聚簇索引 的值，再从 聚簇索引 的索引树上查找数据，这个过程叫做回表**



下图就是查找 非聚簇索引 的索引树，以 age 字段构成的索引，对比上述的 聚簇索引的索引树看，叶子节点对应的是上述 聚簇索引 的值

*![image.png](https://pic.leetcode-cn.com/1599556509-eedyXk-image.png)*



> ### 为什么一个表只存在一个 聚簇索引 ？多设置几个提高查询效率不好吗？

我们需要知道，聚簇索引 它的叶子节点存储的是完整的数据行，当一个表的数据量达到 上千万，上亿 的时候，那么对应的这个 索引文件将会是非常大，如果多设置几个，并且还有多个表，这空间占用，这谁顶得住？？？





### 3、联合索引

联合索引说的是多个列组成一个索引，构建一棵索引树

比如 (id, age, name) 就是将 id、name、age 三个列建立成一个索引树，数据存放 以及 查询的顺序从左到右，因为 索引树是 B+ 树，它是一棵多路平衡查找树，内部自动是有序的，而这个排序则是按照 联合索引的列的定义顺序来的，因此排序是先按照 id，如果 id 相同再按照 age，如果 age 相同则再按照 name

因此，当我们使用联合索引进行查询的时候，需要注意查询条件的使用，因为索引树内部是有排序的，因此表面看来，所有数据的排序初始是根据索引的第一个列来进行排序的，尔后才是根据第二个列。因此如果第一个列没有使用到，这就意味着对后面的字段来说这棵索引树就变成了无序的了



比如 `idx_a_b_c` (`a`,`b`,`c`) 

```java
 select  * from test where a = '333' and b = '333' and c = '333'; //走索引，走 a b c

 select  * from test where a = '333' and b = '333'; //走索引，走 a b 

 select  * from test where a = '333' and c = '333';//走索引，走 a

 select  * from test where  b = '333' and c = '333'; //不走索引，因为索引树是按照 a 排序的，a 不查询的话 索引树就无序了

 select  * from test where c = '333' and b = '333' and a = '333'; //走索引，走 a b c

 select * from myTest  where a=3 and b>7 and c=3; //走索引，走 a 和 b，而 c 被 b 阻断了
 
 select * from myTest  where a>4 and b=7 and c=9; //走索引，只有 a , 后面的 b 被 a 阻断了

 select  * from test where a = '333' and b like '%3' and c = '333'; //走索引，只走 a，因为 b 无法确定前面的数值，这样的话就是无序的了

 select  * from test where a = '333' and b like '3%' and c = '333'; //走索引，走 a 和 b，因为 b 能够确定前面的数值，因此还是有序的
```



> ### 索引 区分度

索引的区分度，可以用来衡量索引值的优劣

索引区分度 = 不重复的索引值个数 / 数据表的总记录数， 这表示区分度越高，查询某个数据越能过滤掉更多的数据

越接近 1，区分度越高



如果对 性别 sex 建立索引，那么只有 0 和 1 两个值，整张表假设 千万数据，区分度低得一批，那么查询也不能过滤掉多少数据，因此没必要建立索引，直接走 聚簇索引扫描



> ### 最左匹配原则

建立联合索引的时候，区分度最高的放在左边，因为这样能够过滤掉很多数据

需要注意的是

- 最左匹配原则当匹配到范围查询的时候会停止匹配
- 索引的建立 跟 where 字段的顺序没有多大关系，因为查询优化器会自动进行优化



假设我们对 (a, b) 建立索引，那么索引树如下

我们可以看到，a 是全局有序的，而 b 是局部有序的，即在 a 相同的情况下， b 保证了有序

而在 a 不同的情况下，b 是无序的，这就是导致 范围查询 停止匹配的原因，因为范围查询字段后面的字段是无序的

![img](https://pic3.zhimg.com/v2-fcde0ef783885b6b17999f39ca2808b5_b.jpg)



> ### 索引建立 练习

```sql
SELECT * FROM table WHERE a = 1 and b = 2 and c = 3;
```

可以对 (a,b,c)、(a,c,b)、(b,a,c)、(b,c,a) 建立索引，具体情况看哪个区分度最高



```sql
SELECT * FROM table WHERE a > 1 and b = 2;
```

由于 最左匹配原则 会在范围查询处停止，所以即使 a 的区分度更高，我们也不能建立 (a,b) 索引，而应该建立 (b,a) 索引



```sql
SELECT * FROM `table` WHERE a > 1 and b = 2 and c > 3;
```

可以建立 (b,a) 或者 (b,c)，具体看 a 和 c 哪个区分度更高



```sql
SELECT * FROM `table` WHERE a = 1 and b = 2 and c > 3;
```

可以建立 (a,b,c) 或者 (b,a,c)，具体看 a 和 b 哪个区分度更高



```sql
SELECT * FROM `table` WHERE a = 1 ORDER BY b;
```

对 (a,b) 建立索引，这样 a 查找完 b 也是有序的



```java
SELECT * FROM `table` WHERE a > 1 ORDER BY b;
```

对 (a) 建立索引，因为 a 是范围查找，对 b 来说是无序的，用不到索引，没必要建立 (a,b) 索引



```sql
SELECT * FROM `table` WHERE a = 1 AND b = 2 AND c > 3 ORDER BY c;
```

建立 (a,b,c) 或者 (b,a,c)，具体看 a 和 b 哪个区分度更高



```sql
SELECT * FROM `table` WHERE a IN (1,2,3) and b > 1;
```

对 (a,b) 建立索引，因为 IN 相当于等值查询，查询完 a = 1 ，b  是有序的，然后再去查询 a = 2，b 也是有序的，a = 3 也是如此



```sql
SELECT * FROM `table` WHERE a = 1 AND b IN (1,2,3) ORDER BY c;
```

可以建立 (b,a) 或者 (a,b)，具体看 a 和 b 哪个区分度更高

对于 order by c 来说，是用不到索引的，因为 a 和 b 中按照顺序查询出来的数据行中 c 是无序的，最终还是需要进行排序



```sql
SELECT * FROM `table` WHERE a = 1 AND b IN (1,2,3) AND c > 3 ORDER BY c;
```

可以创建 (a,b,c) 或者 (b,a,c)，具体看 a 和 b 哪个区分度更高，而 c 能够上索引是范围查询

对于 order by c 来说，我们按照顺序查询出来的 同时满足 a = 1 和 b = 1 以及 a = 1 和 b = 2 以及 a = 1 和 b = 3 的数据行中 c 的值是无序的，最终还是需要排序





### 4、覆盖索引

覆盖索引是针对某种 select 来说的 联合索引

就是查询的字段全部在索引上，这样的话就无需回表



比如 `idx_a_b_c` (`a`,`b`,`c`) 

```java
 SELECT a,b,c from test where a = '333'; //无需回表，因为 a b c 三个列构成了一棵索引树，而查询的字段 a b c 都在这棵索引树上，因此无需再去 聚簇索引 的索引树上进行回表查询

 SELECT a,b,c,d from test where a = '333'; //需要回表，因为查询的字段 a b c d 中，只有 a b c 在索引树上，而字段 d 没有，因此需要到 聚簇索引 的索引树上获取对应的完整数据行，然后获取字段 d 的值
```



**由此可知，身为 聚簇索引一定只需要查询一遍索引树，而非聚簇索引 的可能只需要查询一遍索引树（覆盖索引），也可能需要查询两边索引树**

**因此，一般我们建立索引，查询字段尽可能满足 覆盖索引，这样可以少一遍 索引树的查询**





## 4、特殊的索引-全文索引

原文链接：<http://www.360doc.com/content/17/1211/13/33260087_712076317.shtml>



当我们使用模糊查询的时候，一般情况下使用的是 like "%xxx%"

而当我们只记得某篇文章的某个字段，但又不确定这个字段是正确的，印象中又记得文章作者的名字中的某个字，那么 sql 语句会是这样的：

```sql
select * from t where 文章 like "%xxx%" or 作者 like "%xxx%"
```

这种 sql 语句显然就是在找死，一篇文章可能上千个字，而且使用这个 like 还不能走索引，效率低得一批，查完茶都凉了

业务中基本不可能这么用，那么是怎么实现类似这种 sql 的高效查询呢？

使用 全文索引



创建表的同时创建全文索引

```sql
             CREATE TABLE article (
                 id INT AUTO_INCREMENT NOT NULL PRIMARY KEY,
                 title VARCHAR(200),
                 content TEXT,
                 FULLTEXT(title, body)
             ) TYPE=MYISAM;
```

全文索引就是对某些指定的列创建索引，然后指定对应的关键词存在于哪些数据行中，记录对用的数据行 id



假设我们有这么一张数据库表

*![image.png](https://pic.leetcode-cn.com/1600506086-AQqybI-image.png)*



我们对 文章内容 创建了一个全文索引，记录出现对应关键词的数据行的 id

*![image.png](https://pic.leetcode-cn.com/1600506211-kxZPcJ-image.png)*

这里的关键词是内部自动进行分词的，原本默认只支持英文分词，后续更新好像支持中文了





## 5、为什么 MongoDB 使用 B 树作为索引，而 mysql 使用 B+ 树

具体看  https://zhuanlan.zhihu.com/p/107228878 



**B 树 结构：**

 ![img](https://pic3.zhimg.com/80/v2-e58725270f022db69a68d0dc727e5bf2_720w.jpg)

B 树的特点：

- 每个节点都存储数据
- 相邻节点之间没有指针连接



**B+ 树 结构** 

 ![img](https://picb.zhimg.com/80/v2-0e3ace7e4fa6cf4da345f12e98aca872_720w.jpg) 



B+ 树的特点：

- 只有叶子节点之间存储数据
- 叶子节点的相邻节点存在指针连接



由此看来：

（1）B 树每个节点都存储数据，查询的效率不固定，最好的情况是 O(1)，最坏也是 O(logn)

因此 B 树在单一查询的适合，B 树的平均性能更好

而 B 树中个节点之间没有相邻指针，因此不适合做遍历操作，因为只能顺着某条路径往下，如果要遍历相邻节点，就需要从根节点开始遍历 或者 dfs 的时候回溯

（2）B+ 树在叶子节点粗出数据，因此单一查询的时候，很稳定，时间复杂度都是 O(logn)，比起 B 树要略差

但是叶子节点相邻节点间存在指针相连，因此适合遍历操作



> ### 为什么 mysql 使用 B+ 树，而 mongoDB 使用 B 树

因为 mysql 是关系型数据库，所以 mysql 将具有相同属性的数据放在一起，会经常用到范围查询

而 mongoDB 是非关系型数据库，它是面向文档的，直接存储为 BSON ，这样可以使得 mongoDB 可以插入数组之类的复杂数据类型，它将各种属性都整合在一起，比如 mysql 中有用户表、订单表、购物表等，它们之间存在键关系，而在 mongoDB 中都是直接整合为一个 BSON 的，一般情况下 mongoDB 是单一查询，由于 B树 节点就已经存储了数据，因此最好是 O(1)，效率挺高

 ![img](https://pic4.zhimg.com/80/v2-d6fe8d74a0b9fbfe31de3f820b88449b_720w.jpg?source=1940ef5c) 


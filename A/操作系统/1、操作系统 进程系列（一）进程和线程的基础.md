# 进程和线程的基础





## 1、用户态 和 内核态



> #### 用户态 和 内核态的关系

内存假设为 4G，那么内核态和用户态共用瓜分这 4G 内存，即将一部分作为内核态，一部分作为用户态

**地址空间划分： 0xc0000000以上的地址空间只能在内核态下访问，  0x00000000-0xbfffffff的地址空间在两种状态下都可以访问。** 



用户态：CPU 调用某个进程时，CPU 只能访问该进程所映射的内存，不允许访问外围设备（硬盘，键盘，网卡等），占用 CPU 的能力可以被剥夺，CPU 资源可以被其他程序获取

内核态：CPU 可以访问内存的所有数据，以及 外围设备



涉及到计算机资源的操作，比如读写文件，都需要在内核态中，因为文件不可能直接放在用户态中，否则用户态的程序就可以随意访问篡改了；

跟用户数据相关的，比如 JVM 内存这种，Java 自己定义的变量对象之类的，则在用户态运行

用户态的程序只能持有文件的文件描述符 fd，具体的操作通过传输 fd 给内核态，让 CPU 进入内核态中进行操作





> #### 内核态 和 用户态 切换开销

Linux 中每个进程都有两个栈：用户栈 和 内核栈

当发生用户态到内核态的切换时，CPU 需要保存好 用户栈的数据，然后切换到内核栈

**切换开销：**

- **栈的切换前需要保存很多的 CPU 寄存器，并且切换后也需要恢复很多 CPU 寄存器**
- 从用户态切换到内核态时，CPU cache 中的数据是用户态的数据，因此直接无效；当从内核态切换到用户态时，CPU cache 也同样无效，使得**缓存命中率下降**



> #### 什么时候用户态会切换到内核态？

- 系统调用：比如 read()、write() 等
- 异常：比如 缺页异常
- 外围设备中断：比如硬盘读写完成，CPU 会停止指向下一条将要执行的指令，去处理中断后的后续操作





## 2、线程



> #### 为什么使用线程？

我们举个例子，假设你要编写一个视频播放器软件，那么该软件功能的核心模块有三个：

- 从视频文件当中读取数据；
- 对读取的数据进行解压缩；
- 把解压缩后的视频数据播放出来；

对于单进程的实现方式，我想大家都会是以下这个方式：

![img](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcvw4t9kicec370n3cvX2JS929V7rcLXiaaB16boR9VraolG9Fgc9NpnxOSlHx7No6t0zSPrscaeuaA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

（这里需要说明一下，java 中，我们运行一个类 main() 方法的时候，它就是一个独立的进程，当我们运行两个类的 main() 方法的时候，它们就是两个独立的进程，互不干扰）

因此上面的这种方式是运行在一个类中的，是一个进程

单进程是按顺序执行的，即必须先 Read() 执行完毕后再 解压缩数据，再进行播放

由于需要边读取边播放，因此我们每读取 1 个字节就进行解压缩再播放，这样就可以边读取压缩边播放

对于单进程的这种方式，存在以下问题：

- 可能由于 CPU 的原因，我们在 Read() 方法这里卡住了，那么就会导致半天才能数据解压和播放，体验不友好
- 单进程的方式，各个函数之间不是并发执行的，而是顺序执行的影响效率

那改成多进程的方式：

![img](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcvw4t9kicec370n3cvX2JS9CInoGdDVyYvtTfju7gVeKLjDNOMmul4kPzicTbczNiaBSzGiaEzDXtYTA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

这就又产生一个问题了，多进程，其实就是多个类，一个类执行一个函数，那么这几个类怎么进行共享数据？比如你多个类同时执行 main() 方法，数据能共享吗？

不能吧！！！！

那到底如何解决呢？需要有一种新的实体，满足以下特性：

- 实体之间可以并发运行；
- 实体之间共享相同的地址空间；

这个新的实体，就是**线程( Thread )**，线程之间可以并发运行且共享相同的地址空间。



> #### 线程与进程的比较

**进程是资源分配的基本单位， 线程是调度的基本单位**。

这里我们可以看出来，最开始讲的进程是调度的基本单位，等到线程出来后，进程单单就变成了资源分配的基本单位了，即是提供一个资源共享的平台给它内部的线程使用，单单只是作为一个交流平台而已，所有的线程都可以来这里拿数据资源

所以，由于资源是共享的，所有线程都能拿到，才存在线程安全的问题，即到底是谁先拿到，以及谁做的改变才有效等问题



## 3、进程/线程 上下文切换

进程有两个栈，用户栈 和 内核栈，内核栈对于用户来说不可见，对于内核来说可见

为什么需要内核栈？

一个简单的理解就是 用户栈不可靠，假如用户栈快要溢出了，然后切换到内核态中执行，内核如果使用用户栈保存数据，那么就会导致内核崩溃。



进程上下文切换需要 保存旧进程的 虚拟页目录、全局变量等用户态资源，还会保存内核堆栈、文件描述符 fd、CPU 寄存器 等内核态资源

这些数据打包好保存在进程的用户栈上，并且将栈顶指针保存在进程的 PCB 中



而线程上下文切换只需要保存 

- 虚拟机栈（存储调用的方法栈帧）
- 程序计数器（方法执行的下一条 JVM 指令）
- CPU 寄存器状态（因为 CPU 可能运算一半，这些运算的变量值是在 CPU 寄存器中的，下次切换回来不希望重新执行，所以需要进行保存）



> #### 为什么说上下文切换导致 CPU 效率降低

 假设 一个 CPU 主频是 2.6GHz，这意味着每秒可以执行：2.6*10^9 个指令，那么每个指令的时间大概是0.38ns！

而一次上下文切换，将近需要耗时2000ns！而这个时间内，CPU 什么都干不了，只是做了保存上下文的动作！





## 4、多进程 和 多线程

> #### 多进程 和 多线程、多 CPU 和 多核 CPU

**多进程表示同时运行多个大任务**

**多线程表示单个大任务分成多个小任务同时运行**



进程作为 操作系统资源分配的基本单位，线程是 CPU 调度的基本单位

多 CPU 表示有多个 CPU，多核 CPU 表示一个 CPU 有多个核

一个 CPU 对应一个进程，而 CPU 的核对应进程中的线程

如果有多个 CPU，那么多个进程是并行执行的，如果 CPU 有多个核，那么多个线程是并行执行的

如果只有一个 CPU，那么多个进程是并发执行的，如果 CPU 只有一个核，那么同个进程中的多个线程是并发执行的



> #### CPU 密集型 和 IO 密集型

CPU 密集型表示任务需要大量的计算，需要大量占用 CPU 的资源，因此尽量避免上下文切换导致 CPU 效率降低，如果有多个 CPU 可以使用多进程

IO 密集型表示任务 99%情况下进行的是 IO 操作，IO 操作中 线程 会挂起，当挂起的时候 CPU 处于无事状态，因此可以设置多个进程 去应用这段 CPU 空闲的时间





## 5、僵尸进程 和 孤儿进程



每个进程都有自己的唯一的 PID（进程标识符），进程死亡被回收时，PID 也会被回收，并且能够分配给新的进程



> #### 孤儿进程

子进程还没有结束，而父进程自己先执行完退出了，那么这个子进程就是一个孤儿进程，它会被交给 init 进程进行管理

相比僵尸进程，孤儿进程不会占用资源，因为它最终还是会被回收的



> #### 僵尸进程

[僵尸进程详细介绍]( https://blog.csdn.net/zjwson/article/details/53321431 )



**产生的原因：**子进程死亡后，会给 父进程发送 SIGCHLD  信号，父进程的  signal(SIGCHLD, SIG_IGN) 默认忽略该信号，导致父进程没有调用 wait() 或者 waipid() 去处理子进程

- 默认忽略 SIGCHLD  信号 的原因是，在并发时候常常需要 fork 很多子进程，如果子进程结束后都需要父进程去收尸，那么效率会降低

**危害：**僵尸进程会占用 PID，系统的 PID 是循环回收利用的，一旦大量僵尸进程占用大量的 PID 号，导致无法给新进程分配 PID



**查找僵尸进程：**通过 top 命令查看僵尸进程的数量，再通过 ps 可以查看 进程 stat，查找处于 Z 状态的进程

```shell
ps -aux | grep Z

grep Z 是正则表达式匹配 Z
```



**处理方法：**

- 改写父进程的 signal()，捕捉 SIGCHLD 信号，并且调用 wait() 或者 waitpid() 进行处理
- 手动杀死父进程，这样僵尸进程就变成了孤儿进程，留给 init 进程处理
- 两次 fork()，父进程 fork 一代子进程，一代子进程再 fork 二代子进程，真正的操作在 二代子进程中，然后将 一代子进程杀死，这样二代子进程就是孤儿进程，死后自己靠 init 处理





## 6、进程 和 线程 的状态转换

> #### 1、进程的状态

**进程状态：【运行、就绪、阻塞、终止】**

状态变化如下：

运行状态 -> 就绪状态、阻塞状态

就绪状态 -> 运行状态

阻塞状态 -> 就绪状态

**终止状态：进程运行结束，需要被收尸**

![img](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcvw4t9kicec370n3cvX2JS9EfRviciaGMLREQ1nqvjWkibKlREGPI9JyfhA5XlmzFRRiaIATAEiaLbCx4w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

**阻塞事件**：比如 java 中的 scanner，即等待输入，等待的过程中，即使给进程 CPU 的控制权也没什么意义，因为它被 I/O 事件阻塞了，无法继续执行





> #### 2、线程的状态

**首先我们需要知道，为什么面试经常问 线程的状态，它很重要吗？**

是的，它的确很重要，在故障排除的时候，我们需要通过 jps 获取 Java 运行的进程，然后通过 jstack 查看该进程的所有线程的状态，按照每个线程的状态来排除是否存在问题，是否发生了死锁之类的，如果不知道哪个状态对应什么样的事件，显然是有问题的



在 Thread.State 中定义了 6 种状态

```java
public enum State {
    NEW,
    RUNNABLE,
    BLOCKED,
    WAITING,
    TIMED_WAITING,
    TERMINATED;
}
```



初始化（NEW）：线程刚创建，还没有调用 start()



运行（RUNNABLE）：java 线程将 等待 CPU 调度的 **就绪状态** 和 已经被 CPU 调度的 **运行状态** 合并为一种状态 Runnable，表示线程当前没有什么问题，就是在运行中



等待（WAITING）：这种状态的线程不会被 CPU 调用，需要显示唤醒，比如 wait()、join()**（join() 方法底层是 方法同步 sync 锁 + wait() 实现的）**

```java
//方法加 sync 锁
public final synchronized void join(long millis)
    throws InterruptedException {
    long base = System.currentTimeMillis();
    long now = 0;

    if (millis < 0) {
        throw new IllegalArgumentException("timeout value is negative");
    }

    if (millis == 0) {
        //等待
        while (isAlive()) {
            wait(0);
        }
    } else {
        while (isAlive()) {
            long delay = millis - now;
            if (delay <= 0) {
                break;
            }
            wait(delay);
            now = System.currentTimeMillis() - base;
        }
    }
}
```



超时等待（TIMED_WAITING）：这种状态的线程不会被 CPU 调用，在到达一定时间后会自动唤醒，比如 wait(1000)、Thread.sleep(1000)、Thread.join(1000)



阻塞（BLOCKED）：线程因为某种原因停止 CPU 调度，暂时停止运行，直到事件解决后才会重新进入 运行状态中的就绪状态 等待 CPU 调度，比如 **阻塞获取锁、IO 事件**



终止（TERMINATED）：线程发生异常没有处理，直接抛到 run()  或者 执行完成 退出 run() 



 ![img](https://greenhathg.github.io/2019/08/04/Java%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81/3.jpeg) 





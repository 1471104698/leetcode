# 基础知识



## 1、面向对象语言的特点

**像 java 这种面向对象的语言有三大特点：封装、继承、多态**



对于继承，需要注意的是，**子类只会继承父类的非静态方法和成员变量，而静态方法和成员变量是无法继承的**

```java
class A{
    int a = 1;
    static int b = 3;
}
class B extends A{
    int a = 2;
    public static void main(String[] args) {
        A b = new B();
        System.out.println(b.a);//输出父类 A 的 a 值 1
        System.out.println(b.b);//编译时报错，因为 B 不能继承 A 的静态变量 b
    }
}
```



封装就不说了，主要说说什么是多态，以及多态的两种类型（编译时和运行时）



> 多态的概念

多态，如字面意思，同种行为具有不同的表现形态

现实中，比如我们按下 F1 键这个动作：

- 如果当前在 Flash 界面下弹出的就是 AS 3 的帮助文档；
- 如果当前在 Word 下弹出的就是 Word 帮助；
- 在 Windows 下弹出的就是 Windows 帮助和支持。

同一个事件发生在不同的对象上会产生不同的结果。



> 多态产生的必要条件

**多态存在的三个必要条件**

- 继承
- 重写
- 父类引用指向子类对象

多态是父子之间的关系，父可以是 类 和 接口，子需要 继承类 或者 实现接口

比如：

```java
Parent p = new Child();
```

**函数执行结果的多态：**

一条语句必须同时出现父类和子类，不过是父类的引用和子类的对象

并且要出现一个行为有多种表现形态的话，那么子类就必须重写父类的方法，让方法调用的效果与父类不同



**函数调用传参的多态：**

当我们调用方法传输参数的时候，方法参数设置为父类，那么我们可以传入它的各个子类，方法执行效果如同上面的多态



> 重载是不是多态呢？

多态产生的 3 个必要条件中，第二个条件说的是重写，那么重载是不是多态呢？

有的说是多态，因为相同的一个函数名存在多种不同的执行结果

有的说不是，因为重载是发生在一个类中的，不是发生在继承类之间的，即它们认为必须是父子之间的多态行为

当然，这只是一种工具，差不多知道就好，也没有具体的界定



> 两种多态类型：编译时多态 和 运行时多态

**编译时多态：编译期间就确定的**，主要是方法重载、 静态方法成员和变量、非静态成员变量

我们写的代码都是静态文件，需要编译成二进制文件才能运行，而编译成的二进制文件其实是一条条指令，CPU 根据按照顺序运行这些指令就是在运行我们的代码，当我们一个类中存在多个同名的方法（重载）的时候，编译时就需要通过我们调用方法传入的参数来确定调用的是哪个方法（这是方法重载，静态方法变量和非静态变量的引用也是这个时候确定的）



**运行时多态：运行时候才确定的** ，主要是方法重写，同个方法（父类和子类之间的角度）调用时出现的不同执行效果

比如 

```java
Parent p = new Child();
p.run();
```

上面这个 p 执行的就是子类的 run() 方法，这是在运行时候才确定调用的是哪个方法

主要是使用虚函数来实现，它指向 我们调用的 run() 方法调用的是谁的方法

如果子类中重写了 run() 方法，虚函数指向的是 子类的 run()，如果没有，那么虚函数指向的是 父类的 run()





## 2、为什么浮点数类型 float 和 double 不能使用 == 进行比较

我们首先需要知道，float 是 4 个字节，32 位， double 是 6 个字节，64 位（类比 int 和 long）

整型默认情况下是 int ，浮点型默认情况下是 double ，两者相反



在 Java 中运行一下代码
`System.out.println(2.00 - 1.10);`
**输出的结果是：0.8999999999999999**

为什么会产生这样的结果？

我们从底层浮点数的存储来看



> 浮点数在计算机中的存储

|        | 符号位 | 指数   | 尾数   |
| ------ | ------ | ------ | ------ |
| float  | 1 bit  | 8 bit  | 23 bit |
| double | 1 bit  | 11 bit | 52 bit |



浮点数是有一定存储范围的，我们将一个十进制数存储进计算机的时候，实际上是转换为二进制数

上面的 1.10，整数部分 1 二进制就是 1 ，而小数 0.10 的转换如下：

0.1 * 2 = 0.2，取整数部分 0，余数为 0.2

0.2 * 2 = 0.4，取整数部分 0，余数为 0.4

0.4 * 2 = 0.8，取整数部分 0，余数为 0.8

0.8 * 2 = 1.6，取整数部分 1，余数为 0.6

。。。

。。。

我们可以看出，无论如何 0.1 都无法取到尽头，但是由于 double 类型的尾数部分只能存储 52 bit，因此导致超出的部分被舍去了

导致了精度丢失

而上面输出 0.8999 同样是精度丢失的问题，因为 0.1 无法精确转化为二进制数，只能无限接近，导致转换的值比 0.9 大，因此才出现了 0.0000000...1 的差距



> 将上面的运算替换为 float 后是什么结果？

我们也说了，浮点数默认是 double 类型，如果我们转换成 

`System.out.println(2.00f - 1.10f);`

**输出的结果是：0.9**

这是因为 float 的精度没有 double 高，因此将多出的比 0.9 大的精度给舍弃了，所以才得到正确的 0.9



> float 和 double 比较

```java
float f1 = 0.5f;
double d1 = 0.5;

float f2 = 0.1f;
double d2 = 0.1;

System.out.println(f1 == d1); // true
System.out.println(f2 == d2); // false
```

上面代码出现不同情况的原因同样是因为精度丢失

由于 0.5 能够准确转换为 二进制数，因此 float 和 double 结果是一样的

但是 0.1 无法准确转换为 二进制数，而 float 的尾数位数 比 double 少，因此精度比 double 小，即转换结果为 f2 < d2





## 3、String str = new String(`"abc"`) 创建了多少个对象

```java
String s1 = new String("abc");
String s2 = "abc";
System.out.println(s1 == s2); //false
```

当常量池中不存在 `abc` 这个字符串时，那么 `new String("abc")` 创建了两个对象，一个存放在常量池中，一个存放在 堆内存中

然后 s1 指向了堆中的对象，s2 指向常量池中的对象



```java
String s1 = "abc";
String s2 = "abc";
System.out.println(s1 == s2); //true
```

只创建了一个对象，存放在常量池中，s1 和 s2 指向的都是常量池中的对象



```java
String s1 = "a" + "bc";
String s2 = "abc";
System.out.println(s1 == s2); //true
```

如果常量池中不存在 `a` `bc` `abc` 这3 个字符串时，那么创建了 3 个对象，都在常量池中

然后 s1 和 s2 都指向了常量池中的对象





## 4、hashmap 相关知识



### 4.1、hashmap 和 hashtable 的区别

---



> 相同点

hashmap 和 hashtable 都实现了 Map 接口



> 区别

hashmap 是线程不安全的，所有方法都没有锁机制

hashtable 是线程安全的，所有方法都加了重量级锁 synchronized



hashmap 的 key 和 value 都允许空值

hashtable 的 key 和 value 都不允许空值



hashmap 的默认容量是 16，后续扩容直接 * 2，即 cap << 1，这样就能保证是 2 的指数

hashtable 的默认容量是 11，后续扩容是 2 * old + 1



hashmap 的遍历方式是 iterator

hashtable 的遍历方式是 xxx（不知道什么东西）



一般在单线程下，我们使用的是 hashmap，效率比 hashtable 高

一般在多线程下，我们不使用 hashtable，也肯定不能使用 hashmap，而是使用一个效率更高的用来代替 hashtable 的 ConcurrentHashMap



### 4.2、hashmap 求 2 的指数的算法

---



该算法能够得到比 cap 大的最接近 cap 的 2 的指数

```java
static final int tableSizeFor(int cap) {
    int n = cap - 1;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
}
```



假设 n 的二进制数为 01xxxxxxxxxx

n |= n >>> 1； 对 n 右移 1 位，然后进行或操作，那么 n 变成  011xxxxxxxxx

n |= n >>> 2； 对 n 右移 2 位，然后进行或操作，那么 n 变成  01111xxxxxxx

n |= n >>> 4； 对 n 右移 4 位，然后进行或操作，那么 n 变成  011111111xxx

n |= n >>> 8； 对 n 右移 8 位，然后进行或操作，那么 n 变成  011111111111.。。。

。。。

可以看出，最终所有操作执行完毕，得到的是将最高位的 1 后面的数全部变成 1，比如 0100101，那么就变成 0111111

然后最后对它进行 n + 1，就变成 1000000，刚好是 2 的指数次

上面是 1 + 2 + 4 + 8 + 16 = 31，因为 int 型是 32 位，这样能够覆盖所有二进制数



最开始是 n = cap - 1 是为了防止最开始的 cap 就是 2 的指数的问题

比如 cap = 0100，最接近 cap 的 2 的指数就是它本身，那么 cap - 1 后 n = 0011，那么经过计算 n = 0100

而如果 cap 不减 1，那么 n = 0100，经过计算后会变成 n = 1000



### 4.3、hashmap 的扩容机制 resize()

---

> 什么时候会触发扩容？



当元素数量超过阈值的时候，那么就会触发扩容

阈值 = 容量 * 加载因子（加载因子一般是 0.75）



扩容是 容量变为原来的 2 倍，cap << 1，而阈值也同样变为原来的 2 倍



需要注意的是，一般是在 put() 完元素的时候，才判断是否需要进行扩容，即添加完元素再进行扩容的



> JDK 7 和 JDK 8 的扩容后进行的元素迁移机制

**JDK 7：**所有的元素都是链表的保存形式，开辟一个新的 Entry[] 数组后，开始将旧数组上的 Entry 插入到新的数组上去

**注意点：**

- 使用的是头插法，即旧数组按序遍历的节点，每次都是插入到新数组对应链表的头部，那么就会造成原本的节点顺序发生翻转
- 多线程下，元素迁移的过程中会发生死循环



**JDK 8：**由于 JDK 8 的容量始终是 2 的指数次幂，因此大大提高了迁移的效率，每个 Entry 无需重新 hash 来决定它在新数组中的存放位置，新的位置不是在 **原位置**，就是在 **原位置 + 原长度**

为什么？原因如下：

 ![img](https://pic2.zhimg.com/80/v2-da2df9ad67181daa328bb09515c1e1c8_720w.png) 

我们可以知道，JDK 8 扩容就是将 容量 左移一位，即 n << 1

当原容量为  1 0000 的时候，那么就是使用 n - 1 = 1111 来对 Entry  hash，那么只有尾四位进行计算，始终落在 0 - 15 的位置

而当扩容后，变成 10 0000 的时候，那么就是使用 n - 1 = 1 1111 来对 Entry hash，那么就多了高位一个 1，就是尾 五位 进行计算，这个 高位 1 就是原数组的长度，因此如果 hash 后该位置不为 0，只需要在原位置 加上原数组长度就是新的位置了

**注意点：**

- 正序插入，不会出现链表倒置
- 超过 8 个元素就将链表转换为红黑树，加快查询效率



> JDK 7 元素迁移 在 多线程 下死循环是如何产生的？

我们需要先看 JDK 7 元素迁移的代码：

```java

//newTable：新的数组，rehash：是否重新计算哈希
void transfer(Entry[] newTable, boolean rehash) {
    //获取新数组的长度
    int newCapacity = newTable.length;
    
    //遍历旧数组，需要注意的是，这里的 e 是一个链表头，而不是单单一个元素，通过 next 获取下一个节点
    for (Entry<K,V> e : table) {
        while(null != e) {
            //先记录下一个节点
            Entry<K,V> next = e.next;
            if (rehash) {
                e.hash = null == e.key ? 0 : hash(e.key);
            }
            int i = indexFor(e.hash, newCapacity);
            /*
            将节点 e 插入到 新的位置的头部，作为头节点，这就是头插法
            比如 
            e = 4
            newTable[i] = 3 -> 2 -> 1
            经过头插法
            那么就变成了 newTable[i] = 4 -> 3 -> 2 -> 1
            */
            e.next = newTable[i];
            newTable[i] = e;
            e = next;
        }
    }
```



**单线程下的元素迁移：**

 ![img](https://img-blog.csdnimg.cn/20190331174623768.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIyMTU4NzQz,size_16,color_FFFFFF,t_70) 



**多线程下的元素迁移：**

我们需要知道，多线程不是并行执行的，而是并发执行的，某个线程执行的过程中可能 CPU 会切换到其他线程

因此，某段代码 线程安不安全需要看 CPU 切换后执行别的线程是否对当前线程的这段代码的结果产生影响

很显然，这里就会

**过程：**

- 线程 1 和 线程 2 同时扩容，CPU 先执行线程 1

- 当线程 1 执行完 `Entry<K,V> next = e.next;` ，CPU 切换到 线程 2 ，注意，这里线程 1 的 e 指向的是 节点 3，而 next 指向 节点 7
- 当线程 2 执行完成后，由于是头插法，那么意味着最终的数组从 3 -> 7 就变成了 7 -> 3，注意，这里 7.next = 3，然后切换到线程 1
- 线程 1 将节点 3 插入到新的数组上，3.next = null，然后再处理 next = 7，一次新循环将 e 指向 7，由于 7.next = 3，所以 next = 3**（循环的初步建立）**
- 当使用头插法插入到新位置时，由于 3 和 7 是同个位置，因此 7 作为头节点时，7.next = 3，再然后处理 next = 3，一次新循环将 e 指向 3，再将 3 插入到新位置头节点，这时 3.next = 7，**死循环构成**

  

**这里需要注意的是：**Entry 节点对象至始至终都没有发生改变，改变的是新旧数组这个容器 和 Entry 对象存储的位置，并没有创建新的 Entry 对象去代替旧的 Entry 对象，它们存储在堆中，是所有线程共享的

因此线程 1 和 线程 2 操作的一直是同样的几个 Entry 对象，所以才造成了死循环





## 5、乐观锁和悲观锁



> 乐观锁 和 悲观锁 的概念



**悲观锁：**

将事物都想得很悲观，每个线程拿数据的时候都认为自己使用这个数据的期间别的线程都会进行修改，因此对这个数据加上锁，对别的线程进行排斥，比如 mysql 的写锁、表锁、行锁， 以及 java 中的  synchronized 和 ReentrantLock 等独占锁都是悲观锁的实现

悲观锁适用于多写的环境，因为这样才保证每次只有一个线程在修改，确保了数据的准确性



**乐观锁：**

将事物都想得很乐观，每个线程获取数据的时候都认为别人不会修改，因此不会对数据加锁，只会在写数据的时候判断数据是否被修改过，像 数据库中的 加个字段的版本控制 和 另一种 CAS 算法 都是乐观锁的实现，而 java 中 `AtomicIntger` 等原子类就是 volatile 修饰的 int 变量 + CAS

乐观锁不会对数据加锁，因此可以存在多个线程同时修改的情况，如果一直存在冲突，比如存在 n 个线程同时修改同个数据，那么最终只有一个线程会修改成功，其他的线程都需要进行自旋，获取最新的版本号进行重试，每次只有一个线程成功，效率过低

因此乐观锁适用于多读的情况



> 乐观锁的两种实现



这里需要说下，乐观锁在冲突的情况下，都需要进行自旋重试（重新获取版本号之类的，然后重新提交自己更新的数据）



**版本号控制：**

像 mysql 中同个给表添加一个 `version` 字段来代替 行锁 之类的悲观锁

当事务 A 和 事务 B 同时修改某个数据，而这个数据的初始版本号是 1 ，当事务 A 修改完率先提交，将版本号修改为 2，那么当事务 B 提交的时候，发现该数据的版本号跟自己持有的数据版本号不一样，那么就意味着被其他事务修改过了，那么就需要重新获取版本号来进行修改



**CAS 算法：**

CAS 即 compare And Swap（比较和交换）

它需要 3 个值：内存值 V，线程保存的旧值 A，需要写入的新值 B

其实跟 版本号控制差不多，感觉版本号控制就是 CAS 的一种实现，不过别人分出来了就不管了

**过程：**

假设存在一个变量 x，当线程 1 获取这个 x 的值保存为 A ，然后经过一系列的处理，需要将这个 变量 x 该为 值 B

这时候不能直接写入内存，而是需要比较 内存中 变量 x 的值 V 与之前获取它的时候的值 A 是否一致，如果一致，表示没有被其他线程修改过（其实不一定，这是 ABA 问题），可以直接将 x 更新为 B，如果不一致，那么就表示被其他线程修改过了，那么通过自旋不断重试



**CAS 的缺点：**

- 存在 ABA 问题
- 在存在冲突的情况下会自旋重试，而自旋的时候是不会主动放弃 CPU 的，那么当存在多个线程冲突的时候，CPU 效率低得一批



> 什么是 ABA 问题？

比如 线程 1  和 线程 2 同时要修改某个变量 x，当然，这是并发的，有先后顺序的，线程1 先被 CPU 调用，将 x 的值从 A 变成了 B，然后这时插进来 线程 3，CPU 没去调用线程 2，而是调用了 线程 3，而线程 3 将 x 的值 重新修改为 A，这时候 CPU 调用线程 2，线程 2 发现 x 在内存中的值 V 跟自己保存的旧值一样都是 A，那么感觉没人修改过，那么直接将 自己的新值 C 写入内存中

但实际上，在 线程 2 修改之前，就已经存在两个线程对变量 x 进行了修改，只是最终改回了原来的值，让线程 2 无法感知到它的变化

这就是 ABA 问题，表示从 A 修改为了 B，再从 B 修改回 A，这个中间过程不被感知



举个生活例子：

桌上有一杯水，它是满的，杯子的主人不在，当 人类 A 路过时，实在渴得不得了了，过来把它喝光了，然后就把空杯子放下走了

然后过来一个人类 B，发现杯子空了，很不爽，就把自己随身携带的水给杯子满上，然后就走了

当杯子的主人来的时候，看见杯子是满的，那么他不会想到有人喝了它的水再将它满上了，所以他放心地喝了

当然，他在他不知情的情况下，喝下了别人炙热的口水



> 如何 解决 ABA 问题？

通过添加一个版本号，（这就更像版本号控制那个了），之后的比较就不再是比较什么数据的内存值和旧值了，而是比较版本号了

上面的例子中，线程 1 修改了变量 x，将版本号 +1，之后线程  2 发现版本号不对，自然就感知到了 x 被修改过了，那么自旋重新修改



> ABA 问题有什么危害？

我们这么看老来，线程 1 修改了 x 值 从 A 变成 B，线程 3 又将 x 值从 B 变成 A，对于线程 2 来说，是需要将 x 值从 A 变成 C 的，那么这个 x 值最终是要变成 C 的，好像也没什么多大问题啊

这么看来是的，但是有的时候，这个中间态就可能产生不一样的影响，然而没有具体的例子，，，啧啧，这个 ABA 问题难点就在于没有一个实际的业务场景上的问题，有点理想化了



## 6、ReentrantLock（CAS + AQS）

ReentrantLock 使用了 CAS，我们上面说了 CAS  是乐观锁的一种实现，但这不意味着 ReentrantLock 就是乐观锁

因为i我们具体要看 ReentrantLock 到底是哪个地方用到了 CAS，并非用到了 CAS 就是乐观锁



**ReentrantLock 是一把悲观锁 和 可重入锁**，**同时也是 公平锁 和 非公平锁 的 实现**



### 6.1、ReentrantLock 的实现

---



**ReentrantLock 是一个可重入的悲观锁**

**ReentrantLock 通过 CAS + AQS 队列来实现**（AQS 队列 叫做 同步队列）



ReentrantLock 的实现可以简单描述为：

- ReentrantLock  内部维护了一个 volatile 修饰的 int 型变量 state

- 当 state == 0 时，表示还没有任何线程占有锁**（注意，这里的锁不是一个具象化的事物，而是根据 state 来判断的，只要 state 为 0 就当作是没有线程获得锁）**

- 当 state != 0 时，表示已经有线程获得锁

- 某个线程 使用 CAS 尝试获得锁时，如果 state 为 0，那么可以获得锁，并将 state +1，将锁的拥有者线程设置为自己

- 其他线程来尝试获取锁的时候，发现 state 不为 0，那么就会进入 AQS 队列进行等待，处于 挂起状态，CPU 不会在它们身上浪费时间

根据执行流程我们就可以看出，ReentrantLock 是一把悲观锁，它会阻塞其他的线程，即它对某个共享资源加锁的时候，其他的线程无法去修改这个资源，而是需要阻塞等待获取锁，而它使用的 CAS 就是用来判断是否有线程获得锁而已

而我们最上面讲的 乐观锁的 CAS ，是多个线程可以获取 共享资源 ，并对共享资源进行修改，不过每次修改的只有一个会成功，因此会进行自旋



**ReentrantLock 是在获取锁的时候使用 CAS，会阻塞线程，线程会挂起，CPU 不会在它们身上浪费时间**

**而 乐观锁的 CAS 是在修改的时候发挥作用，线程会进行自旋，CPU 会它们身上直到它们调用成功**



### 6.2、公平锁 和 非公平锁、可重入锁

---



> 公平锁 和 非公平锁



公平锁是指多个线程同时获取一把锁，那么就是按照线程到达时间来分配锁的

非公平锁就是多个线程同时获取一把锁，在某个线程释放锁的时候，其他等待的线程没有获取锁，而是被中途插入的线程获取了锁



**synchronized 和 ReentrantLock 都是非公平锁，不过 ReentrantLock  可以设置为 公平锁**



> 可重入锁



一个线程 在没释放锁的时候可以多次获取同一把锁**

比如 线程 1 获取了锁，然后它调用的方法还需要这一把锁，那么这把锁可以同样给这个方法用，而无需再去竞争锁

这就是可重入锁



### 6.3、非公平锁 lock() 实现原理

---



我们前面说了，ReentrantLock 是一把公平锁和非公平锁，主要是体现在 lock() 和 unlock()



> 非公平锁 获取锁 代码



```java
final void lock() {
    
    if (compareAndSetState(0, 1)) //直接 CAS
        setExclusiveOwnerThread(Thread.currentThread());
    else
        //上面直接 CAS 失败
        acquire(1);
}

public final void acquire(int arg) {
    if (!tryAcquire(arg) &&
        //前面获取锁失败，这里将线程放入 AQS 队列
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}

final boolean tryAcquire(int acquires) {
    //获取当前线程
    final Thread current = Thread.currentThread();
    //获取state变量值
    int c = getState();
    if (c == 0) { //没有线程占用锁
        if (compareAndSetState(0, acquires)) {
            //占用锁成功,设置独占线程为当前线程
            setExclusiveOwnerThread(current);
            return true;
        }
    } else if (current == getExclusiveOwnerThread()) { //当前线程已经占用该锁
        int nextc = c + acquires;
        if (nextc < 0) // overflow
            throw new Error("Maximum lock count exceeded");
        // 更新state值为新的重入次数
        setState(nextc);
        return true;
    }
    //获取锁失败
    return false;
}
```



当 某个线程调用 lock() 尝试获取锁，会先直接 CAS 一次，失败了就调用`tryAcquire()` ，里面 获取 state 变量

如果 state == 0, 那么再次进行 CAS 一次，如果失败直接返回 false

如果 state != 0，那么判断占有锁的线程是否是当前请求的线程，如果是，那么 state +1，这就是可重入锁的原理



**我们可以发现：**

只要有线程尝试获取锁，那么直接进行 CAS 尝试获取锁

这就是非公平锁的体现，当线程 A 释放锁的时候，lock() 它没有去判断 AQS 队列中是否有线程等待，如果这时候中途插入的线程尝试获取锁调用 lock()，并且获取成功了，那么对于早在队列中等待的线程来说就不公平了，甚至如果高并发的情况下，可能出现饥渴现象



> 线程入队 AQS 代码



```java
/**
 * 初始化队列并且入队新节点
 */
private Node enq(final Node node) {
    //开始自旋
    for (;;) {
        Node t = tail;
        if (t == null) { // Must initialize
            // 如果tail为空,则新建一个head节点,并且tail指向head
            if (compareAndSetHead(new Node()))
                tail = head;
        } else {
            node.prev = t;
            // tail不为空,将新节点入队
            if (compareAndSetTail(t, node)) {
                t.next = node;
                return t;
            }
        }
    }
}
```



当线程 B 和 线程 C 都要入队时，由于是排在队尾，一次只能有一个线程入队成功，即每当一个线程入队成功， AQS 队尾元素就会更新入队成功的线程，所以需要进行 CAS + 自旋，直到所有线程入队成功

这里的 CAS 就是判断我们要入队的时候，队尾节点（内存值 V） 和 自己之前保存的队尾节点（旧值 A）是否一致，如果一致表示还没有被更新过，那么直接入队



### 6.4、非公平锁 unlock() 实现原理

---

```java
public void unlock() {
    sync.release(1);
}
  
public final boolean release(int arg) {
    if (tryRelease(arg)) {
        Node h = head;
        if (h != null && h.waitStatus != 0)
            unparkSuccessor(h);
        return true;
    }
    return false;
}

/**
 * 释放当前线程占用的锁
 * @param releases
 * @return 是否释放成功
 */
protected final boolean tryRelease(int releases) {
    // 计算释放后state值
    int c = getState() - releases;
    // 如果不是当前线程占用锁,那么抛出异常
    if (Thread.currentThread() != getExclusiveOwnerThread())
        throw new IllegalMonitorStateException();
    boolean free = false;
    if (c == 0) {
        // 锁被重入次数为0,表示释放成功
        free = true;
        // 清空独占线程
        setExclusiveOwnerThread(null);
    }
    // 更新state值
    setState(c);
    return free;
}
```



代码不难，当线程调用 unlock() 方法的时候，不会直接释放锁

由于 ReentrantLock 是一个可重入锁，因此当前线程的当前方法不一定是最后一个拥有锁的

当该线程的某个方法调用 unlock() 的时候，需要判断 state 减 1 后是否为 0

如果是，表示自己是最后一个拥有锁的，可以释放锁，同时将锁的拥有者线程设置为 null

如果不是，表示还有其他线程需要锁，所以不能释放锁



### 6.5、公平锁的 lock() 

---

其实大部分代码公平锁和非公平锁的实现都是一样的

只是在 lock() 方法上做了一点修改

非公平锁是因为在 lock() 方法内直接判断 state 是否为 0，而不去管 AQS 队列内等待的线程，导致贤臣可以插队出现不公平

而公平锁的 lock() 并不是直接根据 state 状态来判断的，而是先获取 state，如果 state 为 0，那么再判断 AQS 队列是否为空，如果为空，那么再尝试进行 CAS 获取锁，如果 AQS 队列不为空，那么当前线程是不会获得锁的



```java
final void lock() {
    acquire(1);
}

public final void acquire(int arg) {
    if (!tryAcquire(arg) &&
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}

protected final boolean tryAcquire(int acquires) {
    final Thread current = Thread.currentThread();
    int c = getState();
    if (c == 0) {
        if (!hasQueuedPredecessors() &&
            compareAndSetState(0, acquires)) {
            setExclusiveOwnerThread(current);
            return true;
        }
    }
    else if (current == getExclusiveOwnerThread()) {
        int nextc = c + acquires;
        if (nextc < 0)
            throw new Error("Maximum lock count exceeded");
        setState(nextc);
        return true;
    }
    return false;
}
```


# redis 特点



## 1、为什么使用 redis?

因为 redis 是基于内存实现的，单单在数据存储方面无论是查找还是别的，都比 mysql 数据库快，因为 mysql 数据库的数据存储在 磁盘中，每次都需要进行 I/O 操作，寻道时间 redis 就不知道能够执行多少条命令了，效率相差太多

并且它内部自己实现了很多简洁高效的数据结构，应用场景广泛



## 2、redis 快的原因

- 完全基于内存操作，不需要进行 磁盘 IO，因为 磁盘 IO 比 内存操作的时间要高出很大的数量级
- 单线程，避免了频繁的线程上下文切换和锁的竞争（比如 dict 不够用进行 rehash 的时候，无需加锁，因为不存在别的线程）
- 网络层 使用 epoll 模型
- 高效的数据结构 + 合理的编码格式，redis 内部自己实现的数据结构，简单而且效率高，根据数据的情况会进行转变



> #### redis 命令执行为何使用单线程？

[何种情况下 单线程 比 多线程更好？](https://www.cnblogs.com/caihuafeng/p/5438753.html)



```
注意：redis 所谓的单线程是指命令执行的时候，后台还是有其他线程在执行的
```



首先我们要明白多线程的使用意义，只有在 IO 操作的时候，CPU 会空闲，这样的话就需要让 CPU 去执行别的线程，这样 CPU 才不会浪费

如果任务都是 CPU 密集型（计算密集型）的，CPU 不会空闲，这样的话如果使用多线程这里执行一点，那里执行一点，由于存在进程/线程上下文切换，这就导致比 单线程顺序执行还慢了（线程上下文切换时间足够 CPU 执行 几万条指令了）

同时，多线程的情况下还需要防止共享资源的数据错乱，所以又需要加锁，又会产生锁的争夺



需要注意的是， redis 的单线程不包括后台的一些操作，比如 AOF 重写、生成 RDB 之类的，对于这些操作是会重新开一个子进程的

**redis 的单线程 是 使用一个线程处理三方面的数据：从 socket 读取数据 + 处理用户请求 + 将数据写回 socket**

对于 用户请求处理，由于完全是 CPU 密集型的，不涉及任何的 IO 操作，所以不需要使用多线程

但是对于 socket 读取数据 和 数据写回 socket，虽然使用的是 IO 多路复用模型，但是 读取和写回 都涉及到 用户态 和 内核态 的数据拷贝，由于是同一个线程，一旦某个 socket 需要读取或者写回大数据，那么就会影响其他 socket 的 IO 操作，同时也会影响到用户命令的执行

因此，**在 redis 6.0 就 另开一组多线程 来处理 socket 读写了，但是 处理用户命令 仍然是单线程**



> #### redis 6.0 的多线程处理模式

[redis 6.0 的 多线程模型](https://blog.51cto.com/14751386/2484683)

[redis 6.0 多线程 源码解读](https://keys961.github.io/2020/04/16/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-Redis-6.0-%E5%A4%9A%E7%BA%BF%E7%A8%8BIO/)



redis 6.0 以前使用的 IO 多路复用模式 是 Reactor 单线程模式，即 网络 IO 和 业务处理都是一个线程

redis 6.0 变成了多线程 IO 单业务处理 模式

流程如下：

- 使用一个主线程来监听所有的 socket 读写、连接，比如此时处理 可读 socket，将获取到的 可读 socket 放入到 读等待队列 
- 当主线程接收完所有的读事件，那么 轮询将所有等待队列中所有的 socket 按照顺序分发给 IO 线程，包括主线程自己
- 主线程 **while 自旋等待**获取 所有的 IO 线程 完成所有 socket 的数据读取
- 主线程 使用另外的一个单线程 指向 socket 获取的这些命令，并接收 Redis 处理完命令返回的数据
- 主线程 **while 自旋等待** 所有的 IO 线程将数据写回 socket 完成
- 清空读等待队列

该模式有如下的特点：

- 所有的 IO 线程同一时间只能处理 socket 读 或者 socket 写，不能同时处理读写
- 所有的 IO 线程只负责 socket 数据的读写，不负责命令的执行

```C++
// 每个thread有可能需要负责多个client
listRewind(io_threads_list[id],&li);
while((ln = listNext(&li))) {
    client *c = listNodeValue(ln);
    if (io_threads_op == IO_THREADS_OP_WRITE) {
        // 当前全局处于写事件时，向输出缓冲区写入响应内容
        writeToClient(c,0);
    } else if (io_threads_op == IO_THREADS_OP_READ) {
        // 当前全局处于读事件时，从输入缓冲区读取请求内容
        readQueryFromClient(c->conn);
    } else {
        serverPanic("io_threads_op value is unknown");
    }
}
```



## 3、Redis 使用场景

- **分布式 session**
- **缓存**
- 排行榜
- **分布式锁**
- 数据库分布式 id 生成器（使用 incr and get 命令，因为单线程，不存在线程安全问题）
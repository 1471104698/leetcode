一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。

 

示例 1：

输入：nums = [4,1,4,6]
输出：[1,6] 或 [6,1]
示例 2：

输入：nums = [1,2,10,4,1,4,3,3]
输出：[2,10] 或 [10,2]
 

限制：

2 <= nums <= 10000

class Solution {
    public int[] singleNumbers(int[] nums) {
        /*
        如果不要求空间复杂度 O(1)，那么可以使用 set
        如果要求空间复杂度 O(1)，那么只能使用指针

        两个相同的值进行 ^ （二进制加法）结果肯定为 0 
        比如  0110 ^ 0110 = 0000

        数组所有元素的 异或值 结果 res 是 不重复的两个值的异或值

        而两个数的异或结果，二进制为 1 的位置就是两个数二进制不一样的位置
        比如 3（0011）^ 5（0101）= 0110， 第 2、3 位为 1 ，表示 3 和 5 第 2、3 位二进制不同

        因此，我们可以通过不同的二进制位置还进行分组划分
        通过获取 res 最后一个 1 的位置，然后根据这个位置进行划分（res &= -res 可以获取最后一个 1 的位置）
        nums = {1,1,3,5,2,2}
        a[0] =1  0x0001  第一组
        a[1] =1  0x0001  第一组
        a[2] =3  0x0011  第二组
        a[3] =5  0x0101  第一组
        a[4] =2  0x0010  第二组
        a[5] =2  0x0010  第二组
        根据 res 最后一个 1 的位置，我们可以根据两种不同的情况划分出两组
        {2,2,3} 和 {1,1,5}， 2^2^3 = 3， 1^1^5 = 5，结果就是 3 和 5
        */

        int res = 0;
        for(int num : nums){
            res ^= num;
        }

        //得到最后一个 1 的位置，比如 1 & -1 = 0000 .... 0001 ^ 1111 .... 1111 = 0000 .... 0001 得到最后一个 1 的位置
        res &= -res;

        int[] arr = new int[2];
        //根据 最后一个 1 的位置 是 0 还是 1 来进行分组
        for(int num : nums){
            if((res & num) == 0){
                arr[0] ^= num;
            }else{
                arr[1] ^= num;
            }
        }
        return arr;
    }
}
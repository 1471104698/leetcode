## **[32. 最长有效括号](https://leetcode-cn.com/problems/longest-valid-parentheses/)**

```java
给定一个只包含 '(' 和 ')' 的字符串，找出最长的包含有效括号的子串的长度。
```



## **示例 1:**

```java
输入: "(()"
输出: 2
解释: 最长有效括号子串为 "()"
```





## **示例 2:**

```java
输入: ")()())"
输出: 4
解释: 最长有效括号子串为 "()()"
```



## 实现思路

```java
        普通的使用栈不能的了，暴力 O(n^2) 也是不行的了

        使用动态规划：
        dp[i] 表示以 i 结尾的最长的有效括号长度

        关于 状态转移方程的推导，有以下几种情况：
        1、当 s[i] == '(' ，那么以 i 结尾的有效括号长度为 0，即 dp[i] = 0
        2、当 s[i] == ')' ，那么我们需要根据 s[i - 1] 的情况来判断
            2.1、当 s[i - 1] == '(' ，那么 s[i] 和 s[i - 1] 能够凑成一对，那么是否能够更长就看是否能够跟 dp[i - 2] 的情况了
                 dp[i] = dp[i - 2] + 2
            2.2、当 s[i - 1] == ')' ，那么 s[i] 只能是有效括号的外层
                比如 ( ()() )
                           ↑
                          s[i]
                因此，我们需要判断 s[i - 1] 是否能跟前面的组成有效括号，即判断 dp[i - 1] 是否大于 0
                    如果 dp[i - 1] == 0，那么意味着 s[i - 1] 是无效括号，那么 s[i] 内部的括号总不能是无效括号吧，因此 dp[i] = 0
                    如果 dp[i - 1] > 0，那么表示内部是有效括号，但内部有效是前提，重点是 s[i] 左边也必须存在 '(' 能够跟它匹配
                        而左边这个 '(' 存在的位置在哪里呢？
                        ( ()() )
                        ↑      ↑
                             s[i]
                        即为左边的箭头位置，同时为 内部有效括号的左边一个位置，即 left = i - dp[i - 1] - 1 位置
                        如果匹配，dp[i] = dp[i - 1] + 2，同时还需要再判断 dp[left - 1] 是否能够组成有效括号
                                即最终 dp[i] = dp[i - 1] + 2 + dp[left - 1];
                        由于可能存在 
                        ) ()() ) 
                               ↑
                              s[i]
                        这种情况，即左边与 s[i] 不匹配，那么即使内部是有效括号，dp[i] 同样为 0
```



## 实现代码

```java
class Solution {
    public int longestValidParentheses(String s) {
        
        int len = s.length();
        if(len < 2){
            return 0;
        }
        int[] dp = new int[len];
        int maxLen = 0;
        char[] ss = s.toCharArray();

        //第一个字符有效长度肯定为 0
        for(int i = 1; i < len; i++){
            if(ss[i] == ')'){
                if(ss[i - 1] == '('){
                    dp[i] = 2;
                    if(i >= 2){
                        dp[i] += dp[i - 2];
                    }
                }else{
                    if(dp[i - 1] != 0){
                        int left = i - dp[i - 1] - 1;
                        if(left >= 0 && ss[left] == '('){
                            dp[i] = dp[i - 1] + 2;
                            if(left > 0){
                                dp[i] += dp[left - 1];
                            }
                        }
                    }
                }
                maxLen = Math.max(maxLen, dp[i]);
            }
        }
        return maxLen;
    }
}
```


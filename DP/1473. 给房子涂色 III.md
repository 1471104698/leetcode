## **[1473. 给房子涂色 III](https://leetcode-cn.com/problems/paint-house-iii/)**

```java
在一个小城市里，有 m 个房子排成一排，你需要给每个房子涂上 n 种颜色之一（颜色编号为 1 到 n ）。有的房子去年夏天已经涂过颜色了，所以这些房子不需要被重新涂色。

我们将连续相同颜色尽可能多的房子称为一个街区。（比方说 houses = [1,2,2,3,3,2,1,1] ，它包含 5 个街区  [{1}, {2,2}, {3,3}, {2}, {1,1}] 。）

给你一个数组 houses ，一个 m * n 的矩阵 cost 和一个整数 target ，其中：

houses[i]：是第 i 个房子的颜色，0 表示这个房子还没有被涂色。
cost[i][j]：是将第 i 个房子涂成颜色 j+1 的花费。
请你返回房子涂色方案的最小总花费，使得每个房子都被涂色后，恰好组成 target 个街区。//如果没有可用的涂色方案，请返回 -1 。
```



## **示例 1：**

```java
输入：houses = [0,0,0,0,0], cost = [[1,10],[10,1],[10,1],[1,10],[5,1]], m = 5, n = 2, target = 3
输出：9
解释：房子涂色方案为 [1,2,2,1,1]
此方案包含 target = 3 个街区，分别是 [{1}, {2,2}, {1,1}]。
涂色的总花费为 (1 + 1 + 1 + 1 + 5) = 9。
```



## **示例 2：**

```java
输入：houses = [0,2,1,2,0], cost = [[1,10],[10,1],[10,1],[1,10],[5,1]], m = 5, n = 2, target = 3
输出：11
解释：有的房子已经被涂色了，在此基础上涂色方案为 [2,2,1,2,2]
此方案包含 target = 3 个街区，分别是 [{2,2}, {1}, {2,2}]。
给第一个和最后一个房子涂色的花费为 (10 + 1) = 11。
```



## **示例 4：**

```java
输入：houses = [3,1,2,3], cost = [[1,1,1],[1,1,1],[1,1,1],[1,1,1]], m = 4, n = 3, target = 3
输出：-1
解释：房子已经被涂色并组成了 4 个街区，分别是 [{3},{1},{2},{3}] ，无法形成 target = 3 个街区。
```





## **实现思路**

```java
        dp
        推理出状态转移方程，我们需要知道存在多少个状态，共有 3 个，即 房子所在索引位置，房子涂成的颜色，形成多少个街区
        dp[i][j][j] 表示第 i 个房子涂成 第 j 种颜色，共分成 k 个房区

        一、houses[i] != 0，表示 房子 i 的颜色状态已经确定了，如果总共形成 k 个街区，那么有以下两种选择
                1、上一个房子跟当前房子颜色相同 dp[i][j][k] = dp[i - 1][j][k]
                2、上一个房子跟当前房子颜色不同 dp[i][j][k] = Math.min(dp[i - 1][jj][k - 1]) (注：j1 ∈ [1, n] && jj != j)
        二、houses[i] == 0，表示 房子 i 的颜色没有确定，需要进行涂色，如果总共形成 k 个街区，那么有：
                选择 j ∈ [1, n] 中任意一种颜色，每一种颜色 都 存在 跟上一个房子相同或不相同的情况
                比如 房子 i 选择 j 号颜色，那么上一个房子可以选择 j 号颜色 或 除 j 号外的颜色
        
        初值设置：
        
        1、如果 [0, i] 个房子无法分成 k 个街区，即 没有可用的涂色方案，那么 dp 值应该是怎样的？
        比如 houses = [3,1,2,3], target = 2，这样的话 ,dp[4][j][2] 应该为多少？
        我们默认初值设置为 MAX, 这样的话,如果无法分成对应的街区数，结果仍是 MAX，表示无法满足条件
        注意，不能设置为 Integer.MAX_VALUE, 否则后面加上 cost 的时候会溢出
        2、我们提前处理好第一个房子的费用情况，如果不处理，那么后续只存在一个 MAX 和 cost[i][j] 进行相加
        
```





## **实现代码**

```java
class Solution {
    public int minCost(int[] houses, int[][] cost, int m, int n, int target) {

        final int MAX = 100000000;
        int[][][] dp = new int[m + 1][n + 1][target + 1];

        //初值设置 1
        for(int i = 0; i <= m; i++){
            for(int j = 0; j <= n; j++){
                Arrays.fill(dp[i][j], MAX);
            }
        }
        //初值设置 2
        //如果第一个房子已涂色，那么费用为 0
        if(houses[0] != 0){
            dp[1][houses[0]][1] = 0;
        }else{
            //如果第一个房子未涂色，那么处理好涂上某种颜色的费用
            for(int i = 0; i < n; i++){
                dp[1][i + 1][1] = cost[0][i];
            }
        }

        //街区数
        for(int k = 1; k <= target; k++){
            //房子编号
            for(int i = 2; i <= m; i++){

                int color = houses[i - 1];
                if(color != 0){
                    //跟上一个房子相同
                    dp[i][color][k] = dp[i - 1][color][k];
                    //跟上一个房子不同
                    for(int j = 1; j <= n; j++){
                        if(j != color){
                            dp[i][color][k] = Math.min(dp[i][color][k], dp[i - 1][j][k - 1]);
                        }
                    }
                }else{
                    //当前房子选的颜色
                    for(int j = 1; j <= n; j++){
                        dp[i][j][k] = Integer.MAX_VALUE;
                        //上一个房子选的颜色
                        for(int jj = 1; jj <= n; jj++){
                            int c = cost[i - 1][j - 1];
                            //当前房子的颜色跟上一个房子颜色相同
                            if(j == jj){
                                dp[i][j][k] = Math.min(dp[i][j][k], dp[i - 1][j][k] + c);
                            }else{
                                dp[i][j][k] = Math.min(dp[i][j][k], dp[i - 1][jj][k - 1] + c);
                            }
                        }
                    }
                }
            }
        }
        int min = MAX;
        for(int i = 1; i <= n; i++){
            min = Math.min(min, dp[m][i][target]);
        }

        return min == MAX ? -1 : min;
    }
}
```


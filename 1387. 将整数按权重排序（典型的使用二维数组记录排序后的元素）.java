我们将整数 x 的 权重 定义为按照下述规则将 x 变成 1 所需要的步数：

如果 x 是偶数，那么 x = x / 2
如果 x 是奇数，那么 x = 3 * x + 1
比方说，x=3 的权重为 7 。因为 3 需要 7 步变成 1 （3 --> 10 --> 5 --> 16 --> 8 --> 4 --> 2 --> 1）。

给你三个整数 lo， hi 和 k 。你的任务是将区间 [lo, hi] 之间的整数按照它们的权重 升序排序 ，如果大于等于 2 个整数有 相同 的权重，那么按照数字自身的数值 升序排序 。

请你返回区间 [lo, hi] 之间的整数按权重排序后的第 k 个数。

注意，题目保证对于任意整数 x （lo <= x <= hi） ，它变成 1 所需要的步数是一个 32 位有符号整数。

 

示例 1：

输入：lo = 12, hi = 15, k = 2
输出：13
解释：12 的权重为 9（12 --> 6 --> 3 --> 10 --> 5 --> 16 --> 8 --> 4 --> 2 --> 1）
13 的权重为 9
14 的权重为 17
15 的权重为 17
区间内的数按权重排序以后的结果为 [12,13,14,15] 。对于 k = 2 ，答案是第二个整数也就是 13 。
注意，12 和 13 有相同的权重，所以我们按照它们本身升序排序。14 和 15 同理。

class Solution {
    public int getKth(int lo, int hi, int k) {
        /*
        我们计算出每个数的权重，按照顺序存放进行数组 weight 中
        比如 lo = 7, hi = 11
        则 weight = {16, 3, 19, 6, 14}

        因为我们需要进行排序，排序的话会导致顺序混乱，那么我们就需要记录每个数对应的权重位置
        那么我们开二维数组， int[][] weight = new int[len][2];
        weight[i][0] 记录权重
        weight[i][1] 记录对应的数
        
        那么我们就可以进行排序，当权重一样，按照元素数值升序排序，当权重不一样，按照权重排序
        */
        int len = hi - lo + 1;
        int[][] weight = new int[len][2];
        for(int i = 0; i < len; lo++, i++){
            weight[i][0] = helper(lo);
            weight[i][1] = lo;
        }
        Arrays.sort(weight, (a, b) -> a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]);
        return weight[k - 1][1];
    }
    private int helper(int num){
        int step = 0;
        while(num != 1){
            if((num & 1) == 0){
                num >>>= 1;
            }else{
                num = num * 3 + 1;
            }
            step++;
        }
        return step;
    }
}
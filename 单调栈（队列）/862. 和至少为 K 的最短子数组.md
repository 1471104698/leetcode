# [862. 和至少为 K 的最短子数组](https://leetcode-cn.com/problems/shortest-subarray-with-sum-at-least-k/)

```java
返回 A 的最短的非空连续子数组的长度，该子数组的和至少为 K 。

如果没有和至少为 K 的非空子数组，返回 -1 。
```



## **示例 1：**

```java
输入：A = [1], K = 1
输出：1
```



## **示例 2：**

```java
输入：A = [1,2], K = 4
输出：-1
```



## **示例 3：**

```java
输入：A = [2,-1,2], K = 3
输出：3
```



## **示例 4：**

```java
输入：A = [50,50,100,1,-100,50,200], K = 250
输出：2
```



## 方法①、暴力前缀和

### 实现思路

```java
关于子数组求和，直接使用前缀和 O(n^2)
不过数据量过大，会超时

//一般可以使用滑窗 和 二分，不过这道题由于存在 负数，因此不满足单调性，不能使用，具体分析看方法②
```



### 实现代码

```java
无
```





## 方法②、单调队列 + 前置和

### 实现思路

```java
1、涉及子数组和的一定是前缀和，但如果单单使用前缀和暴力求解，那么 O(n^2) 必定超时
2、二分查找，因为存在负数，那么序列不满足单调性，跟普通的无负数子数组和不同，序列不一定不会随着元素的增加而增加
     这使得不能对长度进行二分，因为长度为 L 的子数组满足，这也不意味着长度为 L + 1 的子数组也满足，因为新添加的元素可能是 负数 让子数组和减小导致不满足要求
     因此二分查找不满足要求
3、滑动窗口，同样由于存在负数，序列不满足单调性
	[50,50,100,1,-100,50,200] K = 250
    我们只能处理 sum >= K 的情况，这样的话，那么就是 整个数组总和 才满足 sum > K，然后进行缩减，发现缩减到 [1,-100,50,200] 才 sum < K，那么最短长度为 5
    实际上最短长度为 [50, 200], 我们无法在滑窗中得知这种情况并进行缩减
4、单调递增队列 + 前缀和
	arr：[1,4,-2,4]
    前缀和：1,5,3,7
    queue = {0，1，3，7} 最左边是队头，最右边是队尾，队列内默认队头元素为 前缀和 0
    	由于 7 到 5 的差值比 7 到 3 的差值小，并且 7 到 5 的距离比 7 到 3 的距离大，因此 5 可以被 3 顶替舍弃
    	因为差值越大，表示越能够用更小的长度 >= K,而且 7 到 3 的距离还小了
    	从元素上看，我们舍去了 5 就舍弃了 -2 这个元素

	我们根据 最大宽度坡 这道题的思想来理解这个单调递增队列，但是有点不太一样
	
	因为这是个单调递增队列，因此队头是排在最前面的索引，即最先入队的，并且前缀和是最小的
	//①、
	我们每次找都从队头找满足 sum[i] - sum[peek()] >= K 的值，如果满足，那么弹栈计算长度
	这里能够弹栈的理由是 如果 peek() 对于 i 满足条件的话，因为我们是按 i, i + 1,i + 2 的索引顺序进行遍历的
	因此如果 i 和 peek() 满足，那么长度肯定比后面的 i + 1, i + 2 等 跟 peek() 满足的情况下要短
	比如 
	K = 2
    sum[i] - sum[peek()] = 3,
	sum[i + 1] - sum[peek()] = 2
    i 和 i + 1 跟 peek() 都满足 >= K 的情况，但是 i - peek() 的长度比 i + 1 - peek() 的长度要短，因此我们可以忽略 i + 1 和 peek() 的组合情况
    //②、
    我们维护队尾的单调递增，但是如果后面遇到小值 要将 队尾的大值弹出
    	比如上述的前缀和 5 和 3
    	因为遇到 3 的时候，3 的索引，比 队尾的 5 的索引还大，索引越大越靠近后面我们要进行比较的前缀和 7，那么长度就越短
    	并且如果前缀和 3 还比 队尾 5 小，那么就越能跟后面的 7 组成更大的子数组和，即能够用更短的长度接近 K
    如果遇到的是大于队尾的值，比如 存在前缀和序列 [4,5,7] K = 2
        遇到前缀和 5 的时候， 5 比 队尾 4 大，那么不能将 4 弹栈，但是 5 也需要入队
        因为虽然 5 大，但是可能跟后面的 7 组成 >= K 的情况，长度为 2
        如果 5 没有入队，那么就忽略了 5 跟 7 的组合，导致 4 跟 7 组合，长度为 3
```





### 实现代码

```java
class Solution {
    public int shortestSubarray(int[] A, int K) {

        int len = A.length;

        final int MAX = 100000000;
        int[] sum = new int[len + 1];
        int mlen = MAX;

        Deque<Integer> queue = new ArrayDeque<>();
        queue.add(0);
        for(int i = 0; i < len; i++){
            sum[i + 1] = sum[i] + A[i];
			
            //队头获取满足条件的长度
            while(!queue.isEmpty() && sum[i + 1] - sum[queue.peek()] >= K){
                mlen = Math.min(mlen, i - queue.poll() + 1);
            }
            //队尾维护单调递增性
            while(!queue.isEmpty() && sum[i + 1] < sum[queue.peekLast()]){
                queue.pollLast();
            }
            //
            queue.add(i + 1);
        }
        return mlen == MAX ? -1 : mlen;
    }
}
```


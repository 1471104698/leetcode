## **[887. 鸡蛋掉落](https://leetcode-cn.com/problems/super-egg-drop/)**

```java
你将获得 K 个鸡蛋，并可以使用一栋从 1 到 N  共有 N 层楼的建筑。

每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。

你知道存在楼层 F ，满足 0 <= F <= N 任何从高于 F 的楼层落下的鸡蛋都会碎，从 F 楼层或比它低的楼层落下的鸡蛋都不会破。

每次移动，你可以取一个鸡蛋（如果你有完整的鸡蛋）并把它从任一楼层 X 扔下（满足 1 <= X <= N）。

你的目标是确切地知道 F 的值是多少。

无论 F 的初始值如何，你确定 F 的值的最小移动次数是多少？

 

提示：
1 <= K <= 100
1 <= N <= 10000
```



## **示例 1：**

```java
输入：K = 1, N = 2
输出：2
解释：
鸡蛋从 1 楼掉落。如果它碎了，我们肯定知道 F = 0 。
否则，鸡蛋从 2 楼掉落。如果它碎了，我们肯定知道 F = 1 。
如果它没碎，那么我们肯定知道 F = 2 。
因此，在最坏的情况下我们需要移动 2 次以确定 F 是多少。
```



## **示例 2：**

```java
输入：K = 2, N = 6
输出：3
```



## **示例 3：**

```java
输入：K = 3, N = 14
输出：4
```





## **方法①、递归**

### **实现思路**

```java
            要求的是安全楼层，那么如果鸡蛋在 F 楼碎了，但在 F - 1 楼没碎，那么安全楼层就是 F - 1
            并且要求在所有可能发生的条件下找出最少的扔的次数，即所有的最坏情况中的最好情况

            比如 N = 100，鸡蛋有很多个，
            第一个鸡蛋在 50 楼扔，会存在对应的最坏的情况
            第一个鸡蛋在 10 楼扔，会存在对应的最坏的情况
            第一个鸡蛋在 x 楼扔，会存在对应的最坏的情况
            我们就是要求这所有的最坏情况中最好的情况，即扔的次数最少的

            如果 N == 1，那么无论有多少个鸡蛋，我们都只需要扔一次
            如果 K == 1，只有一个鸡蛋，那么我们必须保证在鸡蛋不碎的情况下去尝试所有的楼层，那么怎么做？
                我们只能从 1 楼开始扔，如果 1 楼碎了，那么安全楼层为 0，如果没碎，那么到 2 楼扔，再到 3 楼扔、... 、N 楼扔
                最坏的情况需要扔 N 次

            递归：我们从 F 楼扔，然后判断 碎 和 没碎 的递归情况
            碎：superEggDrop(K - 1, F - 1) + 1
            没碎：superEggDrop(K, N - F) + 1
```



### **实现代码**

```java
class Solution {
    public int superEggDrop(int K, int N) {
        if(K == 1){
            return N;
        }
        if(N == 1){
            return 1;
        }

        int maxCount = N;
        for(int F = 1; F <= N; F++){
            maxCount = Math.min(maxCount, Math.max(superEggDrop(K - 1, F - 1), superEggDrop(K, N - F)) + 1);
        }
        return maxCount;
    }
}
```





## **方法②、动规**

### **实现思路**

```java
思路跟 递归一样
状态转移方程：
	dp[i][j] 表示 有 i 个鸡蛋的情况下检测 j 层楼 最坏情况下，扔鸡蛋最少的次数
	在有 j 层楼的情况下，任选一层 k 扔鸡蛋，那么存在 碎 和 不碎 两种情况，取得其中最坏的情况
	dp[i][j] = Math.max(dp[i][j], Math.max(dp[i - 1][k - 1], dp[i][j - k]) + 1);
```





### **实现代码**

```java
class Solution {
    public int superEggDrop(int K, int N) {

        int[][] dp = new int[K + 1][N + 1];
        //K 个鸡蛋 1 层楼
        for(int i = 1; i <= K; i++){
            dp[i][1] = 1;
        }
        //1 个鸡蛋 N 层楼
        for(int i = 1; i <= N; i++){
            dp[1][i] = i;
        }
        //鸡蛋
        for(int i = 2; i <= K; i++){
            //楼层
            for(int j = 1; j <= N; j++){
                dp[i][j] = j;
                //从 j 层楼中任选一层楼 F 扔下
                for(int k = 1; k <= j; k++){
                    dp[i][j] = Math.min(dp[i][j], Math.max(dp[i - 1][k - 1], dp[i][j - k]) + 1);
                }
            }
        }
        return dp[K][N];
    }
}
```


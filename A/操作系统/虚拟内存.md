# 虚拟内存

---



## 1、虚拟内存的诞生

如果你是电子相关专业的，肯定在大学里捣鼓过单片机。

单片机是没有操作系统的，所以每次写完代码，都需要借助工具把程序烧录进去，这样程序才能跑起来。

另外，**单片机的 CPU 是直接操作内存的「物理地址」**。

![img](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfVYxicDjAjl4nMxlmyJk7rksAhSTGCc6eqWEmicic648NWnOpxqh4JQPPIpDXicyPFftrz137Zsf9SOg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

**由于单片机是直接操作物理地址的，因此如果同时运行两个相同的单片机程序，那么就是两个程序在操作相同的一块物理地址**

如果第一个程序在 2000 的位置写入一个新的值，将会擦掉第二个程序存放在相同位置上的所有内容，所以同时运行两个程序是根本行不通的，这两个程序会立刻崩溃。



> 操作系统如何避免类似问题？

上述的问题是因为两个程序都直接操作 物理地址

操作系统为 每个进程 都分配一套 虚拟地址空间，每个进程能访问的就是这个虚拟地址，而不能直接访问物理地址

各个虚拟地址映射到不同的物理地址

因此，某两个进程的虚拟地址即使是一样的，但是映射到的物理地址也是不一样的



操作系统引入了 虚拟内存，进程持有的虚拟地址会通过 **CPU 中存储的 内存管理单元（MMU）** 来 映射成 物理地址

![img](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfVYxicDjAjl4nMxlmyJk7rkpVTcOZj4JJSyYlSMyiaC66pP2q1QiafglrtO0tmZHCkBB0RvCsfVOTIA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



> 操作系统是怎么管理 虚拟地址 和 物理地址之间的映射 的呢？即 MMU 的实现方式

主要有两种方式：**分段机制 和 分页机制**，最先提出的是 分段机制



## 2、分段机制

**它是将程序分为四个部分，分别是 堆、栈、数据、代码，每个部分都用单独的内存空间存储，即分段**



**MMU 中存储段表，而段表是 虚拟地址中 各个段 与 物理地址的映射关系**



段基地址就是在地址空间中的起始位置，然后段界限就是属于这部分的空间大小

比如 段基地址为 1000，段界限为 1000

那么我们可以得到该段在物理地址中的空间地址为  [1000 - 2000]

![img](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfVYxicDjAjl4nMxlmyJk7rk87ABj8vKWeQANrKVHpm7xNZRTbgFPOicpy74mD65ia3rGgMaIo6G1ntQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)





> 内存分段的不足之处

我们需要知道，虽然进程采用分段的机制，将 4 个段分散在不同的内存空间，但是实际上它们还是一个整体，只当删除进程的时候才会一起消失

- 会产生内存碎片（当某个进程关闭的时候，对应的空间会释放，于是就产生了内存碎片）
- 内存交换效率低（由于产生了很多内存碎片，于是就需要进行 swap）
- 内存利用率低（上面说了，虽然分段，但仍然是一个整体，这个程序的部分内存可能不是很常用，但仍然占着内存）



> 内存碎片的产生

我们来看看这样一个例子。假设有 1G 的物理内存，用户执行了多个程序，其中：

- 游戏占用了 512MB 内存
- 浏览器占用了 128MB 内存
- 音乐占用了 256 MB 内存。

这个时候，如果我们关闭了浏览器，则空闲内存还有 1024 - 512 - 256 = 256MB。

如果这个 256MB 不是连续的，被分成了两段 128 MB 内存，这就会导致没有空间再打开一个 200MB 的程序。



![img](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfVYxicDjAjl4nMxlmyJk7rk0bmZo1YuxhYHTQN7uokA8dsGX1cJAyApOdHxxwjqOjjQIxHRaFB6Xg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



**解决外部内存碎片的问题就是内存交换。**

可以把音乐程序占用的那 256MB 内存写到硬盘上，然后再从硬盘上读回来到内存里。不过再读回的时候，我们不能装载回原来的位置，而是紧紧跟着那已经被占用了的 512MB 内存后面。这样就能空缺出连续的 256MB 空间，于是新的 200MB 程序就可以装载进来。

这个内存交换空间，在 Linux 系统里，也就是我们常看到的 Swap 空间，这块空间是从硬盘划分出来的，用于内存与硬盘的空间交换。

**需要注意的是：内存交换只能是把整个进程 堆栈、数据、代码 这 四个段都拿出来，存储到硬盘里，然后再读取到内存中**



> 内存交换效率低

对于多进程的系统来说，用分段的方式，内存碎片是很容易产生的，产生了内存碎片，那不得不重新 `Swap` 内存区域，这个过程会产生性能瓶颈。

因为硬盘的访问速度要比内存慢太多了，每一次内存交换，我们都需要把一大段连续的内存数据写到硬盘上。

所以，**如果内存交换的时候，交换的是一个占内存空间很大的程序，这样整个机器都会显得卡顿。**





## 3、分页机制



分段会产生很多内存碎片 和 内存交换效率低的问题

内存交换的原因也是因为内存碎片多



内存分页 是将虚拟内存和物理内存划分为一个空间连续并且大小相等的内存空间，称为 页，在 Linux 下，每 页 4kb

虚拟地址 和 物理地址通过 页表来进行映射，跟上面的段表其实差不多

![img](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfVYxicDjAjl4nMxlmyJk7rkZoTKofqkOibHicWGJPwsCjZGRpG077zmMMnRibkVqcVocZz1PxeIuLLMg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



当进程访问的页在页表中查不到时，就会产生一个缺页异常，然后去读取对应的页



> 分页怎么解决内存碎片问题？

因为每次写入和释放都是以页的大小，那么所有的空闲内存空间都一个一个的页，不会存在比页大和比页小的内存空间

而当进程需要分配内存空间的时候，可以将任意位置的页分配给它，释放也是按也空间，自然不会存在内存碎片

当进程需要的内存空间不够时，会将其他正在运行的进程 【最近不被使用】 的内存页面给换掉，暂时写在磁盘上（就是 Linux 中的 swap 空间），一旦需要的时候，再重新读取

跟分段机制不同的是，分段机制一旦需要内存交换，那么就是整个进程 的读取和写入，而分页机制每次只需要一个或几个页面而已



## 4、Linux 的内存管理

Linux 主要使用的是 页式内存管理，但是不可避免的使用了段机制



主要涉及三个地址：逻辑地址、（线性地址）虚拟地址、物理地址

![img](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfVYxicDjAjl4nMxlmyJk7rkScLhBl6b8h7zMdGJQ30uviaKeonZ3gABkmWghgnlibJw79jib3IOKiaKSA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



**Linux 系统中的每个段都是从 0 地址开始的整个 4GB 虚拟空间（32 位环境下），也就是所有的段的起始地址都是一样的。这意味着，Linux 系统中的代码，包括操作系统本身的代码和应用程序代码，所面对的地址空间都是线性地址空间（虚拟地址），这种做法相当于屏蔽了处理器中的逻辑地址概念，段只被用于访问控制和内存保护。**



## 5、虚拟内存的总结

> 虚拟内存 和 swap 分区的关系

首先，我们需要知道，虚拟内存是磁盘空间

**在 Linux 中，swap 区就是 windows 的 虚拟内存，用于内存交换的**

**虚拟内存是将内存暂时不需要的数据存放到硬盘中**，**对于 Linux ，就是将这些数据存储到 swap 分区中**

**当然，因为是硬盘，所以读写速度肯定是比在物理内存中慢的，所以应该避免大数据的内存交换，比如上面的分段机制，就是因为存在大数据的内存交换，导致效率低下**



> 虚拟内存 和 虚拟地址的关系

虚拟内存是硬盘空间， 是为了方便大程序的运行，弥补物理内存小的缺点，用来必要时候顶替物理内存的

虚拟地址是每个进程独有的，虽然是独有的，但是每个进程的虚拟地址是一样的，但是它们映射的物理地址是不一样的，为了方便程序员管理地址，所以才设置为一样，**这是为了方便程序员管理和使用地址，所以保持每个程序的虚拟地址空间是一样的，这样就需要虚拟内存，虚拟地址就是为了向下屏蔽地址的分布的差异化，向上统一地址的使用**



> 虚拟内存的大致作用

- 它让程序感觉自己有拥有连续的可用的内存空间，实际上内部是分割成多个物理碎片，但是因为程序加载进内存，并不是全部都加载的，而是将需要的部分才加载进去，而当需要另外一部分时，才从硬盘中读取，然后替换掉内存中暂且不需要的内存，这样的话，无论多大的程序都能运行，因此每次都只需要运行需要的部分即可，不需要的就放到内存
- 程序不直接操作物理地址，避免数据混乱导致操作，相当于隔离
- 方便动态链接，多个进程共享内存（比如进程间通信中的内存共享）



## 6、虚拟内存 和 缺页异常 的关系



虚拟内存是将内存暂时不需要的数据存放到硬盘中，因为放到了磁盘（虚拟内存）中

比如 程序 A 的数据段 a 不需要了，而 程序 B 的数据段 b 需要物理内存，所以会将程序 A 的数据段 a 从内存中拿出来，放到 虚拟内存 （swap 分区）中，然后断开程序 A 的数据段 a 的虚拟地址 和 它占用的物理地址的映射关系，而空出来的这段内存就给 程序 B 的数据段 b 用了

而当 程序 A 的数据段 a 又需要运行的时候，这时候发现虚拟地址没有和物理地址产生映射关系，因此产生 缺页异常，然后就从 虚拟内存（swap 分区） 中获取数据段 a ,重新分配到新的物理地址运行，并与 虚拟地址产生映射关系，然后恢复运行




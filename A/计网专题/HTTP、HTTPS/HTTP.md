# HTTP

---



## 1、get 和 post 的区别

首先应该先搞清楚 get 和 post 是什么

get 是 **从服务器获取资源**，而 post 是 **向指定的 url 提交数据**

get 的资源可以是文本、图片、视频等，比如我们打开一篇文章，就是发送 get 请求给服务器，然后返回文章的内容

post 则是我们在一篇文章下面评论，就是通过 post 请求将评论内容作为数据，通过 TCP 协议传输给服务器



> GET 和 POST 方法都是安全和幂等的吗？

先说下安全和幂等的概念

- 安全是指方法请求不会 破坏 和 改变 服务器上的资源
- 幂等是指无论请求多少次，结果都是相同的（无论是查询还是别的）

通过上面这个概念，就可以看出来了，get 是安全和幂等的，因为 get 仅仅是查询

而 post 不是，因为 会新增 和 更新资源，会改变服务器上的资源，所以是不安全的，而多次提交会创建多个相同资源，因为 post 可能是更新或者删除或者插入





## 2、一次HTTP的完整请求过程（输入一个 url 的过程，后面还需要进行补充，详细讲解）

- 通过 DNS 解析域名，获取 IP 地址
- 客户端获取 IP 地址，向目的 IP 地址的服务端发起 TCP 连接（三次握手）
- 建立连接后，客户端向服务端发起 HTTP 请求（比如 get 请求获取静态资源）
- 服务端接收这个请求，在后台进行处理，比如请求某个页面，那么将 HTML 页面代码返回给浏览器
- 浏览器获取到完整的 HTML 页面代码，进行渲染，里面的图片等静态资源也通过一个个 HTTP 请求 进行加载（可以看出 HTML 代码 和 图片之类的是分开获取的，需要多次 HTTP 请求）
- 浏览器渲染完成，将页面展示给用户，如果没有后续请求，浏览器会向服务器发起断开连接（四次挥手）



## 3、HTTP 常见的状态码 

## ![img](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfXG1113Sjm0iaOXfoOv0tlUfV6qkzg4yHtOibAfTv6hTicOx73F55WWl4nW2FWlXnDJ7Igd9kvrrRnA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1) 



**1xx**

提示信息，中间状态，比如我转账给你，钱转过去需要一段处理时间，这段时间可以理解为 1xx



**2xx**

成功状态码，我们最愿意看到的

 「**200 OK**」是最常见的成功状态码，表示一切正常 ，可能服务器返回的 body 中会有数据

 「**204 No Content**」 也是是最常见的成功状态码，服务器不会返回数据

 「**206 Partial Content**」是 **应用于 HTTP 分块下载 或 断电续传**，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。 



**3xx**

表示用户请求的资源位置发生了改变，告知用户需要向新的 URL 发送请求（即旧的 URL 不再提供服务）

 「**301 Moved Permanently**」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。 

 「**302 Moved Permanently**」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。

上面这两个服务器会将新的 URL 一同返回，客户端自动进行访问

 「**304 Not Modified**」表示资源未修改，发送 get 方法请求资源的时候，服务器告知资源未修改，直接用原来的缓存就行了



2xx 和 3xx 都跟错误搭不上边，错误是指 客户端 或 服务端 某方面的错误



**4xx**

客户端方面的错误，服务端不能处理

 「**400 Bad Request**」表示客户端请求的报文有错误，笼统的错误，即并不知道什么错误

 「**403 Forbidden**」表示服务器禁止访问资源，即客户端访问了不能访问的资源

 「**404 Not Found**」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。 



**5xx**

客户端方面没有错误，而是服务端内部出现 了错误

 「**500 Internal Server Error**」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。 

 「**501 Not Implemented**」表示客户端请求的功能还不支持，服务端无法处理，类似“即将开业，敬请期待”的意思。

 「**502 Bad Gateway**」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。 

 「**503 Service Unavailable**」表示服务器当前很忙，暂时无法响应服务器，高并发下可能就有这样的返回码，类似“网络服务正忙，请稍后重试”的意思。 



**上面列举的是常见的状态码，一些不常见的就没列举了，比如 303，401，402 之类的**





## 4、HTTP 各个版本的区别 以及 演变的逻辑



### 1、HTTP 0.9

最原始的 HTTP 版本

- 只 支持 GET 请求：由于不支持其他请求，而 GET 是在 URL 中携带请求信息的，因此客户端无法向服务端发送太多信息
- 没有请求头/响应头 概念：不能指定版本号，同时只有一个版本，也无需指定，服务端只有返回 HTML 字符串的能力
- 短连接，即响应请求后，无需再进行通信，断开连接



HTTP 0.9 的局限性很大，能做的事很少



### 2、HTTP 1.0

- 新增了 POST、DELETE、PUT 等方式
- 增加了 请求头/响应头的概念，在请求/响应头 中指定 HTTP 版本号，以及状态码、权限、编码等
- 扩充了传输内容，可以传输图片、音频、二进制数据等



传输内容的扩容：**Content-Type**

Content-Type 是 请求头 和 响应头 中的一个字段，它指定传输资源的格式，可以通过解析这个字段来判断是什么类型的资源

比如客户端上传文件，需要在 Content-Type 指定二进制流的形式



特性：

- 无状态：服务端不会保存客户端的信息，这样就不会占用服务器内存
  - 可以通过 cookie/session 机制来做身份认证和状态记录
- 无连接：使用短连接，用完即断，表示连接的时间短，浏览器每次请求都需要建立 TCP 连接



HTTP 1.0 的缺点：

- 使用的是短连接，一次  HTTP 请求后都会断开连接（可以通过服务器配置支持多次），每次都需要进行 三次握手、慢启动、四次挥手，频繁通信情况下效率低，   其中 慢启动 主要对文件类大的传输影响大
- 存在 HTTP 队头阻塞





> ### 队头阻塞

- TCP 队头阻塞：即使使用滑动窗口，当一个数据包丢失，它将会导致后续的数据包无法发送，该数据包会重传直到接受方接收到发送 ACK 并且发送方接收到 ACK 为止
- HTTP 队头阻塞：请求 和 请求之间是有顺序的，下一个请求必须在上一个请求得到服务端响应后才能发出去，如果上一个请求阻塞了，那么后面的请求都会阻塞





### 3、HTTP 1.1



- 新增长连接：新增了一个 Connection 字段，里面有个 keep-alive 字段，可以设置保持连接不断开，以此成为长连接，因此一个  TCP 连接可以处理多个请求；HTTP1.1 是默认长连接的
- 管道化：对 HTTP 1.0 的修改，**管道化使得每个请求可以无需等待上一个请求响应即可发出去，不过响应还是按照请求的顺序返回**
- 缓存处理：新增字段：cache-control，对于 get 请求，浏览器会先看看自己是否有缓存，如果有，那么直接用，如果没有再请求，然后进行缓存，通过 cache-control 字段来控制缓存
- 断点传输：资源过大，可以分割传输，并且遇到网络故障的情况下，下次传输也可以从上次传输的地方接着传输



> ### 管道化

基于长连接的基础，我们先看没有管道化请求响应：

TCP 没有断开，用的同一个通道

```
请求1 > 响应1 --> 请求2 > 响应2 --> 请求3 > 响应3
```

管道化的请求响应：

```
请求1 --> 请求2 --> 请求3 > 响应1 --> 响应2 --> 响应3
```



管道化虽然解决了请求阻塞的问题，但是响应返回的顺序还是按照请求的顺序返回

这样的话，即使 响应2 比 响应1 事先准备好，但是还是要等 响应1 整完返回，响应2 才能返回

这是为了防止服务器返回 响应的时候，如果不按照顺序的话，那么服务器不知道相应对应哪个请求

本质上还是没有解决 HTTP 队头阻塞的问题





### 4、HTTP 2.0



HTTP 2.0 进行了全面改造，从数据传输的基本单位 到 使用的 协议 全部发生了改变

在 HTTP 2.0 中，有两个重要的新概念：帧 和 流

HTTP2.0 抛弃了 HTTP/1 使用的文本格式，使用的是二进制数据帧传输



> ### HTTP2.0 新加入的几个概念

连接(Connection)：一个 TCP 连接包含多个 Stream

流（Stream）：一个双向通讯流，代表一个完整的 请求-响应 过程

消息（message）：将每个 HTTP 请求 / 响应 看作一个消息，包含一个或者多个 frame

帧（frame）：数据传输的最小单位

- length：帧的最大长度
- type：帧的类型，比如设置流的优先级之类的
- stream identifier：流的id，即用来标识这个帧是属于哪个流的，**HTTP 1.1 中的队头阻塞就是因为响应和请求没有标识符，不知道怎么对应，所以响应才需要按照顺序返回，而这里给定了标识符了，所以就可以打破这个 HTTP 队头阻塞了**



> ### 上面各个概念的简单描述

首先我们需要搞清楚它们之间的关系

首先 连接(Connection) 就是一个 TCP 连接

那么 流（Stream）是什么？

流 它不是一个具体的事物，它代表着一次完整的 HTTP 请求/响应 过程

当客户端发起请求的时候，就是概念上建立起一个流（Stream），然后 请求/响应 的 帧（frame）进行传输，我们称 帧（frame）是在流上传输的

消息（message）就是每个 请求/响应，将它划分为多个部分，每个部分叫做 帧（frame）

即流上传输的就是 消息的部分，即 帧（frame）

消息（message）分块后是需要按照顺序进行传输的，这样接收方接收到后可以按照接收的顺序进行拼接，保证了有序性



一个 连接(Connection) 可以存在多个流，即用户可以同时发起多个请求，这样的话每个请求对应一个流



> ### 到底什么是流，以及什么是多路复用

**我们还需要再讲明，流，它不是一个具体的事物，既然不是一个具体的事物，那么怎么在 连接(Connection)  表示出 流（Stream）这个东西呢？**



帧（frame）上面有一个 stream identifier 字段，表示它是属于哪个流的

这样的话，其实就是像下面这样，所有的流的帧都在一条道上传输，不过是按照帧上的流的 id，来记录这个帧是属于哪个流的

不同流（Stream）的帧（frame）可以交错传输，而同一个流上的帧需要保证传输的顺序，这样才能够根据接收的顺序进行拼接，保证了有序性



下面的图不管发送还是接收都一条道，不过为了方便指明方向所以画成两条道

![img](https://upload-images.jianshu.io/upload_images/16844918-b13e6490eedb402c.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

*![image.png](https://pic.leetcode-cn.com/1599402910-XBmxXM-image.png)*



由于上面这波操作，将本来只有一条道的，给抽象成了多条流，即每条流的帧都是在各自的道上进行传输

然而，实际上它们还是在一条道上，不过是根据流的不同来区分出不同的道

![img](https://user-gold-cdn.xitu.io/2019/10/12/16dbed8846d82eee?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

而由于它们存在流的 id 标识符，因此可以发送多个请求，以及无需按照请求的顺序进行响应，因为它们有 流 id 进行标记，可以根据这个 流 id 识别出响应是属于哪个请求的，以此来解决了 HTTP 队头阻塞的问题

同时，上面这个讲解过程就是在讲解多路复用了





## 5、cookie、session、token 的关系

具体看：

 https://zhuanlan.zhihu.com/p/63061864 

 https://zhuanlan.zhihu.com/p/66754258 



最开始的互联网时代，服务器和客户端并不会去存储用户的状态。这段时间对服务端和客户端来说都很 happy

随着互联网的发展，像购物网站之类的兴起，越来越需要记住用户的状态，比如哪些人登录了系统，哪些人在购物车中放了哪些东西，这些全部需要将每个人区分开来，由于 HTTP 是无状态的，因此出现了一个新的事物 sessionID，作为一个会话的唯一标识，简单讲就是一个独一无二 的字符串，每个人收到的都不一样。因此发送 HTTP 请求的时候，只需要将 sessionID 一起发送过来，就知道是谁是谁了

但是，这样对用户来说爽了，对服务器来说可不是，因为用户只需要存储自己的 sessionID 即可，而服务器需要存储所有用户的 sessionID，当存在几千万，几亿个用户的时候，那对服务器内存来说就是一个巨大的开销

并且，在后来，出现了分布式，多台机器作为一个集群提供同一个服务，这样不同的用户就会被 推送 到不同的机器上去，而每台内存是不共通的，这样的话，假设 用户 A 在第一次请求同时进行登录，被推送到机器 1，机器 1 存储了用户 A 的 sessionID，用户 A 第二次请求被推送到机器 2，而机器 2 没有 用户 A 的 sessionID，因此会要求 用户 A 进行登录，这样显然是不友好的。因此就出现了这么几个方法：

- 粘性 session：固定将某个用户推送到固定的某台机器上去
- session 复制：一个用户的 session 通过复制发放到每台机器上去
- session 共享：通过 redis 等缓存中间件存储 session，这样每台机器只需要到对应的 缓存中间件上去访问 session 即可，不过需要做成集群防止宕机

但是，有人就开始思考，为什么 tm 的服务器要保存这些可恶的 session 呢？只让每个客户端去保存多好

可是如果 服务端不保存 session，怎么验证客户端发送过来的 sessionID 是服务端生成的而不是伪造的呢？

嗯，只需要验证即可，只要能够做到验证，就可以舍弃掉 session

用户 A 登录了系统，服务端生成一个 token(令牌)，里面包含了用户 A 的 userId，下次用户 A 再次请求的时候，直接将 token 发送过来，服务端进行验证即可。。。但是这本质上和 sessionId 没有什么区别，任何人都可以伪造啊。。。得想点办法

加密就行了，做成类似 CA 证书的那种，自己生成一个密钥，然后对混合到用户数据中，使用特定的 加密算法加密，做成一个 token，发送给客户端，让客户端自己存储，等到下次请求的时候，客户端将 token 发送回来，这样的话，服务端只要 使用对应的密钥 和 用户数据混合，再使用相同的加密算法加密，判断生成的 token 和 客户端发送过来的 token 是否一致，如果一致，则验证通过

这样的话，服务端就无需保存什么东西了，使用 token 代替 session，只需要让 客户端自己保存 token，服务端进行验证即可



**cookie**：用户第一次访问时服务端会生成一个 cookie 和 一个 session，然后将 session 中的 sessionID 存储在 cookie 中，返回给客户端存储，浏览器上每个域名对应一个 cookie，每次发送请求前浏览器会自动去查看 是否缓存了对应域名的 cookie，如果有则获取然后一并发送给服务端

- cookie 存储 sessionID，还存储了用户的购物车信息、用户的个性设置（主题）



**session：**服务端生成，存储在服务端中，作用是通过跟客户端发送过来的 cooike 中的 sessionID 进行比对，进行身份验证

- session 内部存储用户的相关信息，比如 userId，后台应该是 map 存储，sessionID 和 session 是 key-value 的关系。



**token：**解决 服务端存储 session 的问题，服务端无需保存任何东西，只需要将 token 发送给客户端，后续自己进行验证即可



当浏览器禁用 cookie 时，存在两种验证方式：

- 浏览器保存 sessionID，然后在请求的时候直接发送 sessionID，这种的服务器需要存储 session
- 浏览器保存 token
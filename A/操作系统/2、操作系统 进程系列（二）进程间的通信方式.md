# 进程间的通信方式



## 1、管道（半双工）



> ### 匿名管道

[匿名管道](https://blog.csdn.net/skyroben/article/details/71513385)



**匿名管道是内核的一段缓存**

```java
ps auxf | grep
```

上面的 "|" 就是一条匿名管道，需要时创建，用完就直接销毁，没有名字，跟 java 的匿名内部类一样

比如下面这段 java 代码，传入了一个 Runnable 的匿名类对象，用完即毁

```java
new Thread(() -> {
    System.out.println(1);
}).start();
```



管道 “|” 表示将前面命令的输出 作为 后面命令的输入，很明显**数据是单向传输的**

图示如下：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190522031913582.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyODk2NjI3,size_16,color_FFFFFF,t_70)

**匿名管道只能用于父子进程间的通信**

```C
int pipe(int fd[2]);
```

调用 pipe() 创建一个匿名管道，fd[2] 中一个作为写端，一个作为读端，父进程会 fork() 一个子进程，然后将 fd 也复制给子进程，然后父进程连接 fd[0]，子进程连接 fd[1]，一方进行写入，一方进行读取



 ![img](https://img2018.cnblogs.com/blog/1525417/201901/1525417-20190107155245237-468611278.png) 



**读写操作：**

读端不读，写端一直写：管道大小有限，当写满时，write() 会阻塞

写端不写，读端一直读：read() 会阻塞

写端关闭，读端一直读：检测到写端关闭，默认读取到数据末尾，数据传输完成，read() 返回 0

读端关闭，写端一直写：检测到读端关闭，写进程会收到 SIGPEPE 信号，导致写进程异常终止



> ### 命名管道

匿名管道的局限性在于它是一段缓存，对于其他进程来说不可见，只能父子之间进行通信

因为为了能够实现任意进程之间进行通信，出现了命名管道



**命名管道 是以文件形式存在的**，在使用前需要创建一个 命名管道 文件，然后调用 open() 打开命名管道文件

由于命名管道以文件形式存在，所以**任何能够实现进程之间的通信，前提是进程能够访问到命名管道所在的路径**

命名管道 又叫 FIFO，即遵循先进先出的原则，第一个进入的数据会第一个被读走（其实感觉匿名管道也是一样的）



**命名管道调用 open() 时可以通过方法参数设置 读写是否阻塞**，读写阻塞时的情况跟 匿名管道是一样的



> ### 匿名管道和命令管道的 相同点 和 区别

**相同点：**

- 匿名管道 和 命名管道 都是管道，只能实现单向数据传输，如果需要双向通信，那么需要开两个管道
- 管道有大小限制
- 管道数据面向字节流，即数据之间不存在界限（类似 TCP 数据传输）



**区别：**

- 匿名管道是内核态的一段缓存，用完即毁；命名管道以文件形式存在，是持久化的，可多次使用
- 匿名管道因为只是一段缓存，对于其他进程不可见，所以只能使用于父子进程之间；命名管道以文件形式存在于文件系统中，任何能够访问命名管道所在的路径的都能够利用它实现通信
- 匿名管道 的读写默认是阻塞的；命名管道调用 open() 打开文件可以设置读写是否阻塞



**管道要求进程间进行实时通信**，不能让写进程先写数据，然后离开，后面等到读进程需要的时候再来读数据，必须两个同时出现才能够进行通信



## 2、消息队列 （全双工）

管道只适合实时通信，所以出现了**消息队列，用来处理进程间 非实时通信 的情况**

消息队列跟我们平常的邮件一样，只管发，不需要对方立马进行接收，发送完我们就可以去做别的事了，没有实时性



消息队列的数据结构如下：

```C
struct msqid_ds
  {
    struct ipc_perm msg_perm;  //消息队列访问权限
    struct msg *msg_first;    //指向第一个消息的指针
    struct msg *msg_last;     //指向最后一个消息的指针
	ulong  msg_cbytes;       //消息队列当前的字节数
	ulong  msg_qnum;        //消息队列当前的消息个数
	ulong  msg_qbytes;     //消息队列可容纳的最大字节数
	pid_t  msg_lsqid;     //最后发送消息的进程号ID
	pid_t  msg_lrqid;     //最后接收消息的进程号ID
	time_t msg_stime;     //最后发送消息的时间
	time_t msg_rtime;     //最后接收消息的时间
	time_t msg_ctime;    //最近修改消息队列的时间

```

**消息队列是内核中存储消息的一个链表结构**，存储的元素是数据块

消息队列的特点：

- **每个数据块只能存储一个类型的数据**，多个数据块可以存储不同的数据类型
- **数据块可存储的数据大小是有限制的**，因此不能用来传输大数据
- **全双工**

 ![img](https://img-blog.csdn.net/20170519105643346?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2t5cm9iZW4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center) 

## 3、共享内存（全双工）

[udp卷2 共享内存 1](https://blog.csdn.net/u010129119/article/details/77949579?utm_medium=distribute.pc_relevant.none-task-blog-title-3&spm=1001.2101.3001.4242)

[udp卷2 共享内存 2](https://blog.csdn.net/enlyhua/article/details/79888868?utm_medium=distribute.pc_relevant.none-task-blog-title-2&spm=1001.2101.3001.4242)



共享内存是 多个进程拿出某些虚拟页，然后再从用户态内存中拿出一块物理内存，将进程的虚拟页共同映射到这块物理地址上

这样的就它们的数据交流就不需要经过内核态缓存了



**我们讲的拷贝是什么？**

数据从 磁盘到内核 以及 从内核到磁盘 的拷贝 都是借助 DMA 来实现的，这里不涉及到 CPU

我们讲的 拷贝是 CPU 实现的拷贝，需要占用 CPU 资源，因此我们通过 减少拷贝次数 来 提高 CPU 效率



**管道/消息队列存在四次用户态和内核态之间的拷贝：**

- 进程 A 调用系统函数 read() 读取文件 A，DMA 将文件 A 从磁盘拷贝到内核 buffer，CPU 将内核 buffer 的数据拷贝到 用户态**（一次内核态到用户态的拷贝）**
- 进程 A 调用 write()，CPU 将 数据拷贝到 内核态的 缓存中（缓存可以是 管道或者消息队列，这个缓存跟上面的 buffer 不一样，上面的是内核态常驻的，这里的缓存是为了通信而开启的）**（两次用户态到内核态的拷贝）**
- 进程 B 调用 read()，CPU 从内核态缓存中读取数据**（三次内核态到用户态的拷贝）**
- 进程 B 调用系统函数 write() 将数据 写到文件 B 中，CPU 将数据从用户态拷贝到内核态，然后写回到磁盘中**（四次用户态到内核态的拷贝）**

![img](https://img-blog.csdn.net/20170912211559441)

**共享内存只需要两次拷贝：**

- 进程 A 调用系统函数 read() ，DMA 读取文件到内核态缓存，CPU 将数据从内核态拷贝到用户态的共享内存中**（一次内核态到用户态的拷贝）**
- 进程 B 调用系统函数 write() ，CPU 将共享内存中的数据拷贝到内核态，DMA 将内核态缓存的数据写入文件，**（两次用户态到内核态的拷贝）**

![img](https://img-blog.csdn.net/20170912211610292)

简单讲，共享内存减少的两次拷贝就是 进程 A 和 进程 B 之间的数据通信



> ### 共享内存的缺点

多线程下共享资源的不合理竞争，导致数据错乱



## 4、信号量（PV）

共享内存存在进程不安全的问题，即会发生数据错乱，因此需要保护机制，**保证共享内存一次只能由一个进程访问**

**信号量是为共享内存服务的，（Java 中的 sync 锁 和 lock 锁实际上是 信号量的一种特殊情况，只有一个可用资源）**



信号量涉及两个操作：P 和 V

P 操作是将可用资源数 -1，V 操作是将可用资源数 + 1

**过程：**

- 信号量初始化为 1
- 当 进程  A 先到达时，执行 P 操作，发现信号量为 0，那么可以访问数据

- 当 进程 B 到达的时候，执行 P 操作，发现信号量为 -1，那么陷入阻塞状态

- 等到 进程 A 访问完数据，执行 V 操作，信号量 +1，变成 0，唤醒 进程 B
- 进程 B 访问完数据，执行 V 操作，信号量 +1，变成 1

这样做就很好的保护了共享内存



上面这个是信号量用来互斥的，有时我们就需要实现 生产者-消费者模式，可以使用 PV 来实现

比如 进程 A 是生产者，进程 B 是消费者

 ![img](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZckxn1SzJ697nE1m1wJzmPQlO6zu8K0xlLpDBbew0jVibibhVm59TQy4ibJSZKxqKsWOrcLIibZE6RAVg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1) 

**过程：**

- 信号量初始化为 0，表示当前无数据 可消费
- 如果 进程 B 先执行 P 操作，发现信号量为 -1，那么进入阻塞状态
- 之后 进程 A 执行，生产数据，然后执行 V 操作，信号量 +1，变成 0，唤醒 进程 B 进行消费



## 5、信号

**信号一般是用来异常通信的**，比如杀死某个进程时发送的就是信号，进程需要接收信号并且进行处理（可以选择忽略）

信号作为一种通信方式，并不涉及到数据传输（如果把发送的信号当数据那就没得说了）



进程 A 给 进程 B 发送信号，进程 B 在收到信号之后，不管执行到程序什么位置，都要暂停运行去处理信号，处理完毕再继续执行（当然，如果进程 B 对信号的处理是选择忽略那没得说）



信号的使用场景：

- 杀死一个进程，子进程 exit 后会发送 信号 通知父进程进行收尸
- kill 指令就是发送信号给目标进程，要求目标进程终止运行
- so on。。。



通过 `kill -l` 指针可以查看 kill 指令的信号种类

 ![img](https://images2015.cnblogs.com/blog/342318/201604/342318-20160417104856113-1320338870.png) 

kill 如果没有加任何参数时，默认为 kill -15。平常用得最多的是 kill -9

kill -9 的信号是 SIGKIL，kill -15 的信号是 SIGTETM

当进程收到 SIGKIL 时，会立马退出运行，但有些特殊情况是不会响应该信号的

当进程收到 SIGTETM 时，有以下几种情况：

- 立即退出
- 释放完资源后退出
- 继续执行，忽略信号



## 6、Socket（不同主机通信）（全双工）

上面的几种通信方式，都是在同一台主机上面的进程间的通信方式

如果要跨网络或者主机，就要使用 socket 通信




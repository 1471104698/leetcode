# TCP 和 UDP



## 1、TCP 的报文头部

具体看  https://blog.csdn.net/wujingjing_crystal/article/details/52305523 



 ![这里写图片描述](https://img-blog.csdn.net/20170324221213371?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveXRodW5kZXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

TCP 头部长度不包括选项为 20字节，而选项最大为 40 字节，因此 TCP 头部长度最大为 60字节

- 头部长度：TCP 报文头部长度，最小是 20 字节
- 源端口
- 目的端口
- 校验和
- 序列号 seq
- 确认号 ack number
- 6 位标志位：SYN、ACK、FIN、RST、PSH、URG
- 滑动窗口大小：默认 16bit，接收方用来告知发送方自己能够接收的最大字节数，最大为 65535，同时也表示**默认情况下，接收方的接收缓冲区最大能存储 65535 byte 数据**
- 紧急指针：跟 URG 包配合使用，该数据是偏移量，表示 URG 包数据的最后一个字节位置
- 选项：
  - MSS 值
  - 窗口扩大：用来扩大滑动窗口，滑动窗口最大默认只有 16 bit，这个选项可以将窗口扩大为 32 bit，即**接收方的接收缓冲区最大能存储 2^32 = 4GB 数据**
  - 时间戳：根据时间戳 计算 报文往返时间 RTT，可用于超时重传设置超时时间 RTO 的设置基准

> ###  序列号

发送方和接收方都会初始化一个 **随机序列号 ISN**（客户端和服务端都可以是发送方）

**序列号** 的作用：

- 让 TCP 接收方将无序的数据按照序列号进行拼接
- 将 TCP 发送方由于超时发送的重复数据去重



**为什么序列号需要随机？**

为了防止 TCP 预测攻击，防止第三方发送一个 序列号符合预期的包，但是内容是伪造的，因为如果你不加序列号，那么数据包都是从 0 开始的，而加了随机序列号 ISN，数据包就是从 ISN 开始的了，而 ISN 是 0 ~ 2^32 尽头再循环，攻击者难以预测这个 ISN



> ### 标志位：

对应类型的报文的标志位置为 1

- *ACK*：确认应答，TCP 规定除了最初建立连接时的 `SYN` 包之外该位必须设置为 `1`** 
- *RST*：表示 中断异常，如果已经连接那么要断开连接
- *SYC*：表示建立连接，并在其「序列号」的字段进行序列号初始值的设定。
- *FIN*：表示断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 `FIN` 位置为 1 的 TCP 段。
- PSH：PSH 即 "PUSH"，即推送，有时候希望输入一个命令后就能收到对方的回应，因此这时候可以将 TCP 的 PSH 位置 1，这样的话 TCP 接收区就不会等待 缓冲区满了，而是直接告知应用程序处理
- URG：表示有紧急数据要传送，该包具有最高优先级，因此会放在数据的最前面，比如当某个程序在远处主机运行的时候，我们发现了问题，想要中断这个程序，因此就发送一个 URG 包，当存在 URG 包时，会将这个 URG 包放在缓冲区的最前面，这样应用程序就可以优先处理；URG 包后面的是普通数据，URG 包的最后一个字节是由 紧急指针 来记录的



## 2、UDP 的报文头部

 ![这里写图片描述](https://img-blog.csdn.net/20171109193828215?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvREJfd2F0ZXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast) 

UDP 报文头部长度为 8 字节

- 源端口号
- 目的端口号
- UDP 报文长度
- 校验和

**UDP 头部字段中没有头部长度，因此 UDP 的头部长度固定是 8字节，而 TCP 有头部长度是因为 TCP 有个 "选项"字段，所以头部长度不固定**



## 3、TCP 和 UDP 区别

TCP：

- 面向连接：进行数据传输需要进行三次握手确保安全连接，后续断开需要 四次挥手
- 基于字节流：从报文头部可以看出，TCP 中没有记录 TCP 的报文长度，也就意味着不知道数据的长度，那么就会跟其他的 TCP 报文数据混在一起，这也就是因为 TCP 是字节流的，它没将数据当作一个报文一个报文来看待，而是当作将一个字节流的数据分为多次发送而已
- 可分片：由于 TCP 存在序列号，所以分片后的数据能够按照序列号重新进行有序拼接
- 可靠性传输：拥有重传机制、滑动窗口、流量控制、拥塞控制
- 一对一：跟谁连接就只能使用该连接跟谁发送数据
- TCP 头部报文复杂

UDP：

- 无连接：UDP 不使用连接的形式，想发给谁就发给谁，发出去了不管对方接不接收，反正发就完事了
- 基于报文：UDP 首部有 UDP 报文长度，意味着记录了 UDP 的数据长度，这就跟别的 UDP 数据划分开了；当应用层获取数据的时候，一次都是获取一个报文，如果一次不能将一个 UDP 报文的数据给全部获取，那么剩下的 UDP 数据会直接舍弃
- 不能分片：由于 UDP 没有序列号机制，所以分片后的数据无法进行有序拼接，因此不支持分片，如果遇到 UDP 数据大于 MTU 的，那么 UDP 报文直接丢弃
- 不可靠性传输：不能保证数据一定发送到对方手里，并且不会理会网络是否拥堵，发送速率一直不变
- 一对一、一对多、多对多：由于不存在连接一说，想发就发，因此现在可以发给 A，待会可以发给 B
- UDP 头部报文简单



## 4、UDP 使用场景 和 实现可靠性传输

TCP 强制过重的可靠性传输，一方面在于 超时重传时间 RTO

TCP 根据 报文往返时间 RTT 计算出 超时重传时间 RTO，TCP 协议默认的 RTO 等待时间是 2倍增长的

比如最开始 RTP = 100ms，那么往后每一次超时等待 RTO 的变化为：100ms -> 200ms -> 400ms -> 800ms -> 1600ms

如果一直丢包，RTO 将会变得非常大，效率非常低



比如 cs go 这种射击游戏，对方给自己扔手雷，对于自己来说，是能看到爆炸效果和声音的，但是对于远处的队友来说，他能听到的就是声音，并且他主要是注意在自己打出的子弹上，注意的是眼前的敌人，如果使用 TCP 传输给队友的手雷爆炸声音的包丢失了而一直重传，这样提高了队友的延迟，明显是会影响队友的游戏体验



由于 TCP 过于繁重，而如今网络发展对于实时性要求很高，因此 TCP 的繁重机制 慢慢的不再适用

却而代之的是 UDP，但是由于 UDP 没有重传机制之类的，所以在网络环境差的情况下会经常丢包，因此需要实现它的可靠性传输

**可靠性传输传输在应用程序层面实现，而不再跟 TCP 一样依托于 操作系统 和 内核，这样扩展性更好**

我们可以在应用层调整丢包重复的时间，可以设置为 1.5 倍

这样 RTO 的时间变成：100ms -> 150ms -> 225ms -> 375ms -> 500+ms



UDP 可靠性可以在应用层 实现 重传机制（超时重传 + 快重传）、以及再开一个滑动窗口控制发送速率，再对每个报文加序列号方便让接受方进行拼接

具体看场景，因为在应用层我们可以随时添加或者删除一些功能，以及很方便的修改一些参数，扩展性强


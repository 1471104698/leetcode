# IP、MAC等





## 1、七层网络模型 和 TCP/IP 网络五层模型

> ### OSI 七层模型 和 网络的 五层模型

![img](https://picb.zhimg.com/80/v2-8241be381782789f7fb5735d8541c506_720w.jpg)





| OSI中的层    | 功能                                               | TCP/IP协议族                |
| ------------ | -------------------------------------------------- | --------------------------- |
| 7 应用层     | 文件传输，电子邮件，文件服务，虚拟终端             | HTTP，FTP，DNS              |
| 6 表示层     | 数据格式化，代码转换，数据加密                     |                             |
| 5 会话层     | 解除或建立与别的接点的联系                         | 没有协议                    |
| 4 传输层     | 提供端对端的接口                                   | TCP，UDP                    |
| 3 网络层     | 为数据包选择路由                                   | IP，ICMP，OSPF，EIGRP，IGMP |
| 2 数据链路层 | 传输有地址的帧以及错误检测功能                     | SLIP，CSLIP，PPP，MTU       |
| 1 物理层     | 在物理媒介（电话线、空气（WIFI））上传输二进制数据 | ISO2110，IEEE802，IEEE802.2 |



> ### TCP/IP 每层使用的协议

物理层：RJ45、CLOCK、IEEE802.3 （中继器，集线器）

数据链路：PPP、 MTU 、VPN、Ethernet（以太网）（网桥，交换机）

网络层：IP、ICMP（ping）、ARP、RARP （路由器）

传输层：TCP、UDP

会话层：

表示层：

应用层：FTP、DNS、HTTP



> ### 为什么分层

分层就跟 java 类一样，各司其职，只需要考虑自己的任务即可

并且如果有地方需要进行修改，那么修改需要变动的层即可

 **每一层独立于其他层完成自己的工作，而不需要相互依赖，上下层之间通过标准接口来互相通信，简单易用又具有扩展性。** 





## 2、IP 头部

 ![这里写图片描述](https://img-blog.csdn.net/20171118172527691?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjkzNDQ3NTc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast) 

- 版本号：比如 IPV4 和 IPV6
- 头部长度：跟 TCP 一样最小是 20 字节，但是由于 "选项" 字段存在所以需要记录头部长度
- 总长度：IP 报文的总长度， IP 头部 + TCP/UDP 头部 + 数据
- 标识：用于记录相同分片的，IP 分片后每个分片的标识一样
- 标志：3位，每一位分别为："保留/DF/MF"，DF 表示禁止分片，MF 表示当前 IP 数据报不是最后一个分片
- TTL：报文最大生存时间，经过一个路由器 TTL - 1
- 协议：TCP、UDP、ICMP
- 校验和
- 源 IP 地址
- 目的 IP 地址
- 选项

IP 头部最小为 20 字节，其他看 "选项"



> ### TTL 生存时间

为了防止数据包在网络中无限跳转，因此会设置一个 TTL

每当经过一个路由器跳转，那么 TTL -1，当为 0 时，该包丢弃



可以使用 ping + TTL  的组合来判断到达目的主机需要经过多少个路由器

比如最开始设置 TTL = 1，这时候经过一个路由转发后就变成了，被舍弃，并且由于 ping 使用的是 ICMP 报文，因此路由器会发送一个 【请求超时】 的 ICMP 差错报文

然后再设置 TTL = 2，TTL = 3，直到收到 ICMP 回应报文，这样就可以知道路径上需要经过多少个路由器了



## 3、DNS



> ### 域名

使用域名的主要原因就是方便用户记忆，不然你每次都输入一串 IP 地址去访问，这样多麻烦

输入 访问 url 后，需要先通过 DNS 域名解析，获取到 目的 IP 地址，才能进行 TCP/UDP 通信

 

**根 DNS 服务器最高级，每台 DNS 服务器中都有记录 根域 DNS 服务器**

**根域 DNS 服务器 记录了所有 的 DNS 服务器，这样其他 DNS 服务器可以通过访问 根域 DNS 服务器 来获取其他 DNS 服务器的位置**



`www.baidu.com.root` 这是一个完整的域名，简写为 `www.baidu.com.` ，注意后面有个 `.`，而由于所有的域名后面都有一个 `.root`，因此平时都省略掉了，这里的 `.root` 就是根域名



`.com` 是顶级域名，同时也是一级域名（com 用于商业机构）

`.baidu` 是注册的

`www` 是我们自己定义的

`baidu.com` 是二级域名，`www.baidu.com`是三级域名，当然也可以使用 `fuck.baidu.com`作为三级域名，但是这样不如 www 来得容易记

 ![img](https://pic4.zhimg.com/80/79b9fd2666e989ab24024966632ae63f_720w.png) 

> ### 1、域名解析的工作流程

当我们输入 url 后，会检查 hosts 文件、本地 DNS 服务器缓存是否存在对应的域名解析，如果存在则直接返回，如果不存在则进行 DNS 解析

- 客户端首先会发送一个 DNS 请求给本地 DNS 服务器（点开网络配置可以看到，一般我们是不会配置的，是默认的 DNS 服务器，具体可以看 IP 地址划分那张图，或者自己点开网络配置看），问 www.server.com  的 IP 地址是什么
- 本地 DNS 服务器获取到请求后，如果自己有记录，那么将 IP 地址返回，如果没有，那么找到自己记录的     根 DNS 服务器，询问对应的 IP 地址，“老大， 能告诉我 www.server.com 的 IP 地址吗？”  
- 需要注意的是，根DNS 服务器 并不参与域名解析，但是我们上面说了，根DNS 服务器 存储了所有 DNS 服务器，因此它可以查询出管理 com 的 DNS 服务器，将地址发给 本地 DNS 服务器，（不参与解析，但会指明一条道路）
- 本地 DNS 服务器获取到管理 com 的顶级域名服务器的地址后，发起请问问它：“老二， 你能告诉我 www.server.com  的 IP 地址吗？”
- 顶级域名服务器会告诉 本地 DNS 服务器 管理 server.com 的权威域名服务器地址
- 本地 DNS 获取 权威域名服务器地址，发起请求问：“老三，www.server.com对应的IP是啥呀？”
- 权威 DNS 服务器查询后将对应的 IP 地址 X.X.X.X 告诉本地 DNS。
- 本地 DNS 再将 IP 地址返回客户端，**客户端将 IP 地址进行缓存**，然后和目标建立连接。



**客户端和本地 DNS 之间是递归，本地 DNS 和 各个 DNS 服务器之间是迭代**



> ### 2、DNS 使用的协议



DNS 同时使用了 UDP 和 TCP 协议，占用了 UDP 和 TCP 的 端口53

UDP 简单高效，TCP 加了太多的安全措施，效率低



**DNS 中有两种行为：一种是域名解析，一种是区域传送**

**域名解析：**将 www.baidu.com 解析为 ip 地址

域名解析使用 UDP，如果使用 TCP 的话就需要进行 三次握手四次挥手，其中 TIME_WAIT 默认 2min，而一次 DNS 查询需要连续访问多个服务器，这效率太低了



**区域传送：**

DNS 规定了两种 DNS 服务器，一种叫主 DNS 服务器，一种叫辅助 DNS 服务器，类似 redis 的集群，一个 master 和 多台 slave，在 master 崩了后 slave 可以进行顶替，以及平时帮忙分摊 DNS 查询请求；DNS 服务器一般是一台 master 和 一台 slave

区域传送就是 master 和 slave 需要进行数据同步，master 的数据要传送给 slave，需要保证可靠性，所以使用 TCP



同时 DNS 如果基于 UDP 协议，那么最多只能传输 512 字节的数据，如果超过 512 字节，那么必须进行分片，但是 UDP 又不能进行分片，因此只能使用 TCP 来传输



**即 DNS 使用 TCP 的情况有两种：**

- DNS 报文数据超过 512 字节
- 进行区域传送



> ### 3、根服务器的数量

有流言说全球的 "根服务器 数据量为 13 台，一旦 DDos 攻击了根服务器，那么全球的网络就瘫痪了"

其实不然，在 2014 年，全球有 504 台根服务器，被编号为了 A - M 13 组

所以是 13 组，而不是 13 台



> ### 4、DNS 劫持

 http://www.hackdig.com/?01/hack-1196.htm 



DNS 劫持的现象：输入 google.com，弹出来的是百度的页面（域名解析时被中间人拦截，然后发送假的 ip）

HTTP 劫持的现象：打开的知乎页面，结果右下角弹出了 贪玩蓝月 的广告

即 DNS 劫持导致访问的 ip 不是原来的 ip，HTTP 劫持访问的是原来的 ip，但是添加了广告之类的





DNS 解析是通过 DNS 服务器的，意思是 DNS 服务器给你返回什么 ip 你就用什么 ip

因此如果 DNS 服务器给你返回一个假的 ip，那么你就会访问到这个假的 ip

受信任的 DNS 服务器一般不会干这种事的（当然运营商的 DNS 服务器会通过这个方法赚钱，姑且不谈），都是一些中间人篡改用户的计算机默认的 DNS 服务器



DNS 劫持一般是**路由器的 DNS 劫持**，中间人通过自己架设一个 DNS 服务器（只是一个组件），一个后台服务器，再仿造原 html 页面，用作钓鱼网站，然后进入别人的路由器界面，通过暴力破解密码，登录路由器，然后将里面的默认路由器设置为自己的 DNS 服务器，这样后续域名解析的时候就是使用的自己的 DNS 服务器，都直接解析为自己的 服务器 ip 了，这样客户端访问的就是假的 ip 了



以下是路由器界面，可以设置 DNS 服务器

 ![img](https://pic2.zhimg.com/80/v2-dab29a5aa8b9d68c064505054b0e3069_720w.jpg) 





## 4、ARP

ARP：地址解析协议，实现从 IP 地址到 MAC 地址的映射，即询问 目的 IP 对应的 MAC 地址



假设 A ping B，那么会封装成 ICMP 报文，其他包括 A 的 ip、A 的 MAC、B 的 ip、B 的主机

但是如果 A 不知道 B 的 MAC，那么就会封装失败那么就无法进行通信，好比 送快递知道 收件人姓名（IP） 但不知道地址（MAC）,那么这个快递就无法寄出

因此，A 需要获取 B 的 MAC 地址，通过向全网段 广播 【ARP 请求包】，其中包括 A 的 ip、A 的 MAC、B 的 ip

当整个网段中的 主机都收到这个 【ARP 请求包】时，会拆开看，如果发现其中请求的 ip 地址不是自己的 ip，那么直接将包丢弃，如果发现其中的 ip 地址是自己的 ip，那么根据 包中的 A 的 ip 和 A 的 MAC 将自己的 MAC 地址封装到 【ARP 回应包】 中单播 发送给 A ，其他的主机不会受到这个 【ARP 回应包】

当 A 收到这个 【ARP 回应包】 的时候，拆开获取 B 的 MAC 地址，并且添加进行自己的 【ARP 表】中，方便下次直接使用，而这个 MAC 表是存储在内存中的，因此关机就会消失，并且里面的数据是具有一定时效性的，到了过期时间就无效了

（可以通过 arp -a 查询已经缓存的 MAC 地址）

*![image.png](https://pic.leetcode-cn.com/1600697523-buYJrB-image.png)*



**一般 ARP 协议是运行在 同个网段下的，因为广播不能跨网段**



> ### 那么如果是跨网段下的 ping 呢？

什么时候是跨网段？

当主机 A 和 主机 B 使用子网掩码 & ip 的时候，得到的网络号不同，那么就是跨网段的



当 A ping B 是跨网段的时候，与 A 同个网段的主机都会收到 ARP 请求，但是由于它们都不是目的主机，所以会舍弃

**网关设备（路由器）**收到后发现 B 不是当前网段的，那么就会返回自己的 MAC 地址给 A

A 拿到后，发送 ping 消息，这时候目的 MAC 地址是网关的了，因此这个消息会发送到网关上，网关通过 **路由** 将 消息发送给 B

B 收到后通过相同原理发送给 A



> ### ARP 到达是属于 数据链路层还是网络层？

从功能上看，ARP 为数据链路层服务，寻找 MAC 地址，属于 数据链路层

从分层上看，ARP 属于 网络层

默认情况下还是当作网络层吧



> ### ARP 欺骗

但凡局域网发生 ARP 欺骗，都表示 网络存在 "中间人"。

假设局域网中存在 3 台主机 P1,P2,P3，它们都连接上同一台交换机，对应三个接口 p1,p2,p3

假设 P3 是 ARP 攻击的实行者，那么是如何进行攻击的呢？

先回顾下正常下的 ARP 通信

P1 要跟 P2 进行通信，但是不知道 P2 的 MAC 地址，所以会发起 ARP 广播，此时 P2 接收到后回应一个 ARP 单播包，而 P3 **处于 "监听" 状态**

<img src="https://pic4.zhimg.com/80/v2-6522b0e3e1b7e7058152e70953428c74_720w.jpg" style="zoom:80%;" />

正常情况下，P3 收到 ARP 请求包后是会直接舍弃的

但是这里 P3 在 "监听" 之后，会给 P1 发送 ARP 回应包：我就是 P2（MAC3）

<img src="https://picb.zhimg.com/80/v2-383f86e253b689d40ff20d648ce7afac_720w.jpg" style="zoom:80%;" />



很明显，P3 对应的是 MAC3，这明显就是一个 ARP 欺骗行为。

那么 P2 和 P3 的 ARP 回应包都到达 P1 的手里，P1 会如何处理？

P1 收到两个 ARP 回应包：

- 我是 P2，IP 地址是 IP2，我的 MAC 地址是 MAC2
- 我是 P2，IP 地址是 IP2，我的 MAC 地址是 MAC3

这时候 P1 就会很蒙蔽，但它必须选择一个，而默认的规则就是 "后来优先"，即 P1 会选择后面来的 ARP 包作为 P2 的 MAC 地址。

那么 P3 怎么保证自己的 ARP 包一定会比 P2 的先到呢？

实际上 P3 只要不断发送 ARP 欺骗包，就一定能够覆盖掉 P2 的正常包

最终 P1 在 MAC 缓存表上记录了："IP2 -> MAC3"，ARP 欺骗目的达成

<img src="https://picb.zhimg.com/80/v2-bade17b91e12c9f9ad5536858abf1350_720w.jpg" style="zoom:80%;" />



根据规则，当 P1 要跟 P2 通信时，无论是 ping 还是什么，首先都会去查询 ARP 表，这样查找出来的就是 MAC3 了，这样就导致 P1 发送的数据就是发送到 P3 那里了，数据一览无余，而 P2 如果要跟 P1 进行通信，P3 也可以使用相同的方法进行 ARP 欺骗，这样 后续 P1 和 P2 的通信全部由 P3 掌控

<img src="https://pic1.zhimg.com/80/v2-317858c5badea87786011cb8eda6d3fd_720w.jpg" style="zoom:80%;" />



危害就是 P3 控制了数据流，那么可以轻易做到篡改数据、断开通信（断网攻击）、限速攻击（比如突然网络加载很慢），并且明文传输的数据，都会被 P3 窃取



## 5、ping

**ICMP 协议跟 TCP/UDP 协议同个等级，但是却是属于网络层**

ICMP 报文类型有：请求/应答、请求超时 等

其中 请求/应答 属于 查询报文类型，请求超时 属于 差错报文类型

ping 使用的就是 ICMP 的 查询报文类型



ping 是网络层的，所以需要经过 IP 协议封装成 IP 报文再传输到数据链路层

ICMP 报文中主要有三个属性：

- 报文类型：标识是请求报文还是回应报文

- 序列号： 每发送一个请求包，序列号 +1，由于 ping 不是只有一次，会连续发送很多个 ping 包

  ```
  正在 Ping www.a.shifen.com [163.177.151.110] 具有 32 字节的数据:
  来自 163.177.151.110 的回复: 字节=32 时间=5ms TTL=49
  来自 163.177.151.110 的回复: 字节=32 时间=7ms TTL=49
  来自 163.177.151.110 的回复: 字节=32 时间=5ms TTL=49
  来自 163.177.151.110 的回复: 字节=32 时间=5ms TTL=49
  ```

- 发送时间：为了计算 往返时间 RRT，好得出网络延迟情况，所以会插入发送时间



ping 的主要过程：

- A ping B，如果使用的是域名，那么使用 DNS 查找对应的 ip 地址
- A 封装一个 类型为 请求 的 ICMP 请求包，然后将 ICMP 请求包 和 ip 地址都交给 IP 层，封装成一个 IP 报文
- 最后需要 MAC 地址，查找 ARP 表，如果没有目标 ip 地址的 MAC，那么使用 ARP 广播获取对应的 MAC 地址
- 获取到 MAC 地址后，将 IP 报文 和 MAC 地址交给数据链路层，封装成一个数据帧，再发送出去
- B 收到数据帧后，检查 MAC 地址是否是自己的，如果是则封装一个 ICMP 回应包发送出去，如果不是则直接舍弃

在规定时间内，如果 A 收到了 B 的 ICMP 应答包，表示可达，否则不可达



![img](https://pic2.zhimg.com/80/v2-356582a65204ac9801a057f13f964db2_720w.png)





## 6、路由表、ARP 表、MAC 表



路由表：用于路由，记录了所有能够路由到的 ip 地址，其中每个 ip 地址对应着 网络掩码，用于查看对应的 ip 处于哪个网络段

通过在 cmd 界面使用 route print 命令查看

```
IPv4 路由表
===========================================================================
活动路由:
			网络目标        网络掩码          	网关       			接口   跃点数（路由成本，越小越好）
          0.0.0.0          0.0.0.0       10.21.71.1       10.21.71.101     35
       10.21.71.0    255.255.255.0            在链路上      10.21.71.101    291
     10.21.71.101  255.255.255.255            在链路上      10.21.71.101    291
     10.21.71.255  255.255.255.255            在链路上      10.21.71.101    291
        127.0.0.0        255.0.0.0            在链路上         127.0.0.1    331
        127.0.0.1  255.255.255.255            在链路上         127.0.0.1    331
  127.255.255.255  255.255.255.255            在链路上         127.0.0.1    331
    192.168.137.0    255.255.255.0            在链路上     192.168.137.1    281
    192.168.137.1  255.255.255.255            在链路上     192.168.137.1    281
  192.168.137.255  255.255.255.255            在链路上     192.168.137.1    281
    192.168.153.0    255.255.255.0            在链路上     192.168.153.1    291
    192.168.153.1  255.255.255.255            在链路上     192.168.153.1    291
  192.168.153.255  255.255.255.255            在链路上     192.168.153.1    291
    192.168.227.0    255.255.255.0            在链路上     192.168.227.1    291
    192.168.227.1  255.255.255.255            在链路上     192.168.227.1    291
  192.168.227.255  255.255.255.255            在链路上     192.168.227.1    291
        224.0.0.0        240.0.0.0            在链路上         127.0.0.1    331
        224.0.0.0        240.0.0.0            在链路上      10.21.71.101    291
        224.0.0.0        240.0.0.0            在链路上     192.168.227.1    291
        224.0.0.0        240.0.0.0            在链路上     192.168.153.1    291
        224.0.0.0        240.0.0.0            在链路上     192.168.137.1    281
  255.255.255.255  255.255.255.255            在链路上         127.0.0.1    331
  255.255.255.255  255.255.255.255            在链路上      10.21.71.101    291
  255.255.255.255  255.255.255.255            在链路上     192.168.227.1    291
  255.255.255.255  255.255.255.255            在链路上     192.168.153.1    291
  255.255.255.255  255.255.255.255            在链路上     192.168.137.1    281
```



ARP 表：记录 IP 地址 与 MAC 地址的映射关系



MAC 表：用于数据链路层中交换机转发数据帧，交换机存在一张 MAC 表，里面记录了 MAC 地址 和 这个 MAC 地址对外开放的接口，当交换机获取到一个 数据帧的时候，会查看数据帧头部的 MAC 地址是否在自己的 MAC 表中存在，如果有则直接根据对应的接口将数据帧传送给它，如果没有，那么进行广播

交换机广播的原理 跟 ARP 原理一样，交换机 A 将数据帧广播出去，所有的交换机都会收到这个消息，假如只有交换机 B 有记录这个 MAC 地址，那么它会单播回应，并且加上自己的 MAC 地址，这样交换机 A 就知道 交换机 B 有这个 MAC 地址了，那么记录交换机 B 的地址，后续对于 目的 MAC 地址的数据帧转发 都是交换 A 将数据帧发送给交换 B ，让它去转发
# 】TCP 的可靠性实现



## TCP 可靠性 靠什么实现？

这里的可靠性不是说三次握手、四次挥手，而是连接完成后，中间的数据传输

**TCP 的可靠性是通过 确认应答机制、超时重传机制、滑动窗口、流量控制、拥塞控制 实现的**



## 1、确认应答机制

TCP 是面向字节流的传输，对每个字节都进行了编号

比如 客户端 这次传输了 [1,100]，那么序列号就是 1，然后服务端接收后发送一个 ACK = 101 ，表示下次期望收到 101 的序列号数据报

 ![img](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeuicRMlA8rKvl5AVLibhibDhg7rhicME5YSPXZCicwvDpdicChuibpe3AbuavGsDNz5ibPIicibF6wiaJHlKlFQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1) 



## 2、重传机制

> ###  超时重传

当

- 发送端发送的数据包丢失，接收方没有接受到数据所以没有发送 ACK
- 接收方发送的 ACK 丢失

上面两种情况都导致发送方没有收到 ACK

在发送方发送完一个包后，会启动重传计时，如果在超时等待时间内，收到了 ACK，那么就无需重传

如果是超过超市等待时间，那么是带着悲观的思想，认定为数据包丢失

每次超时重传的超时等待时间，是先前设置的两倍，因此多次超时重传等地的时候周期会很长



**超时重传存在重传的等待的时间过长，因此就出现了快速重传**



> ### 快速重传

快速重传的出现是为了减少超时重传的超时等待情况，因为在特定情况下，很大概率是出现了丢包问题，这样的话就无需超时等待，直接重新发送数据包就行了，去掉了超时等待的时间

也说了，只有在特定情况下，才会是快速重传，其余情况下是超时重传

而这个特定情况就是：在超时重传等待时间内，收到 3 个重复的 ACK



![img](https://pic2.zhimg.com/80/v2-0434a2de30645ee6d809bb30f0ad551c_720w.jpg)

- 数据发送使用的是滑动窗口，发送方发送窗口内的多个数据：seq1、seq2、seq3、seq4、seq5，假设 seq2 在网络中丢失了
- 然后接收方按照顺序，只接收到了 seq1、seq3、seq4、seq5，没有接受到 seq2 的数据，因此它接收到 seq1 后期望收到的是 2 号数据，因此 发送 ACK 2，而后续数据可以接收处理，但仍然回送 ACK 2，表示没有接收到 seq2
- 而发送方在 se3、seq4、seq5 这 3 个 ACK，而且都是 ACK 2的，表示 seq2 在网络中丢失了，因此重新发送 seq2
- 当接受方接受到 seq2 时，由于之前已经处理了 seq3、se4、seq5，因此这次无需再发送 ACK 3，而是表明下次接收的是 ACK 6 了



> ### 为什么  快速重传是 通过 3 个 重复 ACK 来判断丢包的

两次 重复 ACK 肯定是数据包乱序造成的

三次 重复 ACK 可能是数据包乱序造成的，也可能是数据包丢失造成的

而反过来说，数据包丢失必定会造成 三次重复 ACK，即三次重复 ACK 我们按照概率问题，忽略掉数据包乱序的情况，直接判定为数据包丢失，懒得等待超时了，直接重发数据，这也就是快速重传的思想



**为什么 丢包必定会造成 3 次 ACK ？**

这个前提下，是对发送了 4 个以上数据包来说的，因为一般情况下的通信，发送肯定超过 4 个数据包，因此是满足条件的

A 为发送方，B 为接收方

假设 A 按照顺序发送了 N - 1、N、N + 1、N + 2 号的数据包，我们探讨 A 收到 ACK(N) 的情况

B 方到达的顺序有

- N-1，N，N+1，N+2   这种情况 A 会收到 1 个 ACK(N) 
- N-1，N，N+2，N+1   这种情况 A 会收到 1 个 ACK(N) 
- N - 1，N + 2，N，N+1   这种情况 A 会收到 2 个 ACK(N) 
- N - 1，N + 1，N，N+2   这种情况 A 会收到 2 个 ACK(N) 
- N - 1，N + 2，N + 1，N   这种情况 A 会收到 3 个 ACK(N) 
- N - 1，N + 1，N + 2，N   这种情况 A 会收到 3 个 ACK(N) 

上面的是数据包乱序 收到的 ACK 个数的各种情况

如果是丢包的情况，假设 N 号数据包丢了（要看 ACK(N)，就只能第一个是 N - 1，如果第一个不是 N - 1，那么发出的就是 ACK(N - 1) 了），那么 B 收到的顺序只剩下两种情况：

- **N-1，N+1，N+2**，收到 3 个 ACK(N)
- **N-1，N+2，N+1**，收到 3 个 ACK(N)



可以发现

- 1 - 2 个 ACK 只能发生在乱序的情况下
- 乱序的所有情况下，收到 3 个重复 ACK 的概率为 2 / 6 = 33%

- 而 丢包的概率下 100% 会收到 3 个 重复的 ACK，基于此，舍弃掉 33% 概率的超时等待，直接重发数据包







## 3、滑动窗口

#### 

> ### 为什么需要滑动窗口

因为 TCP 使用了确认应答机制，每发送一次数据都需要接收到 ACK 后再发送下一部分数据，效率过低

如果没有滑动窗口的话，那么发送数据的过程如下：

- TCP 是每发送一次数据，都要进行一次应答确认，即得到 上一个数据包的 应答，才发送下一个数据包

- 如果每次数据发送的大小都是一个 TCP 报文的话，那么就有点像你我两个人聊天，你一句我一句的，你说我回，我回了你才能继续说

- 如果你说了一句话，而我在干别的事，那么你需要等待我干完，你还必须重新说那句话，这样效率低下



因此，引入了滑动窗口，根据接收端的接收处理能力，来发送更多的数据

**当使用窗口的时候，无需等待收到确认应答，只要在窗口大小内还有可发送数据，那么可以直接发送**



窗口的实现实际上是操作系统内部的一个缓存空间，当你发送出数据后，直到收到确认应答，才可以删除对应的数据缓存，否则，那么需要根据缓存的数据进行重发



**累计确认：**

比如下面的，发送了 【100， 700】，如果 服务端处理完 【500，599】 后发送的 ACK = 600 丢失了，即客户端没有收到确认应答，但是，后面收到了 ACK = 700，那么表示 700 前面的数据都处理完毕了，无需等待 ACK = 600

如果这里发送了 【100，599】，收到了 ACK = 500，却没有收到 ACK = 600，那么就需要从缓存中获取 【500，599】 重新发送



> ### 窗口发送大小由哪一方决定？

窗口大小由接收端决定

TCP 中有 窗口大小  这个字段，接收方会在 ACK 中设置该字段，告诉发送方自己现在还能接收多少数据

发送端就可以根据服务端的接收能力来发送对应大小的数据，而不会一股脑的发送数据，超出服务端的处理能力





> ### 发送方的滑动窗口

发送方的窗口分为四个部分：

- 已发送并且已经收到 ACK（处理完毕， #1： 1 - 31 字节）

- 已发送但未收到 ACK（服务端尚未处理完毕，或者 ACK 还在路上，#2：32 - 45 字节）

- 未发送但是可以发送（服务端还能接收数据，这些数据现在可以发送给服务端，但是现在还没有发送，

  #3 ：46 - 51 字节）

- 未发现并且现在不能发送（后面的这些数据不能发送，因为超出了服务端的接收能力，#4 ：52 - 56 字节）



*![image.png](https://pic.leetcode-cn.com/1597993856-goRUji-image.png)*



如果 32 - 36 字节收到 ACK 后，那么缓存空间中会删除掉这些数据，并且窗口会往右边移动，到达 56

*![image.png](https://pic.leetcode-cn.com/1597994071-LvuLnd-image.png)*



滑动窗口 4 个部分的表示是使用 3 个指针来区分的，即相当于我们使用 write 和 read 指针来压缩字符串一样

SND.WND：窗口大小变量

SND.UNA：第一个指针，位于窗口的第一个字节，表示窗口的起始位置

SND.NXT：已发送数据的末尾位置，同时也是可发送数据的起始位置，SND.NXT - SND.UNA 即为 #2 的大小

*![image.png](https://pic.leetcode-cn.com/1597994129-NGveQS-image.png)*



> ### 接收方的滑动窗口

没啥好说的，比较简单

*![image.png](https://pic.leetcode-cn.com/1597994365-FJXXeT-image.png)*





> ### 窗口关闭 - 滑动窗口为 0 时的产生、危害以及解决方法

产生：

如果发送方一直发送数据，但是接收方非常繁忙，没有时间处理数据，那么就会导致发送方的可发送数据窗口为 0

而 接收方是通过 **ACK** 来告知 发送方窗口大小的，当接收方处理完数据，发送一个窗口非 0 的 ACK 告知发送方，告知可发送窗口大小



危害：

如果接收方发出 窗口非 0 的 ACK 后，由于网络拥堵 导致 ACK 丢失了，那么发送方接收不到这个 ACK

那么就会导致 发送方一直等待接收 ACK，而接收方一直等待发送方发送数据，造成死锁



解决方法：

TCP 为每个连接设置一个 定时器，只要 TCP 发送方收到 接收方的 窗口关闭 通知，那么就会开始 定时器计时

如果定时器从计时 到 指定时间 的范围内没有收到接收方的 窗口非 0 ACK，发送方就会发送一个 窗口探测 报文，而接收方收到这个窗口探测报文的时候，会给出自己的窗口大小

这样接收方的 窗口非 0 ACK 丢失了，发送方也可以自己进行探测

但是如果也不是一直进行探测的，如果 接收方发送的窗口大小一直为 0，那么不还是死锁么，所以 TCP 限定了 窗口探测的次数，默认为 3 次，3 次过后如果还是 0 的话，那么发送 RST 中断连接

## 4、流量控制

流量控制是基于滑动窗口的， 发送方不能无脑的发数据给接收方，要考虑接收方处理能力。 

如果一直无脑的发数据给对方，但对方处理不过来，那么就会导致触发重发机制，从而导致网络流量的无端的浪费。

为了解决这种现象发生，**TCP 提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量，这就是所谓的流量控制。**



就是我们上面说的，接收方每次接收到发送方的数据后，会告知发送方现在的可接受窗口大小，发送方根据这个窗口大小来发送对应大小的数据



**流量控制就是使用 滑动窗口来实现的**



## 5、拥塞控制

前面的流量控制是避免发送方一股脑的发送数据，导致接收方处理不过来

但是流量控制并不会去在意网络中的环境，它只考虑接收方的问题

**计算机网络都处在一个共享的环境。因此也有可能会因为其他主机之间的通信使得网络拥堵。** 

**如果网络拥堵的话，发送方继续发送大数据，那么很可能会导致数据包延迟、丢失等问题，这时候发送方会超时重传，继续发送大数据，但是一旦重传，又会加重网络拥堵，导致更多数据丢包，然后又重传，恶性循环不断加大**



将网络链路比喻为一根水管，如果我们要将更多的数据发送出去，就是往水管里注水

为了保证水管不会爆掉，TCP 维护了一个拥塞窗口 cwnd(congestion window)，用来估计一段时间内水管的载水量（网络链路中最大可传输的数据包数），拥塞窗口的大小取决于网络链路中的拥塞程度，它是动态变化的，为了知道最大的传输效率，我们就需要知道这条水管的传输效率如何，因此做法就是：往这条水管不断注水，直到水管爆掉为止，翻译成 TCP 的话来说就是：

```java
往网络链路中不断发送数据，只要没有出现网络拥堵，那么就可以发送更多的数据，增大拥塞窗口，以便把更多的数据发送出去
一旦出现网络拥堵（水管爆掉），那么表示达到最大传输速率了，这时候应该减小传输的数据
```



**TCP 有 4 个拥塞控制算法：慢启动、拥塞避免、快重传和快恢复**





![在这里插入图片描述](https://img-blog.csdnimg.cn/20190731155254165.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDMxNDA2,size_16,color_FFFFFF,t_70)





> ### 慢启动

TCP 在最开始建立好连接后，不会立马发送大数据，而是会一点一点提高数据量

- 最开始指定拥塞窗口 cwnd = 1，表示只能发送一个 MSS（最大报文长度） 大小的数据
- 当收到 1 个 ACK 后，cwnd +1，一次能够发送 两个 MSS 大小的数据
- 当收到 2 个 ACK 后， cwnd +2, 一次能发送 4 个MSS 大小的数据
- 当收到 4 个 ACK 后， cwnd +4，，，， 当收到 8 个ACK 后，cwnd +8

拥塞窗口 cwnd，同时也是该阶段的慢启动的数据发送量，它是按指数增长的，但是它有一个阈值 ssthresh 



**只要 cwnd 小于 ssthresh ，那么就使用慢启动**



> ### 拥塞避免



当 慢启动到达阈值 ssthresh ，那么就开始拥塞避免算法

比如上述的 cwnd = 8 时进入拥塞避免

- 那么后续每次收到一个 ACK 时，cwnd 就会增加 1 / cwnd，即 1 / 8（八分之一）

- 那么意思就是需要接收到 8 个 ACK，才能凑齐一个 1，cwnd 才能变成 9

- 后续就需要接受到 9 个 ACK，才能凑齐一个 1，cwnd 才能变成 10

cwnd 是按线性增长的



> ### 快重传 和 快恢复出现的原因

早期的 TCP 拥塞控制，并没有快重传和快恢复，有点悲观的想法：只要发生数据丢失，就认为了发生了网络拥堵

因此，有报文在网络中丢失时，就会导致发送方超时重传，而误认为发生了网络拥堵，直接重新开始慢启动，将 cwnd 重新设置为 1，这表示数据发送又只能从 1 开始了，传输效率降低了



**因此，为了解决这个问题，出现了快重传和快恢复，避免重新开始慢启动**

发生超时重传就会进入慢启动，因此在发生超时重传前，提前进入 快速重传，试图解决问题



![在这里插入图片描述](https://img-blog.csdnimg.cn/20190731165605396.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDMxNDA2,size_16,color_FFFFFF,t_70)







> ### 快重传

快重传就是上面重传机制的快速重传

当发生丢包的时候，发送方收到 3 个相同的 ACK ，那么就会启动快重传机制

与此同时，开始快速恢复算法





> ### 快速恢复

快重传发生的同时，快速恢复也同时进行

**发送方收到了 3 个重复 ACK，表示网络并不是拥堵（因为网络拥堵的话这 ACK 也会丢失在网络中），而是因为数据报丢失的问题，由于不是网络拥堵，那么就没必要重新开始慢开始过程**



快速恢复算法开始后，cwnd 和 慢开始阈值 ssthresh  进行修改

ssthresh  = cwnd / 2

cwnd = ssthresh + 3（这里 +3 是因为 这 3 个报文也是在网络中传输过来的，表示网络中不是堆积了报文，而是减少了 3 个报文，因此可以将拥塞窗口扩大些）

我们上面说了， cwnd < ssthresh  才会开始慢开始，而这里 cwnd > ssthresh  ，所以不会慢开始

降低完 cwnd 和 ssthresh 后，重新进行的是拥塞避免算法



简单来说，快速恢复就是认为能够接收到 3 个重复的 ACK，那么表明不是 网络拥堵的问题，而是单单是因为数据报运气不好在网络中丢失了，所以开启快重传重新发送丢失数据，并且将 拥塞窗口和慢开始阈值降低为原来的一半，重新开始拥塞避免算法，主要还是防止不是由于网络拥堵的原因，而发生超时重传然后重新慢启动将 cwnd 设置为 1，降低传输速率



> ### 为什么快速恢复要缩减 慢启动阈值 ssthresh 

因为进入 快速恢复是因为它认为能够接收到 3 个重复 ACK ，那么网络应该没有拥堵

但实际上可能网络拥堵了，因此先降低 ssthresh ，这样，如果快速恢复失败了，即需要再重新开始 慢启动 的过程的话，

是从 cwnd = 1 的这个数据大小来重新发送数据的，由于网络拥堵了，所以 ssthresh 必须缩小，不能还是原来那个阈值，因为后面相当于指数增长，继续那个阈值的话后面发送的数据量大得一批，不就会继续加大网络拥堵了么
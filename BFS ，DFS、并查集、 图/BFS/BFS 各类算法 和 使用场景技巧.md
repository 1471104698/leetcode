## BFS 各类算法 和 使用场景技巧



### 普通的 BFS

```java
1、
普通的 BFS 只适用于 无权图
比如给你一个二维数组，其中有 或 没有障碍物，求到终点的最短路径，这种就是无权图
比如 126. 单词接龙 II，每次进行一次修改变为其他的单词，这种同样是无权图
比如 210. 课程表 II，求课程完成顺序 之类的
比如 994. 腐烂的橘子

它是按层级分的，每一次 while(size-- > 0) 循环结束就多加一层

当第一个到达终点的结果即为最短路径结果，因为是按层级分的，当第一次遇到结果的 level = 3，那么最短肯定为 3，因为后面再遇到 level 肯定 >= 3

BFS 正是因为内部元素是按层级递增的，所以才能够找到最短路径，如果里面不是递增，而是乱序的，那么第一个遍历到的结果不一定是最短路径
也就是说，正是因为 BFS 内部元素层级递增，所以才存在第一个到达终点的结果是最短路径之说


2、
BFS 同时分为 单向 BFS 和 多源 BFS

比如上面的两个示例 就是单向 BFS

而对于像 1162. 地图分析 这种，求 所有海洋区域到离它最近的陆地区域的距离中最大的距离，就是使用多源 BFS ，从各个陆地出发，得到将所有海洋同化为陆地的步数

又比如 同时从起点和终点 出发，直到两个触角相遇，这个就是双向 BFS
```



### 0·1 BFS

```java
普通的 BFS 在无权图上秀得飞起，但如果在带权图上，只能让位给 dijsktra 算法，O(n) -> O(nlogn)
但如果权值比较特殊，只有 0 和 1 的情况下（0 1 权值通常需要我们自己观察出来），那么就继续考虑使用 BFS，
但不是上述普通的 BFS， 而是 用双端队列实现的 0-1 BFS

比如给你起点和终点，从起点出发，每个位置都标有指定的方向
1、如果像指定方向走，那么不需要花费任何代价，即权值为 0
2、如果不按指定方向走，那么需要花费 1 代价，即权值为 1
3、问到达终点的花费的最少代价
（注意：这里求的不是到达终点的最短路径，而是能够到达终点的最少代价，即可以绕远路，但是这条远路所花费的代价必须比近路的代价少）
比如题目：1368. 使网格图至少有一条有效路径的最小代价

//过程：
因为我们计算的是最小代价，因此不管近路还是远路，只要花费代价小，我们就优先走该路径
这意味着首先我们到达 (i, j)，路径为 1，但是代价为 1，而我们绕了远路，一直能够按照指定方向走，到达 (i, j)，路径为 5，但是代价为 0
因此，我们会提前走代价为 0 的，因为我们求最小代价（暗地里的最短路径），而不是明面上的最短路径
即我们将权值为 0 的点放在队首，即下一次遍历就是该点，权值为 1 的放在队尾，最后遍历

//这里需要解释下 元素节点的存放成立的理由：
由于队列元素存储是按层次递增的，位于队首的层级肯定小于等于排在后面的层级，即越前面的越是最短路径
当我们遇到权值为 0 的时候，放在队首，即我们下次仍然按该层级进行遍历， 这样能够保证层级最低
如果后续该节点都存在权值为 0 的，那么会一直按照路径走下去，直到遇到权值为 1 的，那么我们就先放到队尾，相当于舍弃该路径，去走队首的节点，因为它层级低
我们把层级高的一个个放在队尾，队首的层级肯定比后面元素低

简单点说，就是我们按照某条路径走，如果遇到全是权值为 1 的方向，那么我们搁置该路径，然后走别的路径，如果别的路径都遇到权值为 1 的，那么搁置这些路径，走该路径
直到最终第一个到达终点的，即为最短路径

//题型容易产生的误区：
但是像 1293. 网格中的最短路径 这种给定消除障碍物机会的，求在机会内到达终点的最短路径
虽然看起来如果不消除障碍物和消除障碍物的权值跟 0 和 1 一样，但是实际上又不同，
像 1368 是可以无限花费代价，但是只要求能够到达终点的最小代价，意思是无论怎么走都必定能够到达终点，只是代价数不同
但是这道题，是给定了代价数，如果路径上一味消除，那么最终可能在中途失去了所有的消除机会，后面遇到障碍物就无法消除，导致路径走不通
因此，我们不能使用 01 BFS，而是使用普通的 BFS，记录某个位置节点的消除机会，因为中途过程中消除机会不够的会被淘汰
因此最终第一次到达结果的，必定是使用了不超过指定消除机会的次数到达的终点，并且层级数最低，因此即为最短路径
```


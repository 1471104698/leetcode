# 虚拟内存

---



## 1、虚拟内存的诞生

> ### 故事背景

在最开始，虚拟内存还没有出现的时候，进程直接操作的是物理地址，并且程序加载到内存需要连续的内存空间，比如 一个大小为 10M 的程序，如果要运行，必须在内存空间中找到 连续的大小为 10M 的空间，才能将程序加载进内存

上面这种加载方式肯定是有问题的，具体的问题如下：

**1、地址空间不隔离**

内存中的两个程序 A 和 B，假设程序 A 的物理地址为 0x00000000~0x00000099

程序 B 的物理地址为 0x00000100~0x00000199

程序 A 假如就跟我们自己写代码一样，一旦不小心越界了，将数据写进了 0x00000150 的地址，那么受影响的不只是程序 A，连 程序 B 也有问题



**2、程序运行地址不稳定**

比如我们在程序中直接写死，操作的是 0x00000050 地址，由于程序直接访问的就是物理地址，因此就直接操作该物理地址了

但是，程序每次加载的内存地址是不一定的，上一次加载的是 0x00000000~0x00000099，那下一次加载的可能就是 0x00000100~0x00000199 了，那么直接操作地址也是有问题的



**3、产生内存碎片**

比如 存在三个程序，其中程序A大小为10M，程序B为70M，程序C的大小为30M，而内存空间总共有100M。

它们是无法同时在内存中执行的，一次只能执行两个程序

并且，如果先执行了程序 A，再执行程序 B，那么等到需要程序 C 执行的时候，我们需要换一个程序下来，

如果换 A，那么内存空间存在 10M 和 20 M 两个内存碎片，还是无法执行 C



**因此，为了解决上述问题，就出现了虚拟内存**



操作系统为 每个进程 都分配一套 虚拟地址空间，每个进程的虚拟地址都是一样的，但是每个进程的虚拟地址映射到不同的物理地址

因此，两个进程即使访问的是同一个虚拟地址，但映射到的物理地址却是不一样的



操作系统引入了 虚拟内存，进程持有的虚拟地址会通过 **CPU 中存储的 内存管理单元（MMU）** 来 映射成 物理地址



**伴随着虚拟内存出现的就是 分段技术 和 分页技术，随后还有 段页内存管理技术**



## 2、分段机制

**它是将程序分为四个部分，分别是 堆、栈、数据、代码，每个部分都用单独的内存空间存储，即分段**



各个段 对应的物理地址 通过段表查询。

段基地址就是在物理地址中的起始位置，然后段界限就是属于这部分的空间大小

比如 段基地址为 1000，段界限为 1000

那么我们可以得到该段在物理地址为  [1000 - 2000]

![img](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfVYxicDjAjl4nMxlmyJk7rk87ABj8vKWeQANrKVHpm7xNZRTbgFPOicpy74mD65ia3rGgMaIo6G1ntQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)





> ### 内存分段的缺点

我们需要知道，虽然进程采用分段的机制，将 4 个段分散在不同的内存空间，但是实际上它们还是一个整体，只当删除进程的时候才会一起消失

- 会产生内存碎片（当某个进程关闭的时候，对应的空间会释放，于是就产生了内存碎片）
- 内存交换效率低（由于产生了很多内存碎片，于是就需要进行 swap）
- 内存利用率低（上面说了，虽然分段，但仍然是一个整体，这个程序的部分内存可能不是很常用，但仍然占着内存）



> ### 内存碎片的产生

我们来看看这样一个例子。假设有 1G 的物理内存，用户执行了多个程序，其中：

- 游戏占用了 512MB 内存
- 浏览器占用了 128MB 内存
- 音乐占用了 256 MB 内存。

这个时候，如果我们关闭了浏览器，则空闲内存还有 1024 - 512 - 256 = 256MB。

如果这个 256MB 不是连续的，被分成了两段 128 MB 内存，这就会导致没有空间再打开一个 200MB 的程序。



![img](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfVYxicDjAjl4nMxlmyJk7rk0bmZo1YuxhYHTQN7uokA8dsGX1cJAyApOdHxxwjqOjjQIxHRaFB6Xg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



**解决外部内存碎片的问题就是内存交换。**

可以把音乐程序占用的那 256MB 内存写到硬盘上，然后再从硬盘上读回来到内存里。不过再读回的时候，我们不能装载回原来的位置，而是紧紧跟着那已经被占用了的 512MB 内存后面。这样就能空缺出连续的 256MB 空间，于是新的 200MB 程序就可以装载进来。

这个内存交换空间，在 Linux 系统里，也就是我们常看到的 Swap 空间，这块空间是从硬盘划分出来的，用于内存与硬盘的空间交换。





> ### 内存交换效率低的原因

对于多进程的系统来说，用分段的方式，内存碎片是很容易产生的，产生了内存碎片，那不得不重新 `Swap` 内存区域

因为硬盘的访问速度要比内存慢太多了，每一次内存交换，由于内存中段是作为一个整体，一个段的内存空间可能很大，我们都需要把这一大段连续的内存数据写到硬盘上。

所以，**如果内存交换的时候，交换的是一个占内存空间很大的程序，这样整个机器都会显得卡顿。**





> ### 分段的优点

分段是从程序层面出发的，按照堆栈、数据段、代码段 进行分段，可以按照 段进行 数据共享 和 对不同的段进行权限保护



## 3、分页机制



分段会产生很多内存碎片 和 内存交换效率低的问题

内存交换的原因也是因为内存碎片多



内存分页 是将虚拟内存和物理内存划分为一个空间连续并且大小相等的内存空间，称为 页，在 Linux 下，每 页 4kb

虚拟地址 和 物理地址通过 页表来进行映射，跟上面的段表其实差不多

![img](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfVYxicDjAjl4nMxlmyJk7rkZoTKofqkOibHicWGJPwsCjZGRpG077zmMMnRibkVqcVocZz1PxeIuLLMg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



当进程访问的页在页表中查不到时，就会产生一个缺页异常，然后去读取对应的页



> ### 分页怎么解决内存碎片问题？

因为每次写入和释放都是以页的大小，那么所有的空闲内存空间都一个一个的页，不会存在比页大和比页小的内存空间

而当进程需要分配内存空间的时候，可以将任意位置的页分配给它，释放也是按也空间，自然不会存在内存碎片

当进程需要的内存空间不够时，会将其他正在运行的进程 【最近不被使用】 的内存页面给换掉，暂时写在磁盘上（就是 Linux 中的 swap 空间），一旦需要的时候，再重新读取

跟分段机制不同的是，分段机制一旦需要内存交换，那么就是整个进程 的读取和写入，而分页机制每次只需要一个或几个页面而已



> ### 分页的缺点

很明显，为了防止内存碎片，分配的单位都是以 页 为单位，假设一个页为  4KB，而一个程序只需要 1KB  的空间，那么至少也需要分配一个页给该程序，那么就会浪费掉 3 KB 的空间

一个计算机会运行很多程序，不可能所有程序所需的内存空间都刚刚好是页大小的倍数，反之，大部分程序都会浪费一点空间，程序一多浪费的内存空间就更多了



> ### 页面置换算法

OPT：理想层面上的算法

FIFO：先进先出算法

LRU：最近最久未使用算法，即每次换出的页面都是最先入队的页面

LFU：最近最少使用算法，每次换出的页面是使用次数最少的页面，如果使用次数都一样，那么换出最久未使用的数据



## 4、段页机制（Linux 的内存管理）

**段页机制就是 分段机制 和 分页机制的混合使用**，目的就是为了 整合 分段机制 和 分页机制的优点，同时避免单单使用分段机制和分页机制的缺点



实现方法就是 先将用户进程划分为多个段，然后再将每个段划分为多个页



看了下别人的说法 和 按照我个人的理解：段页式就是同样的将用户程序分成多个段，(不是特定的分成 堆栈、数据段和代码段，而是任意切分)，并给每个段取一个段名，然后将每个段再分为多个页

这样的话，通过 段号 找到对应的段，再通过 段内页号 找到对应的页，再通过该 页的页面地址 映射到物理空间

即地址结构：段号 + 段内页号 + 页内地址



![img](https://picb.zhimg.com/80/v2-3254b3e82516ddfe252f353fb406e419_720w.jpg)****



> ### 段页机制的优点

我们可以看出，它将 分段 和 分页的优点集中在了一起

将用户程序分为多个段，这是虚拟地址划分，因此可以按照段进行数据共享和权限保护

然后将各个段分为多个页面，每个页面可以分散的映射到物理地址，无需要求连续的内存空间，这样的话就不会产生内存碎片

虽然还是会跟 分页一样 产生内存空间的浪费





## 5、虚拟内存的总结

> ### 虚拟内存 和 swap 分区的关系

首先，我们需要知道，虚拟内存是磁盘空间

**在 Linux 中，swap 区就是 windows 的 虚拟内存，用于内存交换的**

**虚拟内存是将内存暂时不需要的数据存放到硬盘中**，**对于 Linux ，就是将这些数据存储到 swap 分区中**

**当然，因为是硬盘，所以读写速度肯定是比在物理内存中慢的，所以应该避免大数据的内存交换，比如上面的分段机制，就是因为存在大数据的内存交换，导致效率低下**



> ### 虚拟内存 和 虚拟地址的关系

虚拟内存是硬盘空间， 是为了方便大程序的运行，弥补物理内存小的缺点，用来必要时候顶替物理内存的

虚拟地址是每个进程独有的，虽然是独有的，但是每个进程的虚拟地址是一样的，但是它们映射的物理地址是不一样的，为了方便程序员管理地址，所以才设置为一样，**这是为了方便程序员管理和使用地址，所以保持每个程序的虚拟地址空间是一样的，这样就需要虚拟内存，虚拟地址就是为了向下屏蔽地址的分布的差异化，向上统一地址的使用**



> ### 虚拟内存的大致作用

- 它让程序感觉自己有拥有连续的可用的内存空间，实际上内部是分割成多个物理碎片，但是因为程序加载进内存，并不是全部都加载的，而是将需要的部分才加载进去，而当需要另外一部分时，才从硬盘中读取，然后替换掉内存中暂且不需要的内存，这样的话，无论多大的程序都能运行，因此每次都只需要运行需要的部分即可，不需要的就放到内存
- 程序不直接操作物理地址，由于虚拟内存是操作系统管理的，因此越界操作操作系统可以发现，达到地址隔离的作用
- 方便多个进程共享内存（比如进程间通信中的内存共享）



> ### 虚拟内存 和 缺页异常 的关系

虚拟内存是将内存暂时不需要的数据存放到硬盘中，因为放到了磁盘（虚拟内存）中

比如 程序 A 的数据段 a 不需要了，而 程序 B 的数据段 b 需要物理内存，所以会将程序 A 的数据段 a 从内存中拿出来，放到 虚拟内存 （swap 分区）中，然后断开程序 A 的数据段 a 的虚拟地址 和 它占用的物理地址的映射关系，而空出来的这段内存就给 程序 B 的数据段 b 用了

而当 程序 A 的数据段 a 又需要运行的时候，这时候发现虚拟地址没有和物理地址产生映射关系，因此产生 缺页异常，然后就从 虚拟内存（swap 分区） 中获取数据段 a ,重新分配到新的物理地址运行，并与 虚拟地址产生映射关系，然后恢复运行








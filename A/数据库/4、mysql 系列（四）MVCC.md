## MVCC

### 1、MVCC 出现的原因

MVCC 是不加锁的，最开始的 mysql 使用原生锁，相当于 java  的 syn 锁，一次只能够一个事务，相当于上面的 串行

但是这样效率很低，而且很多情况下是读多写少，因此出现了读写锁，读锁和读锁之间共存，写锁和写锁 、写锁和读锁 之间互斥

这样提高了并发能力，但是发现还不够，还要提高并发能力，让读写什么的都可以同时进行。

因此出现了 MVCC，**MVCC 只能在 读已提交 和 可重复读 两种隔离级别下进行**

```java
因为 读未提交 基本就是没有隔离，不管了的，而 串行 就是那种加了重量级锁的，两种都是不同方面的极端
```



**引入了 MVCC 之后，只有 写和写 会阻塞，其他的都能够并行操作**



**MVCC 实现：隐藏字段 + ReadView（快照） + undo log**

InnoDB 在表中的每行数据后都会添加 3 个 隐藏字段：

- **DB_TRX_ID**：记录最近一次对 当前数据行 做修改的事务 id，对于 delete 操作，同样认为是update，不过修改的是删除标志位
- **DB_ROLL_PTR**：回滚指针，看上面的 undo log 图，类似链表形式，用于回滚
- **DB_ROW_ID**：当没有主键或者唯一非空索引的时候，使用的就是这个 id，**这个跟 MVCC 没什么关系**

**通过 undo log 可以找到之前的事务旧数据**

**通过 ReadView 可以确定对于当前事务而言哪些事务是可见的**



### 2、ReadView

**RC 读 和 RR 读的区别就在于生成 ReadView 的策略不同**



ReadView 有 3 个重要字段 ：

- **low_limit_id**：当前 RV 创建时出现过的最大的事务 ID + 1，即下一个将被分配的事务 ID
- **up_limit_id**：当前 RV 创建时在活跃事务表 trx_ids 中最小的事务 id
- **trx_ids：**RV 创建时其他未提交的事务 id 集合列表，对持有 RV 的事物来说，它的 id 不会在 trx_ids 中



### 3、可见性算法

当 id = 11 的事务 select 某个数据行的时候，会创建一个 RV，而所有的事务 id 如下：

1	2	3	4	5	6	7	8	9	10	11	12	13	

其中有各个 id 对应的状态如下：

已提交事务 id：[1，2，3，4，7，9，12]

未提交事务 id：[5，6，8，10]（因为持有该 RV 的事务 id 不会在 trx_ids 中，因此忽略 11）

这样的话，low_limit_id = 14，up_limit_id = 5

此时 RV 上的数据就已经是固定了的，这就是快照，仅仅记录某个瞬间的数据，对于此刻的 id 11 事务来说，所有的事务就是这个状态

获取读取的数据行上的 trx_id，进行比较

- 1、如果 trx_id < up_limit_id，表示该数据是在创建 RV 前就已经被其他事务提交的了，那么对该事务来说是可见的，跳到步骤 5
- 2、如果 trx_id >= low_limit_id ，表示该数据是在 创建 RV 后才提交的，那么跳到步骤 4
- 3、如果 up_limit_id <= trx_id < low_limit_id ，那么表示创建 RV 的时候，这个数据可能是已经提交了的，或者提交这个数据的事务还在活跃中（即在 trx_ids 中），因此直接使用二分查找判断是否在 trx_ids 中
  - 如果不在，表示对该事务可见，跳到步骤 5
  - 如果在，表示当时那个事务当时还没有把它提交上去，因此对该事务不可见，跳到步骤 4

4、获取读取的数据行的` db_roll_ptr `指针，得到对应的 undo log 链的最新一个，获取对应的 trx_id，然后重新回到上面进行判断，直到跳到步骤 5 ，即找到一个可见的数据

5、找到可见值，那么结束了



### 4、当前读 和 快照读

快照读：普通的 select，每次调用 select 都会产生一个 RV 快照，这时候能够防止不可重复读和幻读，因为后续事务的数据新版本不会被读到

当前读：select...for share、select ... for update、 update、insert、delete 这种都是当前读，每次获取的是 数据行的最新数据，不会涉及到 RV 和 undo log

如果只靠 MVCC ，能够解决不可重复读 的问题，只能解决部分 幻读 的问题，而不能完全解决幻读

```
比如事务 A 开始，执行普通的 select 语句，这时候会创建一个快照，然后事务 B 执行 insert 操作
如果事务 A 再次执行 普通 select，那么就不会看到 事务 B insert 进去的数据，能够解决幻读
如果事务 A 再次执行的是 select...for update，那么会看到最新的数据，导致幻读
```

因此， 只靠 MVCC 无法解决 当前读 的幻读问题

因此， RR 级别下，会对当前读的 数据行 加上 行锁 和 间隙锁，即 使用 行锁 + 间隙锁 + MVCC 完全解决幻读问题



### 5、RR 和 RC 生成 ReadView 的策略

RR 是在第一次执行普通 select 语句的时候创建一次 ReadView，后续的 select 之类的操作都是按照这个 RV，不会再继续创建，因此保证了可重复读，不会读取到新修改的数据



RV 是在每次 执行普通 select 的时候都创建一个 RV，这样的话，每次其他事务修改数据，当前事务进行 select，获取的都是新版本的数据，因为 RV 也是即时创建的，所以才出现 可重复读 和 幻读 的问题




# [632. 最小区间](https://leetcode-cn.com/problems/smallest-range-covering-elements-from-k-lists/)

*![image.png](https://pic.leetcode-cn.com/6e37cb986ccbbd3455e1c5de97d797327beaa5091289d4d6418a9a3c3fdb4cfa-image.png)*

## 题意描述

给定 k 个有序列表，升序排序的

找出一个最小区间，各个列表中都至少存在一个数，包含在该区间中

如果存在多个长度相同的满足条件的区间，那么返回的是起始点最小的区间



**注意:**

给定的列表可能包含重复元素，所以在这里升序表示 >= 。
1 <= k <= 3500
-105 <= 元素的值 <= 105



## **示例 1:**

```java
输入:[[4,10,15,24,26], [0,9,12,20], [5,18,22,30]]
输出: [20,24]
解释: 
列表 1：[4, 10, 15, 24, 26]，24 在区间 [20,24] 中。
列表 2：[0, 9, 12, 20]，20 在区间 [20,24] 中。
列表 3：[5, 18, 22, 30]，22 在区间 [20,24] 中。
```



## 方法①、排序 + 滑窗

### 实现思路

​       ` [4,10,15,24,26], [0,9,12,20], [5,18,22,30]` 有 3 个分组，编号分别为 `0、1、2`

​        合并升序后得到：

​        `[(0,1),(4,0),(5,2),(9,1),(10,0),(12,1),(15,0),(18,2),(20,1),(22,2),(24,0),(26,0),(30,2)]`

​        比如上面的`(0, 1)` 表示 数值 0 在 1 号分组 `[0,9,12,20]`中

​        单单只看分组编号，那么就是` [1,0,2,1,0,1,0,2,1,2,0,0,2]`

​        我们维护一个包含所有分组的滑动窗口，上面 `k = 3`，因此窗口内部需要包含 `0、1、2` 三个分组编号

```java
        滑窗范围：                       最小区间：
        [1,0,2],1,0,1,0,2,1,2,0,0,2     [0,5]
        1,[0,2,1],0,1,0,2,1,2,0,0,2     [0,5]
        1,0,[2,1,0],1,0,2,1,2,0,0,2     [0,5]
        1,0,[2,1,0,1],0,2,1,2,0,0,2     [0,5]
        1,0,[2,1,0,1,0],2,1,2,0,0,2     [0,5]
        1,0,2,1,0,[1,0,2],1,2,0,0,2     [0,5]
        1,0,2,1,0,1,[0,2,1],2,0,0,2     [0,5]
        1,0,2,1,0,1,[0,2,1,2],0,0,2     [0,5]
        1,0,2,1,0,1,0,2,[1,2,0],0,2     [20,24]
        1,0,2,1,0,1,0,2,[1,2,0,0],2     [20,24]
        1,0,2,1,0,1,0,2,[1,2,0,0,2]     [20,24]
```



### 实现代码

```java
class Solution {
    public int[] smallestRange(List<List<Integer>> nums) {
        //分组数
        int k = nums.size();
        
        List<int[]> res = new ArrayList<>();
        for(int i = 0; i < k; i++){
            for(int j : nums.get(i)){
                res.add(new int[]{j, i});
            }
        }
        //按照数值升序
        Collections.sort(res, (a, b) -> a[0] - b[0]);

        //have[i] 表示滑窗内第 i 个分组的个数
        int[] have = new int[k];
        int valid = 0;

        //最小区间起始点
        int start = -1;
        //最小区间长度
        int minLen = Integer.MAX_VALUE;

        int left = 0;
        int right = 0;

        while(right < res.size()){
            int[] arr = res.get(right);
            int val = arr[0];
            int group = arr[1];
            if(have[group] == 0){
                valid++;
            }
            have[group]++;
            while(valid == k){
                int[] l = res.get(left);
                //获取区间长度，注意，区间是数值长度，而不是滑窗大小
                int curLen = val - l[0] + 1;
                if(minLen > curLen){
                    minLen = curLen;
                    start = l[0];
                }
                //分组减一
                have[l[1]]--;
                if(have[l[1]] == 0){
                    valid--;
                }
                left++;
            }
            right++;
        }
        return new int[]{start, start + minLen - 1};
    }
}
```


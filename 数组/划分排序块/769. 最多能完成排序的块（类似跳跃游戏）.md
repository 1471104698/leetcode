# [769. 最多能完成排序的块（类似跳跃游戏）](https://leetcode-cn.com/problems/max-chunks-to-make-sorted/)

<img src="https://pic.leetcode-cn.com/0e6b44516dcbeac60c85a0add9b6ea1b2ba56cd0475d5238fd4e38b99d2b8813-image.png" style="zoom:150%;" />





## **示例 1:**

```java
输入: arr = [4,3,2,1,0]
输出: 1
解释:
将数组分成2块或者更多块，都无法得到所需的结果。
例如，分成 [4, 3], [2, 1, 0] 的结果是 [3, 4, 0, 1, 2]，这不是有序的数组。
```



## **示例 2:**

```java
输入: arr = [1,0,2,3,4]
输出: 4
解释:
我们可以把它分成两块，例如 [1, 0], [2, 3, 4]。
然而，分成 [1, 0], [2], [3], [4] 可以得到最多的块数。
```



## **注意:**

- `arr` 的长度在 `[1, 10]` 之间。
- `arr[i]`是 `[0, 1, ..., arr.length - 1]`的一种排列。





## 方法①、边遍历边更新最大值



### 实现思路

```java
	O（n）解法
    有点像跳跃游戏的做法
    比如 [4,3,2,1,0]
    	我们最开始遇到 4，那么意味着当前位置 必须到 4 号索引 才能划分为一块
    比如 [1,0,2,3,4]
        我们最开始最大值为 1，那么我们需要到 1 号位置才能划分为一块，那么 [1, 0] 划分为一块
        然后最大值为 2，到 2 号位置划分为一块，即 [2] 
    	3 和 4 也是一样，总共 4 块
    比如 [1,2,3,4,5,0]，由于 0 位于最后的位置，那么意味从 0 号位置起就错乱了，首先最大值为 1
        遍历到 1 号位置，更新最大值 2，发现 (2 != 1)，因此继续遍历到 2 号位置，最大值为 3，发现 (3 != 2)
        继续遍历，知道最后最大值为 5 的时候遍历到 5 号位置，才划分为 1 块
```



### 实现代码

```java
class Solution {
    public int maxChunksToSorted(int[] arr) {
        
        int len = arr.length;
        int maxVal = -1;
        int c = 0;
        for(int i = 0; i < len; i++){
            maxVal = Math.max(maxVal, arr[i]);
            if(maxVal == i){
                c++;
            }
        }
        return c;
    }
}
```


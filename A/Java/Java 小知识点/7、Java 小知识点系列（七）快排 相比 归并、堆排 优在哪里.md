# 快排 相比 归并、堆排 优在哪里



快排、归并、堆排 的时间复杂度都是 O(nlogn)，但是我们需要知道，所谓的时间复杂度都只是一个大体上的一个预估值，忽略常熟以及更小的数量级，比如 O(n) 和 O(2n)、O(10n) 都称为 O(n)，当然这个时间复杂度不做考究，真正需要考究的是 硬盘和内存 方面的速度



快排 效率高的原因之一是 因为 快排的查找很好的利用了 磁盘局部性原理，而 堆排 并没有，因为它访问比较的是子节点，即 2 * i 和 2 * i + 1，这种显然跨度很大，当数据是百万级别的，那么这个 2 * i 就跨过了很大的数据量，无法使用到 磁盘局部性原理

快排 效率高的另外一个因素是 它是一个原地算法，在排序过程中不需要创建任何的辅助数组来保存临界值，这样就不需要 分配 和 回收 辅助数据的内存 和 将 原数组元素值 copy 到辅助数组上，而堆排则需要这样做



**当然，在数组上，快排基本比堆排、归并要快，但是在链表上，快排同样快，但却不是最优的**



因为在对链表排序的时候，快排的这些优点并没有体现出来，因为链表的节点内存地址是离散的，并不是跟数组一样的连续内存，因此 磁盘局部性原理 也就没有太大作用

同时，快排的原地算法 这个优点也没有太大的好处，因为链表是可以随时进行断开的，因此对链表进行 归并 的时候也不需要创建的辅助空间

因此，对链表排序的时候，快排同样快，但是归并更快，因为在相同条件下，归并会将链表均匀地分为两半，并且每次合并的工作要比 快排的分区要少

**因此，链表的最优排序算法是 归并算法**



```
以下是 某个国外大佬的原话：（经过翻译）

快速排序效率的主要来源之一是参考位置，在此优化了计算机硬件，因此访问彼此接近的内存位置往往比访问分散在整个内存中的内存位置要快。 快速排序中的分区步骤通常具有出色的局部性，因为它可以访问正面和背面附近的连续数组元素。 结果，快速排序往往比其他排序算法（例如堆排序）表现出更好的性能，尽管它经常进行大致相同数量的比较和交换，因为在堆排序的情况下，访问更加分散。


此外，快速排序通常比其他排序算法快得多，因为它可以在原地运行，而无需创建任何辅助数组来保存临时值。 与诸如合并排序之类的东西相比，这可能是一个巨大的优势，因为分配和取消分配辅助数组所需的时间可能很明显。 就地操作还可以改善quicksort的位置。


当使用链表时，这些优点都不是必需的。 由于链接列表单元经常散布在整个内存中，因此访问相邻的链接列表单元不会带来任何位置上的好处。 因此，Quicksort巨大的性能优势之一就被吞噬了。 同样，就地工作的好处不再适用，因为合并排序的链表算法不需要任何额外的辅助存储空间。


也就是说，快速排序在链表上仍然非常快。 合并排序只会趋于更快，因为它可以将列表更均匀地分成两半，并且每次执行合并的工作要比分区步骤少。
```


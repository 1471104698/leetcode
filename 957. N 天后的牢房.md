## **[957. N 天后的牢房](https://leetcode-cn.com/problems/prison-cells-after-n-days/)**

```java
8 间牢房排成一排，每间牢房不是有人住就是空着。

每天，无论牢房是被占用或空置，都会根据以下规则进行更改：

如果一间牢房的两个相邻的房间都被占用或都是空的，那么该牢房就会被占用。
否则，它就会被空置。
（请注意，由于监狱中的牢房排成一行，所以行中的第一个和最后一个房间无法有两个相邻的房间。）

我们用以下方式描述监狱的当前状态：如果第 i 间牢房被占用，则 cell[i]==1，否则 cell[i]==0。

根据监狱的初始状态，在 N 天后返回监狱的状况（和上述 N 种变化）。


提示：
cells.length == 8
cells[i] 的值为 0 或 1 
1 <= N <= 10^9
```



## **示例 1：**

```java
输入：cells = [0,1,0,1,1,0,0,1], N = 7
输出：[0,0,1,1,0,0,0,0]
解释：
下表概述了监狱每天的状况：
Day 0: [0, 1, 0, 1, 1, 0, 0, 1]
Day 1: [0, 1, 1, 0, 0, 0, 0, 0]
Day 2: [0, 0, 0, 0, 1, 1, 1, 0]
Day 3: [0, 1, 1, 0, 0, 1, 0, 0]
Day 4: [0, 0, 0, 0, 0, 1, 0, 0]
Day 5: [0, 1, 1, 1, 0, 1, 0, 0]
Day 6: [0, 0, 1, 0, 1, 1, 0, 0]
Day 7: [0, 0, 1, 1, 0, 0, 0, 0]
```



## **示例 2：**

```java
输入：cells = [1,0,0,1,0,0,1,0], N = 1000000000
输出：[0,0,1,1,1,1,1,0]
```





## 方法①、暴力模拟（超时）

### 实现思路

```
直接一天一天模拟情况
```



### 实现代码

```java
class Solution {
    public int[] prisonAfterNDays(int[] cells, int N) {
        /*
            0 1 1 0 0 0 0 0
            直接进行模拟
        */
        int len = cells.length;
        while(N-- > 0){
            int[] arr = new int[len];
            for(int i = 1; i < len - 1; i++){
                if(cells[i - 1] == cells[i + 1]){
                    arr[i] = 1;
                }else{
                    arr[i] = 0;
                }
            }
            cells = arr;
        }
        return cells;
    }
}
```



## 方法②、寻找循环节

### 实现思路

```java
            有规律的进行模拟：
            由于 ceils 长度为 8，而且都是 0 和 1，那么就是二进制状态，最多只存在 2^8 = 256 种状态
            而 N 最大可以达到 10^9，即必定会存在循环，那么我们就需要找到循环节，然后跳过循环的部分
            使用 map 记录每个状态出现的天数，当下次出现相同的状态时，那么循环节即为上次出现的天数 - 当天天数

            记录状态可以使用 一个 int 型变量，也可以直接将 数组转换为字符串存储 作为 key
```



### 实现代码

```java
class Solution {
    public int[] prisonAfterNDays(int[] cells, int N) {

        Map<Integer, Integer> map = new HashMap<>();

        //将数组转换为二进制变量
        int b = 0;
        for(int i = 0; i < 8; i++){
            b |= cells[i] << i;
        }

        while(N > 0){
            if(map.containsKey(b)){
                int cyclic = map.get(b) - N;
                N %= cyclic;
                if(N == 0){
                    break;
                }
            }
            map.put(b, N);
            N--;
            b = getNextState(b);
        }
        //将二进制转换为数组
        int[] res = new int[8];
        for(int i = 0; i < 8; i++){
            if((b & (1 << i)) != 0){
                res[i] = 1;
            }
        }
        return res;
    }

    private int getNextState(int b){
        int res = 0;
        for(int i = 1; i < 7; i++){
            //注意：b & (1 << i + 1)) == (b & (1 << i - 1))，这个是错误，因为如果都不为 0，但是 1 的位置不同，值也不会相同
            if(((b >> i - 1) & 1) == ((b >> i + 1) & 1)){
                res |= 1 << i;
            }
        }
        return res;
    }
}
```


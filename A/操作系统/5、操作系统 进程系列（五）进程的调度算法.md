# 进程的调度算法

## 1、先来先服务算法（短的会等长的）

最先来的先执行，在没有执行完成前，不会切换 CPU 



优点：

- 减少切换的开销
- 公平

缺点：

- 一个只需要 10ms 完成的 任务在 需要 1000ms 完成的任务后面到来，这样这个任务明明只需要 10ms 的时间这时候却需要 1010ms，而如果调换过来让这个 短任务先执行，长任务最多也只需要等待 10ms 而已

适用场景：队列中的任务耗时都差不多的场景



## 2、短作业优先（长的会等短的，饥饿）

按照任务完成时长的长短进行排序，短的优先执行，这个任务的特点是需要提前知道所有任务的耗时才能进行排序，这里的时间长短是完成任务还需要的时间来算的，比如现在在执行一个 1 小时的任务，还剩 10s，而这时来了一个 1min 的任务，它还是会继续执行 1 小时的任务，因为它只需要 10s 就能完成



优点；

- 平均等待时间短，因为跟上面的 FIFO 算法比，把能够先完成的任务先完成了，这样就不会出现上面的 10ms 的任务需要等待 1000ms 的情况了

缺点：

- 耗时短的任务可能源源不断，而耗时长的任务得不到调度，**造成饥饿**
- 频繁的任务切换，需要多次切换进程上下文，开销大

适用场景：几乎无适用场景



## 3、时间片轮转算法（频繁切换上下文）

确定一个固定的时间片，每个任务调度的时间片是相同的，当时间片用完时，如果任务完成了，那么出队，如果任务还没完成，那么进入到队尾继续排队，当然，如果一个任务完成不需要一整个时间片，那么也会提前结束的、



优点：

- 每个任务都能得到公平的调度，不会出现上面的短任务等待时间长 以及 长任务饥饿 现象

缺点：

- 频繁的切换 任务，需要多次切换进程上下文，开销大
- 时间片不好设置（设置短了，频繁切换，设置长了，可能退还成 FIFO）

适用场景：队列中任务耗时差不多





## 4、多级反馈队列（较公平）

兼顾了响应时间、调度开销低、避免饥饿问题、公平，在 windows、Linux 中都有使用



分为多个 level，每个 level 对应一个队列，从上到下优先级由高到低，时间片越来越长

位于高优先级的任务可以抢占低优先级的任务

最开始新任务位于最高位置的 队列，分配给它一个时间片，如果在这个时间片内完成任务，那么直接出队，如果没有完成任务，那么进入到下一个 level 的队列中，且分配的时间片比上一级的长一倍

只有当第 1 级的队列为空时，才会调度第 2 级的队列。。。

虽然对于长任务来说，一下子解决不了，需要等待的时间变长，但是分配的时间片也变长了

![img](https://pic4.zhimg.com/80/v2-8a100f3d3e2ba0d97b164b685b5ed394_720w.jpg)





但是，如果在极端情况下，新任务不断进入，那么下面队列中的任务就会导致饥饿，当然几率小



## 5、CFS （完全公平调度算法）

具体看  https://www.jianshu.com/p/673c9e4817a8 



> 故事背景

在CFS算法引入之前，Linux使用过几种不同的调度算法，一开始的调度器是复杂度为O(n)的始调度算法(实际上每次会遍历所有任务，所以复杂度为O(n)), 这个算法的缺点是当内核中有很多任务时，调度器本身就会耗费不少时间，所以，从linux2.5开始引入赫赫有名的O(1)调度器，然而，linux是集全球很多程序员的聪明才智而发展起来的超级内核，没有最好，只有更好，在O(1)调度器风光了没几天就又被另一个更优秀的调度器取代了，它就是CFS调度器Completely Fair Scheduler. 这个也是在2.6内核中引入的，具体为2.6.23，即从此版本开始，内核使用CFS作为它的默认调度器，O(1)调度器被抛弃了。

```
O(n)调度：每次调度都需要遍历一遍就绪队列上所有的进程，选出优先级最高的进程进行调度，时间复杂度为O(n)
O(1)调度：其基本思想是根据进程的优先级进行调度。进程有两个优先级,一个是静态优先级,一个是动态优先级.静态优先级是用来计算进程运行的时间片长度的,动态优先级是在调度器进行调度时用到的,调度器每次都选取动态优先级最高的进程运行.由于其数据结构设计上采用了一个优先级数组，这样在选择最优进程时时间复杂度为O(1)，所以被称为O(1)调度。
```



CFS 不是通过进程的优先级来判断进程的运行顺序的，而是通过计算 进程已经消耗的 CPU 时间来确定的

- **绝对公平：**将 CPU 作为一个资源，记录每个进程已经使用的资源情况，每次调用的时候都选择消耗资源最少的进程进行调度，即让之前占用 CPU 时间少的进程先执行，保证了公平性。但是在很多时候，有些进程的任务比其他进程的任务更加重要，需要提前执行，即权重（跟优先级差不多，但不是优先级）不同，因此我们还希望能够综合权重来进行  CPU 分配

- **相对公平：**根据各个进程的权重进行 CPU 资源分配，公式如下：

  ```
  分配给进程的运行时间 = 调度周期 * 进程权重 / 所有进程权重之和 
  其中 调度周期 为将处于 运行状态的进程全部调度一遍的时间
  ```

  比如系统中只两个进程A, B，权重分别为1和2，假设调度周期设为30ms，那么分配给A的CPU时间为:30ms * (1/(1+2)) = 10ms；而B的CPU时间为：30ms * (2/(1+2)) = 20ms。那么在这30ms中A将运行10ms，B将运行20ms。



Linux 在 CFS 实现上引入了 vruntime（虚拟运行时间）来实现相对公平，vruntime 的计算公式如下：

```
vruntime = 实际运行时间 * 1024 / 进程权重 
```

(这里的进程权重如何得到的下面再讲)

我们可以看出，vruntime 受到两个因素的影响：该进程已经占用的 CPU 时间 和 该进程的权重

同时，如果进程的权重越大、已经占用的 CPU 时间越少，那么 vruntime 越小

而 vruntime 越小，表示该进程越可能会被调度，这个就很容易理解了，CFS 实际上就让 各个进程的 vruntime 互相追赶，让每个进程的 vruntime 尽可能的达到平衡，让 vruntime 小的进程先执行，使得它的 vruntime 变大

同时，权重越大的，vruntime 增加越慢，这样它也就有了更多的 CPU 运行时间，可以将这些重要的进程先处理掉



而 Linux 实现 CFS 的底层数据结构是一棵红黑树，以 vruntime 作为排序节点，这样 vruntime 小的就在左子树，只需要 O(logn) 的时间就能够获取到需要进行调度的进程了

红黑树节点上的进程是就绪状态等待调度的，当某个进程执行 IO 操作的时候会从红黑树上删除，等到完成 IO 操作后才会重新放到红黑树上

 ![img](https://pic4.zhimg.com/80/v2-d5580bfcf145ba594295e22525e09933_720w.jpg)

 

权重 nice 是根据优先级进行转换的，LInux 内部维护了一张 nice 级别表：

```C++
nice值共有40个，与权重之间，每一个nice值相差10%左右。
static const int prio_to_weight[40] = {
    /* -20 */ 88761, 71755, 56483, 46273, 36291,
    /* -15 */ 29154, 23254, 18705, 14949, 11916,
    /* -10 */ 9548, 7620, 6100, 4904, 3906,
    /* -5 */ 3121, 2501, 1991, 1586, 1277,
    /* 0 */ 1024, 820, 655, 526, 423,
    /* 5 */ 335, 272, 215, 172, 137,
    /* 10 */ 110, 87, 70, 56, 45,
    /* 15 */ 36, 29, 23, 18, 15,
};
```

nice 级别为 [-20, 19]，nice 级别越小，意味着 nice 值越大，那么根据公式计算出来的 vruntime 越小，得到的 CPU 时间片越多

nice 级别为正的低优先级，为负的高优先级



比如从 nice0 升级为 nice1，由于对应的权重值变小了 10%，那么该进程的 vruntime 增加了 10%，相当于是 CPU 时间片缩小了 10%

​	从 nice1 升级为 nice0，由于对应的权重值增加了 10%，那么该进程的 vruntime 缩小了 10%，相当于是 CPU 时间片增加了 10%

默认情况下所有进程的权重都为 0
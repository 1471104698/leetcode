## MVCC

具体看  [https://blog.csdn.net/Waves___/article/details/105295060#1.2%E3%80%81Read%20View%20%E7%BB%93%E6%9E%84](https://blog.csdn.net/Waves___/article/details/105295060#1.2、Read View 结构) 



### 1、MVCC 出现的原因

MVCC 是不加锁的，最开始的 mysql 使用原生锁，相当于 java  的 syn 锁，一次只能够一个事务，相当于上面的 串行

但是这样效率很低，而且很多情况下是读多写少，因此出现了读写锁，读锁和读锁之间共存，写锁和写锁 、写锁和读锁 之间互斥

这样提高了并发能力，但是发现还不够，还要提高并发能力，让读写什么的都可以同时进行。

因此出现了 MVCC，**MVCC 只能在 读已提交 和 可重复读 两种隔离级别下进行**

```java
因为 读未提交 基本就是没有隔离，不管了的，而 串行 就是那种加了重量级锁的，两种都是不同方面的极端
```



**引入了 MVCC 之后，只有 写和写 会阻塞，其他的都能够并行操作**



**MVCC 实现：隐藏字段 + ReadView（快照） + undo log**

InnoDB 在表中的每行数据后都会添加 3 个 隐藏字段：

- **DB_TRX_ID**：记录最近一次对 当前数据行 做修改的事务 id，对于 delete 操作，同样认为是update，不过修改的是删除标志位
- **DB_ROLL_PTR**：回滚指针，看上面的 undo log 图，类似链表形式，用于回滚
- **DB_ROW_ID**：当没有主键或者唯一非空索引的时候，使用的就是这个 id，**这个跟 MVCC 没什么关系**

**通过 undo log 可以找到之前的事务旧数据**

**通过 ReadView 可以确定对于当前事务而言哪些事务是可见的**



### 2、ReadView

**RC 读 和 RR 读的区别就在于生成 ReadView 的策略不同**



ReadView 有 3 个重要字段 ：

- **low_limit_id**：当前 RV 创建时出现过的最大的事务 ID + 1，即下一个将被分配的事务 ID（不是已提交事务的最大ID）
- **up_limit_id**：当前 RV 创建时在活跃事务表 trx_ids 中最小的事务 id
- **trx_ids：**RV 创建时其他未提交的事务 id 集合列表，对持有 RV 的事物来说，它的 id 不会在 trx_ids 中



### 3、可见性算法

当 id = 11 的事务 select 某个数据行的时候，会创建一个 RV，而所有的事务 id 如下：

1	2	3	4	5	6	7	8	9	10	11	12	13	

其中有各个 id 对应的状态如下：

已提交事务 id：[1，2，3，4，7，9，12，13]

未提交事务 id：[5，6，8，10]（因为持有该 RV 的事务 id 不会在 trx_ids 中，因此忽略 11）

这样的话，low_limit_id = 14，up_limit_id = 5

此时 RV 上的数据就已经是固定了的，这就是快照，仅仅记录某个瞬间的数据，对于此刻的 id 11 事务来说，所有的事务就是这个状态

获取读取的数据行上的 trx_id，进行比较

- 1、如果 trx_id < up_limit_id，表示该数据是在当前事务创建 RV 前就已经提交的了，那么对该事务来说是可见的，跳到步骤 5
- 2、如果 trx_id >= low_limit_id ，表示该数据是在 创建 RV 后才提交的，那么跳到步骤 4
- 3、如果 up_limit_id <= trx_id < low_limit_id ，那么表示创建 RV 的时候，这个数据可能是已经提交了的，或者提交这个数据的事务还在活跃中（即在 trx_ids 中），因此直接使用二分查找判断是否在 trx_ids 中
  - 如果不在，表示对该事务可见，跳到步骤 5
  - 如果在，表示当时那个事务当时还没有把它提交上去，因此对该事务不可见，跳到步骤 4

4、获取读取的数据行的` db_roll_ptr `指针，得到对应的 undo log 链的下一个数据版本，获取对应的 trx_id，然后重新回到上面进行判断

5、找到可见值，那么结束了



### 4、当前读 和 快照读

快照读：普通的 select，每次调用 select 都会产生一个 RV 快照，这时候能够防止不可重复读和幻读，因为后续事务的数据新版本不会被读到

当前读：select...for share、select ... for update、 update、insert、delete 这种都是当前读，每次获取的是 数据行的最新数据，不会涉及到 RV 和 undo log

如果只靠 MVCC ，能够解决不可重复读 的问题，只能解决部分 幻读 的问题，而不能完全解决幻读

```
比如事务 A 开始，执行普通的 select 语句，这时候会创建一个快照，然后事务 B 执行 insert 操作
如果事务 A 再次执行 普通 select，那么就不会看到 事务 B insert 进去的数据，能够解决幻读
如果事务 A 再次执行的是 select...for update，那么会看到最新的数据，导致幻读
```

因此， 只靠 MVCC 无法解决 当前读 的幻读问题

因此， RR 级别下，会对当前读的 数据行 加上 行锁 和 间隙锁，即 使用 NK 锁 + MVCC 完全解决幻读问题



### 5、RR 解决不可重复读 和 幻读

具体看   https://www.zhihu.com/question/372905832/answer/1106544250 



RR 级别是只有在第一次快照读的时候生成 ReadView，后续的快照读都是使用的这个 ReadView，而当前读仍然会创建新的 ReadView，但是并不会覆盖掉第一个 ReadView，后续的快照读仍然是用的第一个 ReadView，因此这样就避免了不可重复读以及幻读

**MVCC 解决的是在快照读的情况下的 不可重复读 和 幻读**



假设有以下情况：

- 事务 A 执行 select * from t1 的快照读，读出了 2 条数据
- 事务 B 执行 insert t1 (id, a) values (10, 3) 的写操作，然后 commit;
- 事务 A 再执行 select * from t1 for update 的当前读

在最后事务 A 执行 当前读的时候，它会读到多少条数据？？？

答案是 3 条；因为当前读是生成新的 ReadView 的，因此它能够看到 新提交的数据修改、删除、插入，意味着不可重复读 和 幻读 还是存在



**那么 Mysql 所谓的解决 不可重复读 和 幻读 是 什么意思呢？**

是在事务过程中，在最先开始执行了 当前读 或者 写操作，这样就加上了 NK 锁，别的事务无法更改插入删除这些数据，因此防止了 不可重复读 和 幻读



**这表示什么？**

RR 级别下 ，使用 MVCC 解决快照读的不可重复读 和 幻读，使用 NK 锁解决两次 当前读 或者 写操作 间产生的 不可重复读 和 幻读

如果是先一次快照读，然后中间被别的事务修改了，再执行一次 当前读，那么还是会出现不可重复读和幻读


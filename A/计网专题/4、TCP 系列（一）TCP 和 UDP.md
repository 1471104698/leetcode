# TCP 和 UDP



## 1、TCP 的报文头部

具体看  https://blog.csdn.net/wujingjing_crystal/article/details/52305523 



 ![这里写图片描述](https://img-blog.csdn.net/20170324221213371?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveXRodW5kZXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

TCP 头部长度不包括选项为 20字节，而选项最大为 40 字节，因此 TCP 头部长度最大为 60字节

- 头部长度：TCP 报文头部长度，最小是 20 字节
- 源端口
- 目的端口
- 校验和
- 序列号
- 确认号
- 6 位标志位：SYN、ACK、FIN、RST、PSH、URG
- 滑动窗口大小：默认 16bit
- 紧急指针：跟 URG 包配合使用，该数据是偏移量，表示 URG 包数据的最后一个字节位置
- 选项：
  - MSS 值
  - 窗口扩大：用来扩大滑动窗口，滑动窗口最大默认只有 16 bit，这个选项可以将窗口扩大为 32 bit
  - 时间戳：根据时间戳 计算 报文往返时间 RTT，可用于超时重传设置超时时间 RTO 的设置基准

> ###  序列号

发送方和接收方都会初始化一个 **随机序列号 ISN**（客户端和服务端都可以是发送方）

**序列号** 的作用：

- 让 TCP 接收方将无序的数据按照序列号进行拼接
- 将 TCP 发送方由于超时发送的重复数据去重



**为什么序列号需要随机？**

为了防止 TCP 预测攻击，防止第三方发送一个 序列号符合预期的包，但是内容是伪造的，因为如果你不加序列号，那么数据包都是从 0 开始的，而加了随机序列号 ISN，数据包就是从 ISN 开始的了，而 ISN 是 0 ~ 2^32 尽头再循环，攻击者难以预测这个 ISN



> ### 标志位：

对应类型的报文的标志位置为 1

- *ACK*：确认应答，TCP 规定除了最初建立连接时的 `SYN` 包之外该位必须设置为 `1`** 
- *RST*：表示 中断异常，如果已经连接那么要断开连接
- *SYC*：表示建立连接，并在其「序列号」的字段进行序列号初始值的设定。
- *FIN*：表示断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 `FIN` 位置为 1 的 TCP 段。
- PSH：PSH 即 "PUSH"，即推送，有时候希望输入一个命令后就能收到对方的回应，因此这时候可以将 TCP 的 PSH 位置 1，这样的话 TCP 接收区就不会等待 缓冲区满了，而是直接告知应用程序处理
- URG：表示有紧急数据要传送，该包具有最高优先级，因此会放在数据的最前面，比如当某个程序在远处主机运行的时候，我们发现了问题，想要中断这个程序，因此就发送一个 URG 包，当存在 URG 包时，会将这个 URG 包放在缓冲区的最前面，这样应用程序就可以优先处理；URG 包后面的是普通数据，URG 包的最后一个字节是由 紧急指针 来记录的



## 2、UDP 的报文头部

 ![这里写图片描述](https://img-blog.csdn.net/20171109193828215?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvREJfd2F0ZXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast) 

UDP 报文头部长度为 8 字节

- 源端口号
- 目的端口号
- UDP 报文长度
- 校验和

**UDP 头部字段中没有头部长度，因此 UDP 的头部长度固定是 8字节，而 TCP 有头部长度是因为 TCP 有个 "选项"字段，所以头部长度不固定**



## 3、TCP 和 UDP 区别

TCP：

- 面向连接：进行数据传输需要进行三次握手确保安全连接，后续断开需要 四次挥手
- 基于字节流：从报文头部可以看出，TCP 中没有记录 TCP 的报文长度，也就意味着不知道数据的长度，那么就会跟其他的 TCP 报文数据混在一起，这也就是因为 TCP 是字节流的，它没将数据当作一个报文一个报文来看待，而是当作将一个字节流的数据分为多次发送而已
- 可分片：由于 TCP 存在序列号，所以分片后的数据能够按照序列号重新进行有序拼接
- 可靠性传输：拥有重传机制、滑动窗口、流量控制、拥塞控制
- 一对一：跟谁连接就只能使用该连接跟谁发送数据
- TCP 头部报文复杂

UDP：

- 无连接：UDP 不使用连接的形式，想发给谁就发给谁，发出去了不管对方接不接收，反正发就完事了
- 基于报文：UDP 首部有 UDP 报文长度，意味着记录了 UDP 的数据长度，这就跟别的 UDP 数据划分开了；当应用层获取数据的时候，一次都是获取一个报文，如果一次不能将一个 UDP 报文的数据给全部获取，那么剩下的 UDP 数据会直接舍弃
- 不能分片：由于 UDP 没有序列号机制，所以分片后的数据无法进行有序拼接，因此不支持分片，如果遇到 UDP 数据大于 MTU 的，那么 UDP 报文直接丢弃
- 不可靠性传输：不能保证数据一定发送到对方手里，并且不会理会网络是否拥堵，发送速率一直不变
- 一对一、一对多、多对多：由于不存在连接一说，想发就发，因此现在可以发给 A，待会可以发给 B
- UDP 头部报文简单



TCP 强制过重的可靠性传输，TCP 会把数据缓存起来，等到收到前面发送的包后才会继续发送，如果前面的包的 ACK 一直收不到，那么延迟会越来越大

类似游戏这种对实时性要求严格的情况下，选择使用 UDP ，如果要求可靠性，那么可以在应用层实现可靠性传输 - 重传机制，这样能够把丢包产生的延迟降到最低，尽量减少网络问题对游戏造成影响

比如 cs go 这种射击游戏，对方给自己扔手雷，对于自己来说，是能看到爆炸效果和声音的，但是对于远处的队友来说，他能听到的就是声音，并且他主要是注意在自己打出的子弹上，注意的是眼前的敌人，如果使用 TCP 传输给队友的手雷爆炸声音的包丢失了而一直重传，这样提高了队友的延迟，明显是会影响队友的游戏体验





## 4、TCP 粘包



> ### TCP 为什么会发生粘包？

首先，我们要知道，TCP 是基于字节流的，本身没有数据包（报文段）的概念，数据包只是作为传输过程中字节数组的载体

**而也恰恰正是因为 TCP 是基于字节流的，才会导致粘包问题，因为数据没有边界**



一个字节流数据分为了 1 2 3 4 这四个数据段，将它们封装在数据包中，然后按照顺序进行发送

TCP 是有缓存的，发送方是看滑动窗口中能够发送多少字节，就将对应长度的字节数据 封装进数据包中发送出去

接收方是将发送过来的数据包中的数据拆分，然后放入到缓存中，这样就消去了包的概念，只剩下字节的概念了

这样，当接收方接收到一个数据包，假设长度为 10 个字节，放进缓存中，而用户没有调用 read() 进行处理，当第二个数组包到达，假设为 20个字节，接收方拆分后再放到缓存中，这样由于是字节的形式，不存在边界，用户调用 read(buff, 15)，这样就用到了第一个包的全部数据，以及第二个包的前 5 个字节，发生了粘包



> ### 发生粘包、拆包的情况



**1、应用层数据过大，无法一次发送**

如果应用层的数据超过滑动窗口的缓存大小，那么消息会被进行分割，导致拆包

当发送了一部分后，另一部分进入缓存中，而后面又加入了新的数据，导致这后半部分数据跟新的数据一起发送出去，导致粘包



**2、接收方处理不及时**

这个就是上面讲的 TCP 为什么会发生粘包问题的例子，接受方处理不及时，发送方的缓存区缓存了多个报文



**3、MUT / MSS 分片**

MTU 是链路层中以太网对传输数据大小的限制

从 传输层出发，封装成 TCP 报文，再到网络层，封装成 IP 报文，再到 链路层，所以到达链路层时是 IP 报文，即 MTU 是限制 IP 报文大小的

而一个 IP  报文包括 IP 头部、TCP 头部、字节数据

因此真正可传输的数据为 MTU - IP 头部大小 - TCP 头部大小，这部分数据称为 MSS，即 TCP 最大可发送数据

当 发送方缓存中的数据大小超过 MSS 时，那么就会进行分片，这样就会导致拆包



**4、TCP 默认使用的 Nagle 算法**

无论发送多少数据，到达 链路层都是 IP 报文，都会存在 IP 头部 和 TCP 头部

这样即使从键盘输入 1 个字节，发送出去，那么到达 链路层就是 41 个字节，其中 1 个字节是真正的数据，40 个字节分别是 IP 头部 和 TCP 头部，这种情况对于网络来说是完全不值得的，为了 1 个字节的数据竟然额外占用了网络 40 个字节的带宽

因此，TCP 的 Nagle 算法 就是为了避免网络中充斥着许多这种小块数据，因此它制定了以下规则：

- 它会等待缓存中的数据长度到达 MSS，然后再进行发送，**导致粘包**
- 当包是 FIN 时，那么直接发送
- 如果没有打到 MSS 也没有 FIN 包，那么到达一定时间（一般为 200ms）会进行发送



> ### 粘包、拆包问题解决

- TCP 头部添加报文长度
- 报文设置固定长度

- 在一个数据的尾部加上结束符，比如 \n\r，这样接收方可以根据结束符进行分割

- 关闭 Nagle 算法



## 5、UDP 在应用层实现可靠性传输

由于 TCP 过于繁重，而如今网络发展对于实时性要求很高，因此 TCP 的繁重机制 慢慢的不再适用

却而代之的是 UDP，但是由于 UDP 没有重传机制之类的，所以在网络环境差的情况下会经常丢包，因此需要实现它的可靠性传输

可靠性传输传输在应用程序层面实现，而不再跟 TCP 一样依托于 操作系统 和 内核，这样扩展性更好



对于 UDP 丢包，存在两种常用的 丢包处理策略：**ARQ（丢包重传）和 FEC（前向纠错）**


# mysql 主键自增 id



[mysql 主键自增博客]( https://blog.csdn.net/qq_40378034/article/details/90736544 )

## 1、为什么需要主键自增

假设 id 是主键

由于 B+ 树中 聚簇索引的各个节点是按照 id 进行排序的，那么如果我们分别插入 id = 1 3 5 6 7 8

而 1 3 5 成一个节点， 6 7 8 成一个节点， 如果我们这时候再插入 id = 4，那么就会将 5 给挤出来，造成数据页分裂，变成 1 3 4

而 5 会进入到第二个节点中，将 8 给挤出来，造成第二次数据页分裂，变成 5 6 7，而 8 会再单独再开一个数据页

增加了索引的维护成本

因此如果主键自增插入的话，不会对前面的数据页造成太大的影响



## 2、自增值的保存位置

- mysiam 保存在数据文件中，即使用了持久化
- InnoDB 
  - 在 mysql 8.0 之前的版本保存在内存当中，没有进行持久化，那么每次关机都会造成自增值丢失，第一次打开表的时候，会读取 表中最大的 id，然后 +1 作为自增值，这意味 自增值是会发生改变的，举例来说，如果插入了 id = 10 的数据，这时自增值为 11，而后面又删除了 id = 10 的数据，然后关机了，重启打开表后查找最大 id = 9，那么自增值又会变成 10 了
  - mysql 8.0 将自增值的变更记录在了 redo log，完成了持久化，重启直接读取 redo log 获取自增值



## 3、自增值的修改

> ### 自增值修改的策略

假设当前表的自增值 为 AUTO_INCREMENT，当我们插入一条数据的时候：

- 如果指定的 id = 0 或者 未指定值，那么就会把记录的自增值赋值给这个数据行的 id，然后 自增值 +1

- 如果指定了具体的 id

  - 如果 id <  AUTO_INCREMENT ，那么 自增值 不变

  - 如果 id >=  AUTO_INCREMENT ，那么需要修改为新的自增值，新的自增值修改算法为： **从auto_increment_offset（初始值）开始，以 auto_increment_increment（步长）为步长，持续叠加，直到找到第一个大于 id 的值，作为新的自增值** ，即 

    ```C
    int new_id = auto_increment_offset;
    while(new_id < id){
    	new_id += auto_increment_increment;
    }
    ```

    



> ### 自增值修改的时机

先举个例子：

假设数据库中存在以下数据，id 为主键，c 为唯一索引，自增值为 6

我们再插入一条数据 (id,c,d) = (null,5,1)，由于 c 为唯一索引，所以会插入失败

![img](https://img-blog.csdnimg.cn/20190612222922279.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly95YW5nd2VucWlhbmcuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70)



我们再插入一条数据 (id,c,d) = (null,6,1)，插入成功，但是这时候这条数据行的 id 为 7

![img](https://img-blog.csdnimg.cn/20190612223036885.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly95YW5nd2VucWlhbmcuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70)



为什么 id 会是 7.，而不是自增值 6 呢？



这里涉及到自增值的修改时机：

在上面表中，插入 (null, 5,1) 的时候，语句执行的流程如下：

- InnoDB 获取数据 (null,5,1)，发现没有指定 id 的值，获取当前的自增值
- 将自增值 6 赋值给 id，数据变成 (6,5,1)，自增值 +1 变成 7
- 执行插入操作，发现 c 是唯一索引，插入失败，直接返回

我们可以看出，插入前就已经执行了 自增值 +1，但是**失败后并没有将自增值回退**，所以导致下一条数据插入时 id = 7 而跳过了 6



> ### 为什么自增值设置为 不回退



假设 自增值可以回退，这时存在两个事务 A 和 B 都执行插入操作

- A 获取了 id = 2，B 获取了 id = 3，这时自增值为 4（注意，这里获取必定是原子获取，使用 CAS 之类的）

- 事务 B commit 了，而 事务 A 由于插入 的数据中存在类似 c 这种唯一索引冲突，插入失败
- 如果允许事务 A 把自增值回退，那么这时候 把自增值回退成了 2，那么就会出现这种情况，自增值为 2，但是表中存在事务 B 插入的 id = 3 的数据，那么事务 C 获取 id = 3，发现主键冲突，插入不成功，这就很迷

当然，这也是有解决方法的，在插入前扫描整个表，获取整个表的 最大 id，然后将当前行 id 设置为 id + 1，但这样成本太大了，插入一次就扫描一遍表，太迷

因此 InnoDB 放弃了 自增值 回退的设置



**唯一键冲突 和 事务回滚 都会导致 自增主键不连续**，因为执行插入操作失败但又不会回退自增值





## 4、自增 ID 到达最大会发生什么事

主键 id 默认为 无符号 int，上限为 2^32 - 1，即 4294967295

如果自增 id 到达 4294967295，那么它就不会再继续自增，因为再自增就会溢出变成 0，因此**策略是保持不变**

那么下一条插入的数据的自增 id 也会是 4294967295，这时候就会造成主键冲突，插入失败

```
Duplicate entry '4294967295' for key 'PRIMARY'
```



当然，一般情况下 4294967295 也够用了



如果在分布式情况下进行**分库**分表，那么这时候就不能使用数据库自己提供的自增 ID，而是要自己使用分布式高并发的唯一 id，比如之前有点印象的雪花 id 生成器吧

（注意区分 row_id 和 自增 id，row_id 是一个数据库的 InnoDB 表共用一个，自增 id 是一个表一个）
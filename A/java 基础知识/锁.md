# 锁

## 1、乐观锁和悲观锁



> 乐观锁 和 悲观锁 的概念



**悲观锁：**

将事物都想得很悲观，每个线程拿数据的时候都认为自己使用这个数据的期间别的线程都会进行修改，因此对这个数据加上锁，对别的线程进行排斥，比如 mysql 的写锁、表锁、行锁， 以及 java 中的  synchronized 和 ReentrantLock 等独占锁都是悲观锁的实现

悲观锁适用于多写的环境，因为这样才保证每次只有一个线程在修改，确保了数据的准确性



**乐观锁：**

将事物都想得很乐观，每个线程获取数据的时候都认为别人不会修改，因此不会对数据加锁，只会在写数据的时候判断数据是否被修改过，像 数据库中的 加个字段的版本控制 和 另一种 CAS 算法 都是乐观锁的实现，而 java 中 `AtomicIntger` 等原子类就是 volatile 修饰的 int 变量 + CAS

乐观锁不会对数据加锁，因此可以存在多个线程同时修改的情况，如果一直存在冲突，比如存在 n 个线程同时修改同个数据，那么最终只有一个线程会修改成功，其他的线程都需要进行自旋，获取最新的版本号进行重试，每次只有一个线程成功，效率过低

因此乐观锁适用于多读的情况



> 乐观锁的两种实现



这里需要说下，乐观锁在冲突的情况下，都需要进行自旋重试（重新获取版本号之类的，然后重新提交自己更新的数据）



**版本号控制：**

像 mysql 中同个给表添加一个 `version` 字段来代替 行锁 之类的悲观锁

当事务 A 和 事务 B 同时修改某个数据，而这个数据的初始版本号是 1 ，当事务 A 修改完率先提交，将版本号修改为 2，那么当事务 B 提交的时候，发现该数据的版本号跟自己持有的数据版本号不一样，那么就意味着被其他事务修改过了，那么就需要重新获取版本号来进行修改



**CAS 算法：**

CAS 即 compare And Swap（比较和交换）

它需要 3 个值：内存值 V，线程保存的旧值 A，需要写入的新值 B

其实跟 版本号控制差不多，感觉版本号控制就是 CAS 的一种实现，不过别人分出来了就不管了

**过程：**

假设存在一个变量 x，当线程 1 获取这个 x 的值保存为 A ，然后经过一系列的处理，需要将这个 变量 x 该为 值 B

这时候不能直接写入内存，而是需要比较 内存中 变量 x 的值 V 与之前获取它的时候的值 A 是否一致，如果一致，表示没有被其他线程修改过（其实不一定，这是 ABA 问题），可以直接将 x 更新为 B，如果不一致，那么就表示被其他线程修改过了，那么通过自旋不断重试



**CAS 的缺点：**

- 存在 ABA 问题
- 在存在冲突的情况下会自旋重试，而自旋的时候是不会主动放弃 CPU 的，那么当存在多个线程冲突的时候，CPU 效率低得一批



> 什么是 ABA 问题？

比如 线程 1  和 线程 2 同时要修改某个变量 x，当然，这是并发的，有先后顺序的，线程1 先被 CPU 调用，将 x 的值从 A 变成了 B，然后这时插进来 线程 3，CPU 没去调用线程 2，而是调用了 线程 3，而线程 3 将 x 的值 重新修改为 A，这时候 CPU 调用线程 2，线程 2 发现 x 在内存中的值 V 跟自己保存的旧值一样都是 A，那么感觉没人修改过，那么直接将 自己的新值 C 写入内存中

但实际上，在 线程 2 修改之前，就已经存在两个线程对变量 x 进行了修改，只是最终改回了原来的值，让线程 2 无法感知到它的变化

这就是 ABA 问题，表示从 A 修改为了 B，再从 B 修改回 A，这个中间过程不被感知



举个生活例子：

桌上有一杯水，它是满的，杯子的主人不在，当 人类 A 路过时，实在渴得不得了了，过来把它喝光了，然后就把空杯子放下走了

然后过来一个人类 B，发现杯子空了，很不爽，就把自己随身携带的水给杯子满上，然后就走了

当杯子的主人来的时候，看见杯子是满的，那么他不会想到有人喝了它的水再将它满上了，所以他放心地喝了

当然，他在他不知情的情况下，喝下了别人炙热的口水



> 如何 解决 ABA 问题？

通过添加一个版本号，（这就更像版本号控制那个了），之后的比较就不再是比较什么数据的内存值和旧值了，而是比较版本号了

上面的例子中，线程 1 修改了变量 x，将版本号 +1，之后线程  2 发现版本号不对，自然就感知到了 x 被修改过了，那么自旋重新修改



> ABA 问题有什么危害？

我们这么看老来，线程 1 修改了 x 值 从 A 变成 B，线程 3 又将 x 值从 B 变成 A，对于线程 2 来说，是需要将 x 值从 A 变成 C 的，那么这个 x 值最终是要变成 C 的，好像也没什么多大问题啊

这么看来是的，但是有的时候，这个中间态就可能产生不一样的影响，然而没有具体的例子，，，啧啧，这个 ABA 问题难点就在于没有一个实际的业务场景上的问题，有点理想化了



## 2、ReentrantLock（CAS + AQS）

ReentrantLock 使用了 CAS，我们上面说了 CAS  是乐观锁的一种实现，但这不意味着 ReentrantLock 就是乐观锁

因为i我们具体要看 ReentrantLock 到底是哪个地方用到了 CAS，并非用到了 CAS 就是乐观锁



**ReentrantLock 是一把悲观锁 和 可重入锁**，**同时也是 公平锁 和 非公平锁 的 实现**



### 2.1、ReentrantLock 的实现

------



**ReentrantLock 是一个可重入的悲观锁**

**ReentrantLock 通过 CAS + AQS 队列来实现**（AQS 队列 叫做 同步队列）



ReentrantLock 的实现可以简单描述为：

- ReentrantLock  内部维护了一个 volatile 修饰的 int 型变量 state
- 当 state == 0 时，表示还没有任何线程占有锁**（注意，这里的锁不是一个具象化的事物，而是根据 state 来判断的，只要 state 为 0 就当作是没有线程获得锁）**
- 当 state != 0 时，表示已经有线程获得锁
- 某个线程 使用 CAS 尝试获得锁时，如果 state 为 0，那么可以获得锁，并将 state +1，将锁的拥有者线程设置为自己
- 其他线程来尝试获取锁的时候，发现 state 不为 0，那么就会进入 AQS 队列进行等待，处于 挂起状态，CPU 不会在它们身上浪费时间

根据执行流程我们就可以看出，ReentrantLock 是一把悲观锁，它会阻塞其他的线程，即它对某个共享资源加锁的时候，其他的线程无法去修改这个资源，而是需要阻塞等待获取锁，而它使用的 CAS 就是用来判断是否有线程获得锁而已

而我们最上面讲的 乐观锁的 CAS ，是多个线程可以获取 共享资源 ，并对共享资源进行修改，不过每次修改的只有一个会成功，因此会进行自旋



**ReentrantLock 是在获取锁的时候使用 CAS，会阻塞线程，线程会挂起，CPU 不会在它们身上浪费时间**

**而 乐观锁的 CAS 是在修改的时候发挥作用，线程会进行自旋，CPU 会它们身上直到它们调用成功**



### 2.2、公平锁 和 非公平锁、可重入锁

------



> 公平锁 和 非公平锁



公平锁是指多个线程同时获取一把锁，那么就是按照线程到达时间来分配锁的

非公平锁就是多个线程同时获取一把锁，在某个线程释放锁的时候，其他等待的线程没有获取锁，而是被中途插入的线程获取了锁



**synchronized 和 ReentrantLock 都是非公平锁，不过 ReentrantLock  可以设置为 公平锁**



> 可重入锁



一个线程 在没释放锁的时候可以多次获取同一把锁**

比如 线程 1 获取了锁，然后它调用的方法还需要这一把锁，那么这把锁可以同样给这个方法用，而无需再去竞争锁

这就是可重入锁



### 2.3、非公平锁 lock() 实现原理

------



我们前面说了，ReentrantLock 是一把公平锁和非公平锁，主要是体现在 lock() 和 unlock()



> 非公平锁 获取锁 代码



```java
final void lock() {
    
    if (compareAndSetState(0, 1)) //直接 CAS
        setExclusiveOwnerThread(Thread.currentThread());
    else
        //上面直接 CAS 失败
        acquire(1);
}

public final void acquire(int arg) {
    if (!tryAcquire(arg) &&
        //前面获取锁失败，这里将线程放入 AQS 队列
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}

final boolean tryAcquire(int acquires) {
    //获取当前线程
    final Thread current = Thread.currentThread();
    //获取state变量值
    int c = getState();
    if (c == 0) { //没有线程占用锁
        if (compareAndSetState(0, acquires)) {
            //占用锁成功,设置独占线程为当前线程
            setExclusiveOwnerThread(current);
            return true;
        }
    } else if (current == getExclusiveOwnerThread()) { //当前线程已经占用该锁
        int nextc = c + acquires;
        if (nextc < 0) // overflow
            throw new Error("Maximum lock count exceeded");
        // 更新state值为新的重入次数
        setState(nextc);
        return true;
    }
    //获取锁失败
    return false;
}
```



当 某个线程调用 lock() 尝试获取锁，会先直接 CAS 一次，失败了就调用`tryAcquire()` ，里面 获取 state 变量

如果 state == 0, 那么再次进行 CAS 一次，如果失败直接返回 false

如果 state != 0，那么判断占有锁的线程是否是当前请求的线程，如果是，那么 state +1，这就是可重入锁的原理



**我们可以发现：**

只要有线程尝试获取锁，那么直接进行 CAS 尝试获取锁

这就是非公平锁的体现，当线程 A 释放锁的时候，lock() 它没有去判断 AQS 队列中是否有线程等待，如果这时候中途插入的线程尝试获取锁调用 lock()，并且获取成功了，那么对于早在队列中等待的线程来说就不公平了，甚至如果高并发的情况下，可能出现饥渴现象



> 线程入队 AQS 代码



```java
/**
 * 初始化队列并且入队新节点
 */
private Node enq(final Node node) {
    //开始自旋
    for (;;) {
        Node t = tail;
        if (t == null) { // Must initialize
            // 如果tail为空,则新建一个head节点,并且tail指向head
            if (compareAndSetHead(new Node()))
                tail = head;
        } else {
            node.prev = t;
            // tail不为空,将新节点入队
            if (compareAndSetTail(t, node)) {
                t.next = node;
                return t;
            }
        }
    }
}
```



当线程 B 和 线程 C 都要入队时，由于是排在队尾，一次只能有一个线程入队成功，即每当一个线程入队成功， AQS 队尾元素就会更新入队成功的线程，所以需要进行 CAS + 自旋，直到所有线程入队成功

这里的 CAS 就是判断我们要入队的时候，队尾节点（内存值 V） 和 自己之前保存的队尾节点（旧值 A）是否一致，如果一致表示还没有被更新过，那么直接入队



### 2.4、非公平锁 unlock() 实现原理

------

```java
public void unlock() {
    sync.release(1);
}
  
public final boolean release(int arg) {
    if (tryRelease(arg)) {
        Node h = head;
        if (h != null && h.waitStatus != 0)
            unparkSuccessor(h);
        return true;
    }
    return false;
}

/**
 * 释放当前线程占用的锁
 * @param releases
 * @return 是否释放成功
 */
protected final boolean tryRelease(int releases) {
    // 计算释放后state值
    int c = getState() - releases;
    // 如果不是当前线程占用锁,那么抛出异常
    if (Thread.currentThread() != getExclusiveOwnerThread())
        throw new IllegalMonitorStateException();
    boolean free = false;
    if (c == 0) {
        // 锁被重入次数为0,表示释放成功
        free = true;
        // 清空独占线程
        setExclusiveOwnerThread(null);
    }
    // 更新state值
    setState(c);
    return free;
}
```



代码不难，当线程调用 unlock() 方法的时候，不会直接释放锁

由于 ReentrantLock 是一个可重入锁，因此当前线程的当前方法不一定是最后一个拥有锁的

当该线程的某个方法调用 unlock() 的时候，需要判断 state 减 1 后是否为 0

如果是，表示自己是最后一个拥有锁的，可以释放锁，同时将锁的拥有者线程设置为 null

如果不是，表示还有其他线程需要锁，所以不能释放锁



### 2.5、公平锁的 lock() 

------

其实大部分代码公平锁和非公平锁的实现都是一样的

只是在 lock() 方法上做了一点修改

非公平锁是因为在 lock() 方法内直接判断 state 是否为 0，而不去管 AQS 队列内等待的线程，导致贤臣可以插队出现不公平

而公平锁的 lock() 并不是直接根据 state 状态来判断的，而是先获取 state，如果 state 为 0，那么再判断 AQS 队列是否为空，如果为空，那么再尝试进行 CAS 获取锁，如果 AQS 队列不为空，那么当前线程是不会获得锁的



```java
final void lock() {
    acquire(1);
}

public final void acquire(int arg) {
    if (!tryAcquire(arg) &&
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}

protected final boolean tryAcquire(int acquires) {
    final Thread current = Thread.currentThread();
    int c = getState();
    if (c == 0) {
        if (!hasQueuedPredecessors() &&
            compareAndSetState(0, acquires)) {
            setExclusiveOwnerThread(current);
            return true;
        }
    }
    else if (current == getExclusiveOwnerThread()) {
        int nextc = c + acquires;
        if (nextc < 0)
            throw new Error("Maximum lock count exceeded");
        setState(nextc);
        return true;
    }
    return false;
}
```


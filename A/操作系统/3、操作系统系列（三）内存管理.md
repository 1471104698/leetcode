# 内存管理

---

内存管理：<https://blog.csdn.net/smilesundream/article/details/70148878>



## 1、虚拟内存 和 虚拟地址

> ### 故事背景

在最开始，虚拟内存和虚拟地址还没有出现的时候，进程直接操作的是物理地址，并且程序加载到内存需要连续的内存空间，比如 一个大小为 10M 的程序，如果要运行，必须在内存空间中找到 连续的大小为 10M 的空间，才能将程序加载进内存

上面这种加载方式肯定是有问题的，具体的问题如下：

**1、地址空间不隔离**

内存中的两个程序 A 和 B，假设程序 A 的物理地址为 0x00000000~0x00000099

程序 B 的物理地址为 0x00000100~0x00000199

程序 A 假如就跟我们自己写代码一样，一旦不小心越界了，将数据写进了 0x00000150 的地址，那么受影响的不只是程序 A，连 程序 B 也有问题



**2、程序运行地址不稳定**

比如我们在程序中直接写死，操作的是 0x00000050 地址，由于程序直接访问的就是物理地址，因此就直接操作该物理地址了

但是，程序每次加载的内存地址是不一定的，上一次加载的是 0x00000000~0x00000099，那下一次加载的可能就是 0x00000100~0x00000199 了，那么直接操作地址也是有问题的



**3、产生内存碎片**

比如 存在三个程序，其中程序A大小为10M，程序B为70M，程序C的大小为30M，而内存空间总共有100M。

它们是无法同时在内存中执行的，一次只能执行两个程序

并且，如果先执行了程序 A，再执行程序 B，那么等到需要程序 C 执行的时候，我们需要换一个程序下来，

如果换 A，那么内存空间存在 10M 和 20 M 两个内存碎片，还是无法执行 C



**为了解决上述问题，就出现了虚拟内存，使用硬盘空间来代替物理内存，而伴随着虚拟内存出现的就是虚拟地址**

操作系统给进程分配内存的时候，分配的是虚拟地址（虚页），虚页会映射到物理内存或者虚拟内存上，进程只能访问这些虚页，而不能实际操作物理内存

并且通过在虚页上加上权限控制，当进程通过虚页进行操作时，CPU 可以根据上面的权限判断进程的操作是否允许



**实现虚拟地址到物理地址的映射的，就是使用的 分段、分页、段页式 机制**



> ### 虚拟内存的限制

虚拟内存作为物理内存的扩充，多进程分配的内存实际上可能远远大于实际可用的物理内存，因此需要使用虚拟内存来代替物理内存，而分配给进程的是虚页，即虚拟地址，这些虚拟地址可以映射到物理内存上，也可以映射到虚拟内存上（磁盘）

将进程活跃的页面调入内存，不活跃的放入到虚拟内存上，当进程访问某个不活跃的页面时，CPU 发现虚页映射在磁盘上，因此发起缺页异常，将虚页对应的磁盘页面调入内存当重



**在 Linux 中，swap 区就是 windows 的 虚拟内存，用于内存交换的**

**虚拟内存是将内存暂时不需要的数据存放到硬盘中**，**对于 Linux ，就是将这些数据存储到 swap 分区中**

**当然，因为是硬盘，所以读写速度肯定是比在物理内存中慢的，所以应该避免大数据的内存交换，比如分段机制，就是因为存在大数据的内存交换，导致效率低下**



虚拟内存的大小理论上是无限大的（磁盘大小）

但是真正有用的虚拟内存大小 **受到 CPU 位数的限制**，如果 CPU 只支持 0 - 2^32  - 1 的寻址范围，那么超出的寻址虚拟内存也没有什么用了



## 2、分段机制



分段是将用户进程按照某个逻辑划分为大小不等的多个段，比如划分为 堆、栈、数据段、代码段 四个段

每个段从 0 开始编制，并且内存空间是连续的，**即段内连续，但是段与段之间不需要连续**



**各段的逻辑地址和物理地址映射存储在 段表中**

段表存储了每个段的段长（占用内存大小） 和 基址（该段在物理地址中的起始位置）



> ### 地址结构

给出逻辑地址的段号和段内地址，求解物理地址：

- 通过 段号 + 段表，获取基址
- 通过 基址 + 段内地址 获取物理地址

虚拟地址中的每一段的大小跟对应的物理地址每一段是一样的，并且每一段都是从 0 开始编址的

这样段内地址就是该段的段内偏移量，而基址是该段在物理地址的起始地址，所以 起始地址 + 段内偏移量就是物理地址了

![img](https://img-blog.csdn.net/20131031091123328?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2FuZzM3OTI3NTYxNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)



> ### 内存分段的优缺点

优点：

- 信息共享：由于分出来的段都是具有实际意义的，比如 数据段里面都是数据，因此有利于信息共享，分页不能够实现这点，因为分出来的页没有独立的意义，只是单纯的存储数据而已
- 便于存区访问控制：即权限控制

缺点：

- 存在内存碎片
  - 内碎片：一个段占据的内存空间很大，但是可能一大部分都是没有运行的，这样的部分称作内碎片
  - 外碎片：当一个程序停止运行后会释放占据的内存空间，假设是 20MB，如果后面的程序需要的内存空间都大于 20MB，这 20MB 就不能利用起来，形成了外碎片
- 内存交换效率低：分段是以整个程序作为基本单位的，分的段只是为了尽量让存储空间不连续而已，所以内存不足时还是需要将整个程序交换到 swap 区，由于 IO 操作比内存读写速度慢很多，所以当交换的一个程序足够大的时候，可能会形成卡顿





## 3、分页机制



内存分页 是将 虚拟内存空间 和 物理内存 划分为大小相同的一个个小空间，虚拟内存的每个小空间称为 页，物理内存的每个小空间称为 块， **页大小 和 块大小是相同的，这样才能建立映射关系**

在 Linux 或者 Windows 中，每块都是 4KB

![image.png](https://pic.leetcode-cn.com/1604650481-hGoCmv-image.png)



每一 页 和 块 的映射关系存储在页表中，比如 进程1 的 虚拟页 1 映射 物理内存的 块号 998，进程2 的 虚拟页 1 映射 物理内存的 块号 1000

**页表 由 CPU 的 MMU（内存管理单元） 进行管理**

 ![img](http://nieyong.github.io/wiki_cpu/CPU%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84-image/mmu/mmu_va2pa.png) 

> ### 地址结构

逻辑地址 = 页号 + 偏移量

由于每一页都是分散存储的，因此每 1 页 和 第 2 页 对应的物理页不一定是连续的

比如 第 1 虚拟页对应 第 3 个物理页（块），第 2 虚拟页对应第 6 物理页

因此，只要 某一页的页内偏移量 = 某一块的块内偏移量，只要知道 页对应的哪一块就可以求出对应的物理位置

比如给定 x 的逻辑地址 8242，一个页 4KB，则有：

- 求得所在页数： 8242 /  4 KB = 8242 /   (4 * 1024) = 2，
- 求得页内偏移量：8242 % (4 * 1024) = 50

因此找到 页数对应的物理块号：6

那么 x 所在物理地址为 6 * (4 * 1024) + 50 = 24626



<img src="https://pic.leetcode-cn.com/1604674811-UbLvUi-image.png" style="zoom:80%;" />*



> ### 分页解决 外碎片 问题

因为每次写入和释放都是以页的大小，那么所有的空闲内存空间都一个一个的页，不会存在比页大和比页小的内存空间

而当进程需要分配内存空间的时候，可以将任意位置的页分配给它，释放也是按也空间，自然不会存在内存碎片

当进程需要的内存空间不够时，会将其他正在运行的进程 目前不需要使用 的内存页面给换出到 swap 区，一旦需要的时候，再换入



**但 分页还是会存在 内碎片**

为了防止外碎片，分配的单位都是以 页 为单位，假设一个页为  4KB，而一个程序只需要 1KB  的空间，那么至少也需要分配一个页给该程序，那么就会浪费掉 3 KB 的空间，如果一个程序浪费 3KB，那 x 个程序加起来就浪费 3x KB



> ### 页面置换算法

OPT：理想层面上的算法

FIFO：先进先出算法

LRU：最近最久未使用算法，即每次换出的页面都是最先入队的页面

LFU：最近最少使用算法，每次换出的页面是使用次数最少的页面，如果使用次数都一样，那么换出最久未使用的数据





## 4、分页机制 之 多级页表

[多级页表](https://zhuanlan.zhihu.com/p/152119007)



**为什么要使用多级页表？**

Linux 每个进程分配的虚拟空间为 4GB（2^32），而划分的每个页的大小为 4KB (2^12)

这样一个进程的所划分出来的虚拟页的数量为 2^20，其中每个页表项为 4B

那么存储 2^20 个页表项 所需的页表的大小为 4B * 2^20 = 4MB

看来好像只要 4MB，也没占据多少内存，但是，这只是一个进程，**如果存在 100 个进程，那么总的页表所需物理内存为 400MB**，即物理内存中 400MB 空间是不能够用来存储进程数据的，单单是用来存储页表，显然有些吃亏



因此，引入了多级页表

 ![img](https://pic4.zhimg.com/80/v2-d93943bf4f4fbed708f751c5303f8d6f_720w.jpg) 

上面这张图是将 32位（4GB）虚拟地址按照 位（注意，这里的位不是 bit，而是 B） 进行划分：

- 前 10 位（2^10 = 1KB）划分为 1024 个一级页表项，作为一级页表
- 中间 10 位划分为 1024 个二级页表
- 最后 12 位（2^12 = 4KB）划分为页内偏移，因为一个页大小为 4KB，所以需要 4KB 来表示页内地址



也许看不太懂这个划分方式，**为什么是划分为 1024 个页表项？？？这么划分的意义是什么？？**

我们需要知道内存地址 4GB 和 每个页大小 4KB 代表着什么

内存地址 32位 4GB，表示地址范围为 [00000000 00000000 00000000 00000000， 11111111 11111111 11111111 11111111]

页面大小为 4KB，表示该页的地址范围为 4KB，比如 [00000000 00000000 00000000 00000000, 00000000 00000000 00000011 11111111]，类似这种，地址范围为 4KB，即 2^10



**单级页表是直接根据整个虚拟地址来查找对应的页表项位置，即 逻辑地址 / 页大小 获取 页表项号，而多级页表则是对虚拟地址进行更加细节的划分**



一个进程有 32 位，多级页表是根据 32 位的前 10 位划分出 1024 个页表项 作为一级页表（注意，页表是存储在 CPU 中的，这里是根据 前 10 位来确定在页表的页表项号）

如果两个进程的 虚拟地址 前 10 位相同的那么都对应到同一个一级页表项上

再根据 中间 10 位 划分出 1024 个页表项，作为二级页表

如果 2 个虚拟地址 前 10 位相同，这时它们根据中间 10 位来确定 二级页表的页表项，通过二级页表项可以获取到对应的物理块；

如果它们中间 10 位相同，那么它们就对应到同一个 二级页表的页表项上，即它们对应同一个 物理块 ，这时候就根据 后 12 位来确定它们在物理块中的 偏移量了



**这时候可能会说：**

多级页表中，一级页表 1024 个页表项，每个页表项占 4B，那么一级页表需要 4KB

二级页表中，同样的每个页表需要 4KB，而存在 1024 个二级页表，那么就需要 1024 * 4KB = 4MB

这样总的不就需要 4KB + 4MB 了么，占据的内存不是更多了么？



的确理论上看来是这样，但是实际上一个进程是不可能全部使用到 4GB 内存的，即我们不需要给整个 一级页表的所有页表项分配二级页表，只需要在使用的时候才分配二级页表

假设只有 20% 的一级页表被使用到了，那么页表占用的空间为  4KB（一级页表） + 20% * 4MB（二级页表）= `0.804MB` 



**那么为什么 单级页表 需要提前分配内存呢？**

我们从页表的性质来看，保存在 CPU 中的页表是将虚拟地址翻译成物理地址，如果我们只分配了 2MB 的页表，那么就意味着有些虚拟地址我们无法在 页表中找到，这样就系统出错了，因此即使 虚拟页 和 物理块没有存在映射关系，我们也需给这些虚拟页 提前分配页表项，防止出现查找不到的情况

而多级页表的 一级页表项虽然只覆盖了虚拟地址的前 10 位，但是足够已经覆盖了整个虚拟地址空间，当我们查找某个虚拟页的时候，只需要根据它的前 10 位找到对应的一级页表项，然后再根据中间 10 位找到对应的二级页表项

因此只要任何一个虚拟地址能够进行定位，而不会存在找不到页表项位置的情况，就不会出现系统错误，而二级页表只需要在后续分配即可





## 5、段页机制（Linux 的内存管理）

段页式就是分段 + 分页，先将用户进程划分为多个段，然后再将每个段划分为多个页

分成了很多个段，因此存在段号，所以需要一张段表

每个段分成了很多的页，因此存在页号，每个段需要一张页表

因此需要 段表 + 页表



关系如下图：先在 4GB 虚拟地址中划分出各个段的空间，然后将各个段分成各个页，然后将页与物理页进行映射

![img](https://pic3.zhimg.com/80/v2-db98afd6d5e107bba50547f1759dbd36_720w.jpg?source=1940ef5c)



> ### 地址结构

段表中不再只是存储段号 和 段大小，而是存储了 段号、页表大小（段大小）、该段对应的页表起始位置（段基址）

```
解释一下：
页表对应某个段，所以页表大小页是段的大小
页表的起始位置其实也是该段的起始位置，跟原来指代的物理地址不同，这里指的是虚拟地址中的位置
```

![img](https://img-blog.csdn.net/20131031092005921?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2FuZzM3OTI3NTYxNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

给定 段号、段内页号、页内地址（页内偏移量）

- 段表 + 段号 获取 页表的起始地址
- 页表的起始地址 + 段内页号 获取对应的 物理地址块
- 物理地址块 + 页内地址 获取对应的物理地址

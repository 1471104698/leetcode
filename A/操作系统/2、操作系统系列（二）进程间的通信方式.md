# 进程间的通信方式



## 引言

我们需要知道的是，不需要去细分什么 "同步" 和 "通信" 的关系，而是当作 能够 "通信" 那么就一定是一种同步机制

所有的通信方式如下：

![img](https://pic4.zhimg.com/80/v2-c6aeb64f7e87579f12f6cc2c92dc95c0_720w.jpg)





## 1、管道

管道有两种：匿名管道 和 命名管道



> ### 匿名管道

匿名管道是存在于内存当中的，而不存在文件形式，管道实际上就是内核中的一个缓冲区，数据写入都放到这个缓冲区中

```java
ps auxf | grep
```

上面的 "|" 就是一条匿名管道，需要的时候就创建，用完就直接销毁，没有名字的，跟 java 的匿名内部类一样

比如下面这段 java 代码，传入了一个 Runnable 的匿名类对象，用完即毁

```java
new Thread(() -> {
    System.out.println(1);
}).start();
```



它是将 "|" 前面的命令输出结果当作写入到管道中，而 "|" 后面的命令会去读取管道内的数据

图示如下：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190522031913582.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyODk2NjI3,size_16,color_FFFFFF,t_70)





匿名管道的调用方法：

```C
int pipe(int fd[2]);
```

fd[2] 中一个作为写端，一个作为读端

匿名管道只能用于父子进程间的通信，即当前进程创建 管道，它内部是调用 fork() 创建子进程，然后进行通信

父进程调用 pipe()，传入两个 fd，然后再调用 fork() 创建出来的子进程会同时复制 父进程的 fd

这样父进程使用 fd[0] 进行读取， 子进程使用 fd[1] 进行写入，完成通信



比如下面，父子进程的 fd 都一样的，都是 3 和 4，不过父进程使用 fd = 4，子进程使用 fd = 3，这样就不会存在干扰

![clipboard.png](https://segmentfault.com/img/bVN8RW?w=548&h=557)



> ### 命名管道

```java
 mkfifo myPipe
```

上面是创建了一个 名字为 myPipe 的管道，它是以文件形式存在的，可以进行复用，并且不局限于父子进程，即本机进程都可以使用这个管道进行通信，不过通信前需要指定是哪两个进程，比匿名管道麻烦点



> ### 管道的缺点

- 使用管道进程会阻塞，如果没有数据需要阻塞等待数据，不适合频繁的交换数据

- 只能单向传输，如果要双向通信，那么需要创建两个管道

- 匿名管道只能使用在父子进程

  

## 2、消息队列 

管道不适合进程间的频繁通信，因为进程会阻塞，效率低

而消息队列就能够解决这个问题

消息对队列是保存在内核中的消息链表，进程间的通信数据结构就是 数据块（类似链表的 Node 节点）

当进程 A 要给进程 B 发消息时，将数据封装在数据块中，然后放入消息队列，然后就可以返回做其他事了

而进程 B 需要的时候再去读取数据就可以了

类似我们平时发的电子邮件，你一封我一封，可以频繁交流

但是这种邮件形式的方式也有缺点：

- 一是信息不具有即时性，由于邮件什么的什么时候都可以看，因此可能今天看的这封邮件是几天前发的

- 二是邮件大小也有限制

我们上面说了，数据是封装在 数据块的，它也是一种数据结构，那么内部肯定是使用数组实现的，那么就有对应的大小限制



> ### 消息队列的缺点

- 由于消息队列内部是使用数组来存储数据的，那么存在大小限制，不适合大数据的传输
- 消息队列用于不需要实时性的数据传输



## 3、共享内存

具体看 [udp卷2 共享内存 1](https://blog.csdn.net/u010129119/article/details/77949579?utm_medium=distribute.pc_relevant.none-task-blog-title-3&spm=1001.2101.3001.4242)

[udp卷2 共享内存 2](https://blog.csdn.net/enlyhua/article/details/79888868?utm_medium=distribute.pc_relevant.none-task-blog-title-2&spm=1001.2101.3001.4242)



共享内存是 多个进程拿出某些虚拟页，然后再从用户态内存中拿出一块物理内存，将进程的虚拟页共同映射到这块物理地址上

这样的就它们的数据交流就不需要经过内核态缓存了



管道/消息队列存在四次拷贝：

- 进程 A 调用系统函数 read() 读取文件，发生一次内核态到用户态的拷贝
- 进程 A 将读取的数据拷贝到 内核态的 缓存中（缓存可以是 管道或者消息队列），发生一次用户态到内核态的拷贝
- 进程 B 从内核态缓存中读取数据，发生一次内核态到用户态的拷贝
- 进程 B 调用系统函数 write() 将数据写回到文件中，发生一次用户态到内核态的拷贝

![img](https://img-blog.csdn.net/20170912211559441)

共享内存只需要两次拷贝：

- 进程 A 调用系统函数 read() 读取文件，将数据存储到共享内存中，发生一次内核态到用户态的拷贝
- 进程 B 调用系统函数 write() 将共享内存中的数据直接写入文件，发生一次用户态到内核态的拷贝

![img](https://img-blog.csdn.net/20170912211610292)

简单讲，共享内存减少的两次拷贝就是 进程 A 和 进程 B 之间的数据通信



> ### 共享内存的缺点

- 多线程不加锁处理数据会导致数据错乱，当多个进程同时修改一个共享内存，那么比如两个进程同时写一个地址，那么先写的那一个进行会发现被后面的覆盖了



## 4、信号量（PV，为共享内存服务）

共享内存存在进程不安全的问题，即会发生数据错乱，因此需要保护机制，**保证共享内存一次只能由一个进程访问**

**因此信号量是为共享内存服务的**

信号量涉及两个操作：P 和 V

P 操作是将可用资源数 -1，V 操作是将可用资源数 + 1

**过程：**

- 信号量初始化为 1
- 当 进程  A 先到达时，执行 P 操作，发现信号量为 0，那么可以访问数据

- 当 进程 B 到达的时候，执行 P 操作，发现信号量为 -1，那么陷入阻塞状态

- 等到 进程 A 访问完数据，执行 V 操作，信号量 +1，变成 0，唤醒 进程 B
- 进程 B 访问完数据，执行 V 操作，信号量 +1，变成 1

这样做就很好的保护了共享内存



上面这个是信号量用来互斥的，但有时我们就需要实现 生产者-消费者模式，同样可以使用 PV 来实现

比如 进程 A 是生产者，进程 B 是消费者

 ![img](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZckxn1SzJ697nE1m1wJzmPQlO6zu8K0xlLpDBbew0jVibibhVm59TQy4ibJSZKxqKsWOrcLIibZE6RAVg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1) 

**过程：**

- 信号量初始化为 0，表示当前无数据 可消费
- 如果 进程 B 先执行 P 操作，发现信号量为 -1，那么进入阻塞状态
- 之后 进程 A 执行，生产数据，然后执行 V 操作，信号量 +1，变成 0，唤醒 进程 B 进行消费



## 5、信号（异常通信）

上面的几种通信方式包括下面的 socket，都是正常情况下的进程间通信，比如交换数据之类的

信号的使用：

- 在异常情况下的通信方式，比如杀死一个进程，子进程 exit 后通知父进程进行收尸防止变成僵尸进程，就会使用到 信号
- kill 指令就是发送信号，表示立即停止该线程

- 当某个进程陷入阻塞，比如我们 mysql 在事务中进行当前读的时候需要锁，而锁被别的事务获取了，所以会陷入阻塞，那么这时候可以通过 crtl + c 发送信号来中断等待



## 6、Socket（不同主机通信）

上面的几种通信方式，都是在同一台主机上面的进程间的通信方式

如果要跨网络或者主机，就要使用 socket 通信

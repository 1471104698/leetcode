# 用户线程 Stop The World



在 GC 时，经常会碰到用户线程 STW 的情况，而 STW 是需要用户线程到达一个 "安全点" 的东西



## 1、OOPMap

默认 JVM （HotSpot）使用的是 可达性分析，而可达性算法是扫描 GC roots，如果在 GC 的时候才找出 GC roots 有哪些，这显然速度是很慢的，需要扫描整个进程上下文之类的，效率很低，而用户线程还在 STW，这么做显然是不合理的

因此，JVM 使用了一种数据结构来存储 GC roots，**在 GC 的时候直接扫描这些数据结构即可**，这个数据结构就是 OOPMap

OOPMap 会存储两种数据：

- 在类加载的时候，由于成员变量在类加载的时候偏移量会提前计算好，并且创建出来的 OOP 对象体中 数据存放也是根据这个偏移量来的，所以 JVM 会在 OOPMap 中记录**该对象哪个偏移量对应哪个引用对象**，不会去记录 基本数据类型和 String 之类的，只会记录引用类型

- 一个线程对应一个栈和寄存器，在程序运行的时， JIT 即时编译方法字节码的时候，会在 OOPMap 中记录当前虚拟机栈和寄存器中**哪个位置存在哪个对象引用**

<img src="https://pic1.zhimg.com/80/v2-c6e13c93852c15d9dd9002c56e0112c4_720w.jpg" style="zoom:100%;" />



例子：

在类加载时，JVM 会在 一个 OOPMap 中记录 Main 类 offset = 10 的位置是 A 对象，offset = 32 的位置是 B 对象

在程序运行到 h() 的时候，JIT 编译过程中会在一个 OOPMap 中记录 User 对象

```java
class Main{
	A a;	//offset = 10
	B b;	//offset = 32
	int c = 0;
	public User h(){
		User user = new User();
		int i = 0;
		while(i++ < 10){
			//
		}
		user.setAge(1);
		user.setName("oy");
		return user;
	}
}
```



## 2、安全点 和 安全区域

> #### 安全点

OOPMap 不是每次发生变量引用就去更改的，即 JIT 不是每次边编译边执行边更新 OOPMap 的，JVM 设置了安全点

**在安全点是会停止该用户线程，然后创建 OOPMap 记录中的对象引用，即一个安全点一个 OOPMap，为后面的 GC 做准备**

即安全点是为了更新 OOPMap 而产生的



当需要发生 GC 的时候，用户线程不是随便暂停的，而是需要到达安全点才停止。

一个方法可能有多个安全点，即多个 OOPMap，JVM 可能会将一个方法分为多个代码段，每个代码段设置一个安全点，而 每个安全点的 OOPMap 的作用域也仅限于这个安全点

安全点不是随便设置的，如果在每条指令都设置一个安全点，那么显然是不科学的，因此 JVM 在指定的一些位置创建安全点：

- 方法调用
- 方法返回前
- while/for 循环末尾
- 抛异常的位置

可以看出，安全点的设置都是相当于代码段的分割，它不会在如下这种定义变量或者输出之类的地方设置一个安全点

因为感觉这种代码相当于一个代码段，没必要进行分割。因为如果在中间设置安全点，那么创建完 OOPMap 后，下面又进行引用更改，本来是完全可以合并为一个 OOPMap 的

```java
public User h(){
	User user = new User();
    user.setAge(1);
    A a = new A();
    user.setA(a);
    System.out.println(a);
    System.out.println(user);
    
    savepoint();//设置安全点
    return user;
}
```

而在 while/for 后面设置安全点是因为**当发生 GC 时，需要暂停所有的用户线程，一旦存在一个用户线程没有暂停，那么就会导致其他的用户线程 STW 的时间过长**，效率降低，因此为了尽可能的减少 while 过长导致的 STW 过长，需要在 while 后面立马加上一个安全点，循环结束立马进入 STW。



> #### 安全区域

安全区域即 线程运行某个代码段时，这个代码段不会发生任何的引用更改或者创建，比如简单的输入输出 或者 sleep() 之类

**为什么有了安全点还需要安全区域？**

因为当有的线程在 GC 发生前就进入了 sleep() 或者 阻塞等待锁，而这些线程在 GC 时 JVM 是无法将它们唤醒然后让它们进入安全点的，所以需要设置一个安全区域，比如在 线程进入 sleep() 之前，**标识自己进入了安全区域**，然后如果在它 sleep() 的时候，发生了 GC，那么在 GC 过程中，它 sleep() 结束了，为了防止它继续运行而修改了引用，所以它离开安全区域之前，会检查 GC 是否结束，如果没有结束，那么继续 STW，免得出去修改了引用


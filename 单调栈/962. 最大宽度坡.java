给定一个整数数组 A，坡是元组 (i, j)，其中  i < j 且 A[i] <= A[j]。这样的坡的宽度为 j - i。

找出 A 中的坡的最大宽度，如果不存在，返回 0 。

 

示例 1：

输入：[6,0,8,2,1,5]
输出：4
解释：
最大宽度的坡为 (i, j) = (1, 5): A[1] = 0 且 A[5] = 5.
示例 2：

输入：[9,8,1,0,1,9,4,0,4,1]
输出：7
解释：
最大宽度的坡为 (i, j) = (2, 9): A[2] = 1 且 A[9] = 1.
 

提示：

2 <= A.length <= 50000
0 <= A[i] <= 50000

/*
	单调栈应用范围：
	1、求解数组右边第一个比当前元素大的索引位置，正序遍历，维护一个单调递减栈
	2、求解数组右边第一个比当前元素小的索引位置，正序遍历，维护一个单调递增栈
	（上述一次遍历即可）
	3、求解数组左边第一个比当前元素大的索引位置，反序遍历，维护一个单调递增栈
	4、求解数组左边第一个比当前元素小的索引位置，反序遍历，维护一个单调递减栈
	（上述需要正序遍历一次获取单调序列，然后反序遍历求取结果）
*/
class Solution {
    public int maxWidthRamp(int[] A) {
        /*
        对于 i 位置，其实就是找 [0, i - 1] 第一个比它小的位置 j
        即寻找数组左边第一个比当前元素小的索引位置

        先正序遍历，维护一个单调递减栈
        比如 [6,0,8,2,1,5]，那么单调递减序列为 [6, 0]，栈内元素为 [0, 1]

        然后反序遍历，我们可以发现 最后一个元素 5，它比 0 大，因此计算高度坡
        我们可以发现，因为我们是从前往后的单调递减序列，而求取结果是从后往前
        比如 1 和 5 都比 0 大，但是因为 5 越靠后，因此对于同个位置的 0 的来说，5 到 0 的高度坡比 1 到 0 的高度坡大，
        因此我们遇到比 5 小的位置 i 可以直接 pop() 计算高度坡，因为前面不会存在比 5 到 i 还大的高度坡
        */
        Deque<Integer> stack = new LinkedList<>();
        int len = A.length;
        for(int i = 0; i < len; i++){
            if(stack.isEmpty() || A[stack.peek()] > A[i]){
                stack.push(i);
            }
        }
        int high = 0;
        for(int i = len - 1; i >= 0; i--){
            while(!stack.isEmpty() && A[i] >= A[stack.peek()]){
                high = Math.max(high, i - stack.pop());
            }
        }
        return high;
    }
}
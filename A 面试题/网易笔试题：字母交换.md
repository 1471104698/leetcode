# [网易笔试题：字母交换](<https://www.nowcoder.com/test/question/analytic?tid=35742761>)

*![image.png](https://pic.leetcode-cn.com/e6c550463ce29c029f31017f5b2d734ee42bc76e5be3cede24fed92b2980d7bd-image.png)*

## 题意描述

字符串S由小写字母构成，长度为n。定义一种操作，每次都可以挑选字符串中任意的两个相邻字母进行交换。询问在至多交换m次之后，字符串中最多有多少个连续的位置上的字母相同？



## 示例1

### 输入

```
abcbaa 2
```

### 输出

```
2
```

### 说明

```
使2个字母a连续出现，至少需要3次操作。即把第1个位置上的a移动到第4个位置。
所以在至多操作2次的情况下，最多只能使2个b或2个a连续出现。
```



## 方法一：区间 dp

### 实现思路

#### 1、dp思路

​            假设 str 中 a 字符的索引列表为 `arr = [0,2,4]`
​            `dp[i][j] `表示 某个字符 第 i 个位置 到 第 j 个位置这个范围内的所有字符 拼接成连续位置所需的最少交换次数
​            这里的第 i 个位置和 第 j 个位置不是指代在 str 中的索引，而是 [0,2,4] 中 0 代表第 1 个位置，2 代表第 2 个位置，即在索引列表中的位置
​            当 i == j 时，只有一个字符，那么 `dp[i][j] = 0`
​            其他情况：
​                那么` dp[i][j] = dp[i + 1][j - 1] + arr[j] - arr[i] - 1 - (j - i - 1)`
​                            ` = dp[i + 1][j - 1] + arr[j] - arr[i] - (j - i)`
​                `arr[j] - arr[i] - 1 `   表示   str 中它们之间的距离
​               ` j - i - 1 `表示它们中间存在多少个相同字符，这样就少移了` j - i - 1` 步（因为被这些字符阻挡了，直接跟它们靠在一起就可以了）

#### 2、思路注意点：

我们不是 字符 j 移动到字符 i，而是看作字符 j 和 字符 i 移动到连续位置所需的最少步数

一般来说，我们两个同时往中间靠的时候，步数是最少的，比如 i 位置索引为 0， j 位置索引为 10

那么它们同时往中间靠，所需的步数为 10 - 0 - 1 = 9

特殊情况：i 位置 和 j 位置之间不存在任何其他字符，那么 i 移动到 j 和 j 移动到 i 以及 两个往中间靠的步数是一样的

但是如果它们中间存在其他字符，比如：

a	a		a

0	4		20

i	 k		   j

如果我们将 i 和 j 移到连续位置的话，如果我们单单是看作将 j 移动到 i 的相邻位置，那么需要的步数为  19

而对于中间的 k 位置，它要跟它们连续的话就必须移动到 i 位置，需要步数 3，那么总步数就是 19 + 3 = 22

a ⬅   a	⬅      a

0	4		20

i	 k		   j



我们其实移动不是移动中间的去跟边界靠，而是移动边界的去跟中间靠，比如 移动 i 去跟 k 靠，移动 j 去跟 k 靠

这样步数只需要 3 + 15 = 18，实际上就是 

`arr[j] - arr[k] - 1 + arr[k] - arr[i] - 1 = 20 - 4 - 1 + 4 - 0 - 1 = 18`

但我们可以简化为 `arr[j] - arr[i] - 1 - 中间字符数  = 20 - 1 - 1 = 18`

因为 i 移动到 k ，j 移动到 k 的距离都是 `arr[j] - arr[i]`，不过由于不会重合，因此位置需要 -1，然后由于存在中间字符 k，所以距离又需要 -1，`arr[j] - arr[i] - 1 - 1`

如果中间存在 m 个字符，那么就需要少移动 m 步，即为 

`dp[i][j] = dp[i + 1][j - 1] + arr[j] - arr[i] - 1 - m`

` dp[i + 1][j - 1] ` 表示中间的字符移动到相邻位置所需的最小步数

a ➡   a	⬅      a

0	4		20

i	 k		   j



#### 3、区间 dp 注意点

区间 dp 不能跟普通的 dp 一样，双重循环都往同一个方向走，即 ⬅⬅ 或者 ➡➡

而必须是从中间往两边扩散延伸，即一个向左一个向右 ⬅➡

因为我们使用区间 dp 的时候，需要使用到内部值，比如 `[i, i + 1, ..., j - 1, j]`

当我们计算 `dp[i][j]` 的时候，内部的 `dp[i + 1][j - 1] `必须已经处理好了
如果我们从 `i = 0，j = i + 1` 开始同向遍历，那么对于 `i + 1` 来说，我们还没有处理好

 因此，当我们需要使用` dp[i + 1][j - 1] `的时候，即我们需要内部的时候
我们需要  ⬅➡ 双向遍历，即 i 从后往前， j 从前往后 或者 i 从前后往后， j 从后往前，只要是往左右两边扩散，才能保证使用的 i 和 j 的内部处理完毕



### 实现代码

```java
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        Main main = new Main();
        String str = sc.next();
        int m = sc.nextInt();
        main.helper(str, m);
    }
    private void helper(String str, int m){
        int len = str.length();
        List<Integer>[] lists = new List[26];
        for(int i = 0; i < len; i++){
            int num = str.charAt(i) - 'a';
            if(lists[num] == null){
                lists[num] = new ArrayList<>();
            }
            lists[num].add(i);
        }
        
        int mlen = 1;
        for(int i = 0; i < 26; i++){
            if(lists[i] == null){
                continue;
            }
            int size = lists[i].size();
            int[][] dp = new int[size][size];

            for(int j = size - 2; j >= 0; j--){
                for(int k = j + 1; k < size; k++){
                    dp[j][k] = dp[j + 1][k - 1] + lists[i].get(k) - lists[i].get(j) - (k - j);
                    if(dp[j][k] <= m){
                        mlen = Math.max(mlen, k - j + 1);
                    }
                }
            }
        }
        System.out.println(mlen);
    }
}
```


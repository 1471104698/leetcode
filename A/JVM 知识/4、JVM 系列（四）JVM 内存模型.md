





# JVM 内存模型

## 1、JVM 内存模型

JDK 1.8 的 JVM 内存空间如下：

![img](https://pic4.zhimg.com/80/v2-fb2f583edea32cfde008ecb5390244b9_720w.jpg?source=1940ef5c)



### 1、程序计数器

线程私有，即每个线程都有一个程序计数器，记录字节码指令的位置



这里的程序计数器跟操作系统的程序计数器不同

操作系统的程序计数器是使用 寄存器来实现的，线程的程序计数器是使用内存来实现的



当运行 native 方法时，由于不是 java 代码，因此不会使用 java 的程序计数器，对应的程序计数器值为空

一个线程方法间的切换是不需要保存程序计数器的



### 2、虚拟机栈

------

线程私有，即每个线程都有一个虚拟机栈，每个线程都有自己的方法调用链，虚拟机栈存储调用的方法的栈帧

> **它是 JVM 用来描述 Java 方法执行的内存模型**

每当一个方法被调用时，就会创建一个新的栈帧，当某个方法执行完毕后，那么就会将栈顶的栈帧弹出

由于是栈模型，所以表示栈顶的栈帧是最新的，即对应的是当前正在执行的方法



栈的内存空间也是有限的，即存储的栈帧是有限的，即递归调用的方法数是有限的

如果一直深入递归，那么就会栈溢出，那么抛出 StackOverflowError 异常



> ### 栈帧

[栈帧包含什么？](<https://blog.csdn.net/qian520ao/article/details/79118474>)

操作数栈 和 局部变量表



### 3、本地方法栈

线程私有，跟虚拟机栈差不多的，存储的是 native 方法的栈帧

native 方法可以在 Object 中找到：getClass()、clone()、wait()、notify()



```java
HotSpot 中 没有划分 虚拟机栈 和 本地方法栈，它将两个栈合并为一个
```



### 4、堆内存

堆内存 是 JVM 内存中最大的一块内存，基本上所有 的实例对象都是在这里分配内存，但是有的不一定，因为存在逃逸分析，会在栈上分配



老年代 ：新生代 = 2 ：1

E区 ：S0：S1 = 8：1：1



### 5、方法区

方法区 是 JVM 一个抽象的规范，而 永久代 和 元空间 则是方法区的实现

- 在 JDK 8 之前，使用的都永久代，它位于 JVM 内存当中，受到 JVM 管理，而 **永久代 和 老年代 是进行 GC 绑定的，一旦其中一个区域占满，那么这两个区域都会同时进行 GC**，所以我们需要注意 永久代的空间大小

- JDK 8 的时候，使用元空间代替永久代，元空间不在 JVM 内存中，而是在本地内存中（即我们的计算机内存，比如我这台电脑 8G），这样理论上它能够使用的内存空间是没有限制的，也就很难出现 GC 和 OOM，而且 运行时常量池也从元空间移除了，在堆中开辟了一个内存空间存放运行时常量池



> ### 各种常量池

**字符串常量池：**

​	JDK 6 在方法区中，存储字符串对象， JDK 7 转移到堆中，存储对堆中字符串对象的引用



**运行时常量池：**

​	JDK 7 还有永久代时在方法区中，JDK 8 移除永久代，替换为元空间，元空间在物理内存上，此时运行时常量池转移到堆中

​	即 JDK 8 的时候 字符串常量池 和 运行时常量池 都存在于堆中了

class 文件中除了 类、方法、接口的描述符之类的，还有 常量池，这部分存储了字面量 和 符号引用（即方法的 Code 属性需要的，记录的是某个方法调用的方法、字段等）， 类加载后这部分会存储到到运行时常量池中

```java
class A{
	public int read(){
		int i = 0;
		int j = 2;
		return i + j;
	}
	public void say(){
		read();
	}
}
```

class 文件中关于一个类的信息的部分，我们可以看作分为两部分：

- 类的父类、子类、类加载器、方法（方法名、访问修饰符、Code 属性、虚方法表的索引等）、字段（变量名等） 等信息
- 常量池（class 文件中的）：方法 Code 属性具体 定义的参数、调用的方法

在类加载的时候第一部分会转变成 Klass 实例存储在方法区中，在类加载后会将**常量池的内容存储到运行时常量池中**



## 2、JVM 内存分配策略



JVM 内存分配 有 5 钟策略

**注：新生代划分为 伊甸区（E区） 和 两个幸存区（S区），比例为 8：1：1**



> ### 对象优先进入新生代

大多数情况下，对象都是在 E区 中分配内存，当 E区 无法给申请内存的对象分配连续的内存的时候，那么就会触发一次 minor GC（young GC）

将 E区、S区① 存活的对象放到 S区② 中，然后 S1 和 S2 互换指针，保持 S区② 指针指向的区域 是空的



> ### 大对象直接进入老年代

大对象是需要大量连续的内存空间的，比如大数组和超长字符串，由于存放在 E 区的话很容易导致内存不足而频繁产生 GC，所以直接放到 老年代

对于多大的对象才直接进入老年代，可以通过参数设置



> ### 根据对象年龄判断是否进入老年代

所谓的年龄，如果经历过一次 young GC 对象仍然存活，那么年龄 +1，如果没有存活，那么直接享年 x 岁

某个对象第一次经历 young GC 存活时，会将该对象从 E区 移动到 S区①，且对象年龄为 1，往后只要经历过 指定次 young GC 还活着，那么就将该对象移动到 老年代



> ### 动态对象年龄判断

JVM 其实并不是会一直等到年龄到达一个阈值才会将对象晋升的

一般应该是在 young GC 时进行，在 S 区中从 年龄为 1 的对象开始计算对象大小，计算到年龄为 x 时总的对象大小超过阈值（阈值应该是 S 区的空间一半），那么就将年龄大于 x 的对象移至老年代



> ### 空间分配担保

这里的 担保 有点像 买保险 的意思

在发生 young GC 之前，

- 判断 老年代最大可用连续空间 是否 大于 新生代的所有对象的总空间大小
  - 即如果极端的情况下，新生代所有的对象都晋升到老年代，老年代是否撑得住
- 如果大于，那么可以放心的进行 young GC
- 如果小于，那么判断是否设置了某个参数
- 如果设置了，那么再次判断 老年代最大可用连续空间 是否 大于 历次新生代晋升老年代的平均对象空间
  - 这里是退而求其次，按照历次的 young GC 晋升的对象大小来判断是否可以进行 young GC
- 如果大于，那么可以有风险的进行一次 young GC
  - 因为历次平均值只能作为参考，如果刚好这次 young GC 晋升的对象空间超过了老年代最大可用连续空间，那么就崩了
- 如果没有设置或者 小于，那么进行一次 full GC



## 3、OOM 内存溢出 和 内存泄漏

> ### OOM 内存溢出

**程序计数器是线程私有的，是唯一一个不会出现 OOM 的区域**

而 堆、虚拟机栈、方法区、方法区 都有可能会出现 OOM



**堆 OOM：**堆是线程共享的，当一个线程为一个对象申请分配内存的时候，如果堆内存空间不够，就会触发 GC，如果 GC 之后还是无法分配，那么就会产生 堆 OOM

- -Xms：初始堆内存大小，默认为 物理内存 1/64
- -Xmx：最大堆内存大小，默认为 物理内存 1/4

**栈 OOM **：系统分配给每个进程的空间是有限的，每个线程都会占用一定的内存，如果无限创建线程会出现 栈OOM，这里的栈 OOM 实际上是系统内存 OOM，不过是由于 栈分配引起的，所以说是 栈 OOM

- -Xss：每个线程栈的内存大小，默认为 512KB - 1M

**方法区 OOM：**在 JDK 8 之前，方法区实现是永久代，它跟堆内存是绑定在一起的，GC 也是一起 GC，用来存储类的元数据 ，它的大小也是有限的，如果加载过多的类，再加载新的类的时候无法分配空间，那么就会产生 方法区 OOM（JDK 8 之后使用的是元空间，跟物理内存挂钩，基本不会出现 OOM）



**直接内存 OOM：**使用 ByteBuffer 的 allocateDirect() 或者 unsafe 的 allocateMemory()

```java
while(true){
	unsafe.allocateMemory(1024);
}
```





> ### 内存泄漏



**内存泄漏是导致 OOM 的原因之一**

**JVM 对内存进行全权管理，从自动分配到垃圾回收，为什么还会发生内存泄漏？**

java 方面的内存泄漏跟 C 的内存泄漏不太一样，C 由于不存在 JVM 的自动垃圾回收，因此每次都需要手动释放对象，而如果在没有释放对象前就失去了对这个对象的引用，那么这个对象就无法被释放，会一直占用内存，这就导致内存泄漏

比如下面这段代码

```C
for(i=0; i<N; i++) {
    p = malloc(4096);
    p = malloc(4096);
    free(p);
}
```

对于第一个 malloc 的内存，没有释放就失去了引用，这就导致内存泄漏



而由于 java 存在 JVM，会对没有引用的对象进行回收，所以很难出现 C 层面的内存泄漏

所以对于 java 的内存泄漏来说，就是反过来的，已经使用完了某个对象，但是仍然留着对它的引用，导致 JVM 无法进行回收，占用着内存空间

比如下面这段代码

```java
class stack {
    Object[] data = new Object[1000];
    int top = -1;

    public void push(Object o) {
        top++;
        data[top] = o;
    }

    public Object pop(Object o) {
        top--;
        return data[top + 1];
    }
}

```

对于 push 进去的元素， pop 的时候并没有失去对它的引用，而是简单的对 top 指针进行变化

这样的话， pop 后的栈顶对象已经使用完了，但是 data 数组还留着对它的引用，导致它无法被垃圾回收

只能等到 push 到该位置时，使用一个新的元素来代替 data 对它的引用，它才能被 JVM 回收

而如果 push 了 1000 个元素，然后再 pop 1000 个元素，那么这时宏观上来看 data 中是不存在任何元素的

**但是，实际上 data 并没有放弃对那 1000 个元素 的引用，这样的话这 1000 个元素不会被 JVM 回收，也不会被再次使用，相当于是垃圾堆放在了内存空间中，这样就导致了内存泄漏，进一步可能会导致 内存溢出**





## 4、静态变量、全局变量、局部变量、 和 常量存储位置

**静态变量：** JDK 1.7 后从方法区中移除，放入到 Class 对象中，而 Class 对象存储在 堆中

**全局变量：**某个类实例化时进行初始化，是属于某个类实例的，因此跟类实例一样存储在堆中

**局部变量：**属于某个方法的，方法的具象化是用栈帧来表示的，局部变量存储在局部变量表中，基础类型的局部变量（int）存储的是值，非基础类型的局部变量（User）存储的是引用，而局部变量表是栈帧的一部分



**final 和 static final 常量：**



```java
public class A{
    final static long l = 2L;
    final String s = "abc";
    final String s1 = new String("abc");
    final double d = 123.00987d;
    final float f = 10.001f;
    final int N = 2;
}
```

javap -v 后如下：

```java
//该字节码描述的是 A 的构造方法 ，即如果调用 new A()，那么初始化的变量如下，由于 l 不是 OOP 对象，所以不会在这里初始化
public cur.A();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=4, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object."<init>":()V
         4: aload_0
         5: ldc           #2                  // String abc 
             		//需要先将 符号引用 #2 转换为直接引用
             					1.1、执行 s = "abc"，ldc 指令，如果常量池没有，则在堆中创建 "abc"，将引用放入常量池
         7: putfield      #3                  // Field s:Ljava/lang/String;
             					1.2、将上面 lac 返回的引用赋值给 s
        10: aload_0
        11: new           #4                  // class java/lang/String
            					2.1、执行 s1 = new String("abc") 中的第一步，创建 String 的 OOP 对象
        14: dup
        15: ldc           #2                  // String abc
            					2.2、执行 ldc 执行，这里获取的是上面 ldc 存入的引用
        17: invokespecial #5                  // Method java/lang/String."<init>":(Ljava/lang/String;)V
            					2.3、执行 new String("abc") ，调用构造方法
        20: putfield      #6                  // Field s1:Ljava/lang/String;
            					2.4、将 OOP 对象赋值给 s1
        23: aload_0
        24: ldc2_w        #7                  // double 123.00987d
        27: putfield      #9                  // Field d:D
        30: aload_0
        31: ldc           #10                 // float 10.001f
        33: putfield      #11                 // Field f:F
        36: aload_0
        37: iconst_2
        38: putfield      #12                 // Field N:I
        41: return
}
```

final 和 static final 修饰的变量在编译时期产生的字节码 与普通的变量没有区别（虽然这里看不出 static final，但实际上一样的）

意味着是在编译阶段就保证了 final 的不变性，即通过各个代码判断是否被发生改变

如果发生了改变，那么编译就不通过，而在后续编译完成的 字节码就是当作普通的变量来对待

所以，被 final 修饰的变量，该存哪还是存哪，final 就存储在堆的 OOP 对象中，static final 就存储在 堆中的 Class 对象中





## 5、引用类型存储的位置

```java
public class Main{
	A a = new A();
	public void h(){
		B b = new B();
	}
}
```

有两个引用类型指针 a 和 b

a 指向的是成员变量，是属于整个 OOP 对象的，不属于任何一个 栈帧，因此不会存储在 虚拟方法栈中，所以跟 OOP 对象一样存储在堆中

b 是属于方法栈的，所以它存储在栈中
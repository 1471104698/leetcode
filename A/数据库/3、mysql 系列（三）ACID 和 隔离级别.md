# ACID 和 隔离级别



## 1、事务的四个特性（ACID 原则）

A：原子性，在事务执行过程中，所有的操作要么全部 commit 成功，要么全部 rollback 失败，成功就要应用于数据库，失败就不能对数据库有任何影响，**基于 redo/undo 机制**

C：一致性，这个很重要

I：隔离性，事务与事务之间是相互隔离的，互不干扰，**通过设置隔离级别**

D：持久性：一个事务一旦被提交，在数据库中的数据改变就应该是永久有效的，**持久化到硬盘上**



> ### C 一致性

[如何理解数据库事务中的一致性的概念？ - 莺歌一笑的回答 - 知乎](https://www.zhihu.com/question/31346392/answer/362597203)

事务的 AID 是数据库本身来保证的，而 **C  不是 事务本身 能够做到的，则是需要开发者来保证，它是应用层面的约束**

**所谓的一致性是指 系统从一个正确的状态，迁移到另一个正确的状态**

何为正确的状态？就是当前的状态满足设定的约束，那么当前状态就是正确的状态

```
做个比喻，事务就好比一个保镖，保镖他本身就强壮、踏实、反应能力快，这就类比事务的 AID，而在一般情况下，在保镖保护下自己就是安全的，而这个安全就类比事务的 C，如果自己故意骗开保镖，自己去玩，那么这样的话就意味着不再保证安全了，即丢失了 C
同样，如果自己在事务中写出了违反约束的代码，那这也没办法
```



在好比 转账：

```
A 向 B 支付 100 元，而 A 的账户中只有 90 元，在数据库中的 余额 字段列没有存在任何的约束，因此当支付完成后，会发现 A 的余额为 -10
```

虽然这个转账事务最终执行成功了，但是这个结果显然不是我们想要的，它遵守了数据库的约束，但是违反了应用层的约束，在应用层方面余额就必须 >= 0，在应用层方面来讲，最终的状态就是一个错误的状态

因此我们需要在应用层进行判断，来保证 C，即如果余额不够，那么就不能进行转账

同时，A 给 B 转账了，A 扣钱后 B 也必须加钱，不能出现只扣钱不加钱的情况，这种都是需要在应用层处理好的



**因此，感觉 C 不应该叫做一致性，而应该叫做 约束性**

作者自己也说了：

```
This(Consistency）does not guarantee correctness of the transaction in all ways the application programmer might have wanted (that is the responsibility of application-level code) but merely that any programming errors cannot result in the violation of any defined database constraints.[1]

翻译：
（一致性）不能以应用程序程序员可能想要的所有方式保证事务的正确性（这是应用程序级代码的责任），而仅仅是保证任何编程错误都不会导致违反任何已定义的数据库约束。[1] ]
```





## 2、事务并发问题：丢失修改、脏读、不可重复读、幻读

丢失修改：

```
这个就类似 多线程情况下没有加锁的 i++ 了
按照实际场景来讲的话，就比如 库存，商品原先有 100 件
线程 A 下单 10 件，先查询，发现有 100 件
线程 B 下单 20 件，先查询，发现有 100 件
此时 线程 A 和 线程 B 同时进行减库存操作
线程 A： 100 - 10 = 90
线程 B： 100 - 20 = 80
最终无论是谁最后写回数据库，最终的结果都是错误的，因为正确的结果应该是 70

但这个实际上加行锁就能解决
```

脏读：

```
当前事务能够读取到别的事务还没有提交的脏数据，由于读得到，所以可能会被当前事务使用，但是如果别的事务将这个数据回滚，那么就意味着当前事务是用了不存在的数据，问题很大
```

不可重复读：

```
第一次 select 的某个数据行的数据 跟第二次 select 的相同数据行的数据不同，即别人 commit 后将这个数据行的数据修改了，结果被当前事务读取到了
```

幻读：

```
当前事务第一次查询的数据只有 3 条，第二次查询的数据出现了 4 条，或者 变成了 2 条，跟出现幻觉一样，跟 不可重复读差不多，不过是别人添加和删除的数据被当前事务读取到了
```





## 3、四个隔离级别

四个隔离级别：读未提交、读已提交、可重复读、串行

 

读未提交：会出现脏读、不可重复读、幻读

读已提交：会出现不可重复读、幻读

可重复读：在特定情况下会出现 可重复读、幻读

串行化：没啥事



> ### 读未提交

一个事务执行过程中，可以读取到另外一个事务修改的未提交的数据



假设 x = 100

事务 A 和 事务 B 都在操作 x，事务 A将 x 改为 50，但是还没有提交

而事务 B 获取 x 值，这时读取到的是 x = 50

这时候如果 事务 B 执行 x - 50 这个操作的话，那么 x 变成 0

而如果 事务 A 没有提交，而是回滚，那么意味着 x = 50 这个值是不成立的，而事务 B 在不成立的值上做了修改，导致最终的结果也是不成立的，因为事务 A 回滚了，表示 x 应该还是 100，那么事务 B 执行的 x - 50 的话，结果应该是 50

这个 隔离性最差，基本事务之间就没有隔离



这个在自己事务中能够读取到别的事务修改的数据，就是脏读



> ### 读已提交

一个事务执行过程中，不可以读取另一个事务修改未提交的数据，但可以读取到已提交的数据



假设 x = 100

事务 A 和 事务 B 两个事务并发执行，事务 B 使用 select 查询 x = 100，事务 A 修改了 x = 50，然后提交，事务 B 使用 select 再次查询 x = 50，发现前后两次查询结果不一样，这就是不可重复读（按照字面意思就是不能够重复读取之前的值，即之前读的值会被修改）



假设 x > 50 的有 3 条数据

事务 A 和 事务 B 两个事务并发执行，事务 B 查询 x > 50，发现有 3 条数据，事务 A 插入了 x = 60 的一条数据，事务 B 再次查询 x > 50 ，发现有 4 条数据，前面查询的数据量不一样，这就是幻读



读已提交能够解决脏读的问题，即读取到的都是提交的，已经确定的值，但因此会产生 不可重复读 和 幻读

其中，不可重复读是针对 update 的，单单是修改值，幻读是针对 delete 和 insert 的，会改变数据量



> ### 可重复读

一个事务执行过程中，不能读取其他事务未提交以及已提交的数据，相当于事务之间操作的都是数据的副本



其中是通过 MVCC（多版本并发控制）来实现的，因为别的事务提交了数据，数据已经更新了，怎么保证自己能够读取到自己原来的值呢？就是指定版本



> ### 串行

这个隔离级别就严重了，可以解决上述问题的任何问题，因为每次**只允许一个事务执行，不允许并发事务**，即是串行的

没啥用吧，在如今这个要求效率的时代，基本不会去用这种拖慢下来的东西

**使用场景大概就是 在事务过程中不允许别的事务进行操作，避免任何事务并发问题**
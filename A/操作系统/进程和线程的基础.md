# 进程和线程的基础



> 先来看看一则小故事

我们写好的一行行代码，为了让其工作起来，我们还得把它送进城（**进程**）里，那既然进了城里，那肯定不能胡作非为了。

城里人有城里人的规矩，城中有个专门管辖你们的城管（**操作系统**），人家让你休息就休息，让你工作就工作，毕竟摊位（**CPU**）就一个，每个人都要占这个摊位来工作，城里要工作的人多着去了。

所以城管为了公平起见，它使用一种策略（**调度**）方式，给每个人一个固定的工作时间（**时间片**），时间到了就会通知你去休息而换另外一个人上场工作。

另外，在休息时候你也不能偷懒，要记住工作到哪了，不然下次到你工作了，你忘记工作到哪了，那还怎么继续？

有的人，可能还进入了县城（**线程**）工作，这里相对轻松一些，在休息的时候，要记住的东西相对较少，而且还能共享城里的资源。



## 1、进程的概念

最开始进程的概念是：我们首先写的代码，它是一个磁盘中的静态文件，通过编译变成二进制文件，当我们执行这个文件的时候，它会加载到内存中，变成含有一条条的指令的程序，而执行这个程序的时候，就是在执行这些指令，这个执行的程序就被称作进程



> 什么是并发？

当执行某个进程的时候，它需要读取磁盘文件，这个过程对人来说可能很快，但是换成计算机视角，是非常缓慢的，CPU 不可能等到这个进程读取完数据再继续执行它，这样效率低得一批（这里需要注意的是，进程读取磁盘文件是进程自己的事，无需 CPU 参与）

做个类比，你去煮开水时，你会傻傻的等水壶烧开吗？很明显，小孩也不会傻等。我们可以在水壶烧开之前去做其他事情。当水壶烧开了，我们自然就会听到“嘀嘀嘀”的声音，于是再把烧开的水倒入到水杯里就好了。

同样的，人类设置的 CPU 也不会这么傻，当进程 A 读取磁盘文件的时候，CPU 就不管这个进程 A，去执行另外一个进程 B，当进程 A 读取完毕后，CPU 收到中断指令，停止执行进程 B 再去执行进程 A

![img](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcvw4t9kicec370n3cvX2JS9ROKhytS0ATz3KUictSI0rDntHcibw6wdfrJyDgvVgxdicEic6jkRW0692A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1) 

进程交替运行，由于进程切换的速度对于人类来说非常的快，因此给人一种几种程序同时进行的感觉，其实不然，这就是并发，而并行才是人类感觉的哪一种

![img](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcvw4t9kicec370n3cvX2JS9kkSqrpkMYqI035yU7Ricpv368zOBOCicrk5EOMf7T5j9UicUvficEQdCxg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



> 进程和程序的关系

按我的理解，静静的躺在电脑桌面上的软件就是程序，我们没有运行它，它只是磁盘的静态文件而已，当我们运行它了，加载到内存当中供 CPU 调度了，就变成了进程，即运行中的程序



## 2、进程的状态

**进程至少存在 3 个状态：【运行、就绪、阻塞】**

状态变化如下：

运行状态 -> 就绪状态、阻塞状态

就绪状态 -> 运行状态

阻塞状态 -> 就绪状态

即阻塞状态不可能一下就变成运行状态，因为运行状态需要 CPU 的调度，当阻塞时间完成后，不可能保证 CPU 立马调度它，因此会先进入就绪状态等待调度

![img](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcvw4t9kicec370n3cvX2JS9EfRviciaGMLREQ1nqvjWkibKlREGPI9JyfhA5XlmzFRRiaIATAEiaLbCx4w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

**阻塞事件**：比如 java 中的 scanner，即等待输入，等待的过程中，即使给进程 CPU 的控制权也没什么意义，因为它被 I/O 事件阻塞了，无法继续执行



## 3、进程的结构（PCB）

操作系统中， 进程控制块 - PCB 就是用来标识进程的

**PCB 是进程的唯一标识符**，即创建进程的时候就创建对应的 PCB，销毁进程的时候就销毁对应的 PCB



>  PCB 包含什么？为什么对进程来说如此重要？

PCB 包含了：

进程当前的状态：如 运行态、阻塞态、就绪态等

进程的优先级：进程抢占 CPU 的优先级

内存地址 或 虚拟内存的空间信息

当前运行的状态信息：比如进程切换时，那么需要保存当前运行的状态信息，即下次运行进程时需要从什么地方开始，方便下次 CPU 调度时 CPU 直接获取 PCB 来继续执行进程

> 每个 PCB 是如何组织的呢？

PCB 包含了进程的 状态，那么我们获取运行、就绪、阻塞状态的进程就是根据 PCB 来的，那么各个进程的 PCB 是如何串联起来的呢？

一般是通过 **链表** 的方式

由于 PCB 也是一种数据结构，这里我们就可以把 PCB 看作是链表的 Node 节点，有以下定义：

```java
class PCB{
    //进程号
    int pid;
    //优先级
    //...
    
    //下一个进程 PCB
    PCB next;
}
```

由于是链表的形式，通过 next 指针来获取下一个进程 PCB

把具有相同状态的 PCB 串成一条链表，**组成各种队列**。

- 将所有处于就绪状态的进程链在一起，称为**就绪队列**；
- 把所有因等待某事件而处于等待状态的进程链在一起就组成各种**阻塞队列**；
- 另外，对于运行队列在单核 CPU 系统中则只有一个运行指针了，因为单核 CPU 在某个时间，只能运行一个程序。

![img](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcvw4t9kicec370n3cvX2JS9q2vgjxfNQq38MNmricWU9jicJtxKDqu8MiaFtvia2qJ7LVxjlsMCcRDShQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



## 4、进程的上下文切换（就是进程切换）

CPU 从一个进程切换到另一个进程，就叫做 线程的上下文切换



> 进程的上下文切换是切换什么？

当 进程 A 的 时间片用完后，CPU 就会执行 进程 B，而进程 A 的状态信息需要保存下来，这样下次执行进程的时候才能保证 任务 看起来连续运行

进程的状态信息：

1、当前执行的位置：或者说程序计数器，最开始的时候也说 了，进程的执行实际上就是按照顺序执行每条指令，因此我们需要记录当前已经执行完的指令，方便下次从接下来的指令位置开始执行

2、全局变量、栈等资源

这些都保存在 PCB 中，等到下次 CPU 调用到该进程时，会从 PCB 中获取到这些信息，然后继续执行进程

进程上下文的切换由于需要保存旧进程的状态信息，读取新进程的状态信息，也是有点花费时间的，我们自然希望 开销越小越好



## 5、线程的概念

上面我们提到的进程，是作为 CPU 调度的基本单位

即我们可以把上面的进程看作一个线程

但是由于某些原因，因此又提出了更小的独立运行的基本单位：线程



> #### 为什么使用线程？

我们举个例子，假设你要编写一个视频播放器软件，那么该软件功能的核心模块有三个：

- 从视频文件当中读取数据；
- 对读取的数据进行解压缩；
- 把解压缩后的视频数据播放出来；

对于单进程的实现方式，我想大家都会是以下这个方式：

![img](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcvw4t9kicec370n3cvX2JS929V7rcLXiaaB16boR9VraolG9Fgc9NpnxOSlHx7No6t0zSPrscaeuaA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

（这里需要说明一下，java 中，我们运行一个类 main() 方法的时候，它就是一个独立的进程，当我们运行两个类的 main() 方法的时候，它们就是两个独立的进程，互不干扰）

因此上面的这种方式是运行在一个类中的，是一个进程

单进程是按顺序执行的，即必须先 Read() 执行完毕后再 解压缩数据，再进行播放

由于需要边读取边播放，因此我们每读取 1 个字节就进行解压缩再播放，这样就可以边读取压缩边播放

对于单进程的这种方式，存在以下问题：

- 可能由于 CPU 的原因，我们在 Read() 方法这里卡住了，那么就会导致半天才能数据解压和播放，体验不友好
- 单进程的方式，各个函数之间不是并发执行的，而是顺序执行的影响效率

那改成多进程的方式：

![img](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcvw4t9kicec370n3cvX2JS9CInoGdDVyYvtTfju7gVeKLjDNOMmul4kPzicTbczNiaBSzGiaEzDXtYTA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

这就又产生一个问题了，多进程，其实就是多个类，一个类执行一个函数，那么这几个类怎么进行共享数据？比如你多个类同时执行 main() 方法，数据能共享吗？

不能吧！！！！

那到底如何解决呢？需要有一种新的实体，满足以下特性：

- 实体之间可以并发运行；
- 实体之间共享相同的地址空间；

这个新的实体，就是**线程( Thread )**，线程之间可以并发运行且共享相同的地址空间。



> 什么是线程？

通过上面我们可以看出，**线程是进程的一条执行路线流程**

即 Read() 可以作为一个线程，解压缩数据可以作为一个线程，播放可以作为一个线程

线程是在进程的基础上产生的，多个线程共享进程的资源，但又有自己的寄存器和栈，这样，就既能共享资源，又能有独立的运行空间而不受其他线程的影响，比如上面的 Read() 线程，它能跟别的线程一起 共享 进程的全局变量等，但又存在自己的局部变量



> #### 线程与进程的比较

**进程是资源分配的基本单位， 线程是调度的基本单位**。

这里我们可以看出来，最开始讲的进程是调度的基本单位，等到线程出来后，进程单单就变成了资源分配的基本单位了，即是提供一个资源共享的平台给它内部的线程使用，单单只是作为一个交流平台而已，所有的线程都可以来这里拿数据资源

所以，由于资源是共享的，所有线程都能拿到，才存在线程安全的问题，即到底是谁先拿到，以及谁做的改变才有效等问题
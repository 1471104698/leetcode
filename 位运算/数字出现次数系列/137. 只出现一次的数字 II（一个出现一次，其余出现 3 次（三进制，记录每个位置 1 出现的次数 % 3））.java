给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。

说明：

你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

示例 1:

输入: [2,2,3,2]
输出: 3
示例 2:

输入: [0,1,0,1,0,1,99]
输出: 99

class Solution {
    public int singleNumber(int[] nums) {
        /*
            其他元素出现 3 次，那么使用 3 进制
            其他元素出现 k 次，那么使用 k 进制

            2,2,3,2

            0010
            0010
            0011
            0010
            
            记录当某个位置 1 出现的个数，只能是 3 的倍数 或 3 的倍数 + 1，即 c % 3 = 0 | 1
            其他数出现 3 次，那么它们的某个有 1 的位置的 1 的个数必定是 三个三个 出现的，那么对于三进制来说 % 3 = 0
            经过 三进制后剩余的结果就是 只出现 1 次的数 
        */
        int res = 0;
    
        //这里 32 次遍历 nums 数组，时间复杂度 O(32 * n) = O(n)， 仍是线性复杂度
        for(int i = 0; i < 32; i++){
            //第 i 个位置 1 的个数
            int c = 0;
            for(int num : nums){
                //判断某个位置是否是 1，如果是 ，那么 1 的次数 + 1
                if(((num >>> i) & 1) != 0){
                    c++;
                }
            }
            //结果只能是 0 或 1
            c %= 3;
            //将结果合并到 res 中
            res |= c << i;
        }
        return res;
    }
}
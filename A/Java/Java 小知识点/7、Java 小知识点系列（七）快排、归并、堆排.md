# 快排、归并、堆排



## 1、数组上快排的优点

快排、归并、堆排 的时间复杂度都是 O(nlogn)，但是我们需要知道，所谓的时间复杂度都只是一个大体上的一个预估值，忽略常熟以及更小的数量级，比如 O(n) 和 O(2n)、O(10n) 都称为 O(n)，当然这个时间复杂度不做考究，真正需要考究的是 硬盘和内存 方面的速度



快排 效率高的原因之一是 因为 快排的查找很好的利用了 磁盘局部性原理，而 堆排 并没有，因为它访问比较的是子节点，即 2 * i 和 2 * i + 1，这种显然跨度很大，当数据是百万级别的，那么这个 2 * i 就跨过了很大的数据量，无法使用到 磁盘局部性原理

快排 效率高的另外一个因素是 它是一个原地算法，在排序过程中不需要创建任何的辅助数组来保存临界值，这样就不需要 分配 和 回收 辅助数据的内存 和 将 原数组元素值 copy 到辅助数组上，而堆排则需要这样做



## 2、链表上归并的优点

**当然，在数组上，快排基本比堆排、归并要快，但是在链表上，快排同样快，但却不是最优的**



因为在对链表排序的时候，快排的这些优点并没有体现出来，因为链表的节点内存地址是离散的，并不是跟数组一样的连续内存，因此 磁盘局部性原理 也就没有太大作用

同时，快排的原地算法 这个优点也没有太大的好处，因为链表是可以随时进行断开的，因此对链表进行 归并 的时候也不需要创建的辅助空间

因此，对链表排序的时候，快排同样快，但是归并更快，因为在相同条件下，归并会将链表均匀地分为两半，并且每次合并的工作要比 快排的分区要少

**因此，链表的最优排序算法是 归并算法**



```
以下是 某个国外大佬的原话：（经过翻译）

快速排序效率的主要来源之一是参考位置，在此优化了计算机硬件，因此访问彼此接近的内存位置往往比访问分散在整个内存中的内存位置要快。 快速排序中的分区步骤通常具有出色的局部性，因为它可以访问正面和背面附近的连续数组元素。 结果，快速排序往往比其他排序算法（例如堆排序）表现出更好的性能，尽管它经常进行大致相同数量的比较和交换，因为在堆排序的情况下，访问更加分散。


此外，快速排序通常比其他排序算法快得多，因为它可以在原地运行，而无需创建任何辅助数组来保存临时值。 与诸如合并排序之类的东西相比，这可能是一个巨大的优势，因为分配和取消分配辅助数组所需的时间可能很明显。 就地操作还可以改善quicksort的位置。


当使用链表时，这些优点都不是必需的。 由于链接列表单元经常散布在整个内存中，因此访问相邻的链接列表单元不会带来任何位置上的好处。 因此，Quicksort巨大的性能优势之一就被吞噬了。 同样，就地工作的好处不再适用，因为合并排序的链表算法不需要任何额外的辅助存储空间。


也就是说，快速排序在链表上仍然很快。但是归并排序 更快，因为它可以将列表更均匀地分成两半，并且每次执行合并的工作要比分区步骤少。
```



## 3、快排的最坏情况

快排的平均时间复杂度为 O(nlogn)，即认为得到的分割点都差不多是 中点

```java
private int quickSort(int[][] vals, int left, int right){
    int[] base = vals[(left];
    while(left < right){
        //从右边找到比 base 大的填充过去
        while(left < right && vals[right][1] <= base[1]){
            right--;
        }
        if(left < right){
            vals[left] = vals[right];
            left++;
        }
        while(left < right && vals[left][1] >= base[1]){
            left++;
        }
        if(left < right){
            vals[right] = vals[left];
            right--;
        }
    }
    vals[left] = base;
    return left;
}
```

但是可能会出现最坏的时间复杂度 O(n^2)，出现这种最坏情况的可能如下：

- 数组已经排序
- 数值全部相等

对于这两种情况，在 while() 第一次循环的时候，right 指针就会直接左移达到左边界，这样分割点就是左边界了，相当于一次 quickSort() 只是减少了一个元素，最终次数为 O(n^2)

 

解决方法：

对于第一种情况，选择中点作为基准值

对于第二种情况，在 Arrays.sort() 使用三路归并进行处理（leetcode 75.颜色分类）
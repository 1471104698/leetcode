# 死锁

## 1、死锁的产生

> ### 举个例子

假设我们有一把蓝钥匙，可以打开一扇蓝色的门；以及一把红钥匙，可以打开一扇红色的门。

两把钥匙被保存在一个皮箱里。

同时我们定义六种行为：获取蓝钥匙，打开蓝色门，归还蓝钥匙，获取红钥匙，打开红色门，归还红钥匙。

![img](https://pic1.zhimg.com/80/v2-823088df49d849ebbcb52739ec20333b_720w.jpg)



获取蓝钥匙，打开蓝色门，归还蓝钥匙 应该保证相对顺序

获取红钥匙，打开红色门，归还红钥匙 应该保证相对顺序



那么一共有 20 种情况（![[公式]](https://www.zhihu.com/equation?tex=A_%7B6%7D%5E%7B6%7D%2F%28A_%7B3%7D%5E%7B3%7D%2AA_%7B3%7D%5E%7B3%7D%29)），我们任取 6 种

![img](https://pic1.zhimg.com/80/v2-1a3491eb9bcf99612863a4be404e57f4_720w.jpg)



假设线程 A 和 线程 B 都有一个任务，就是需要打开蓝色门和红色门，它们的指令安排是这样的：（解法 3 和 解法 4）

![img](https://picb.zhimg.com/80/v2-021292616c89207b9868f3991be7d699_720w.jpg)

线程 A 获取 蓝色钥匙，打开蓝色门，阻塞等待红色钥匙，线程 B 获取红色钥匙打开红色门，归还红色钥匙，阻塞 等待蓝色钥匙

线程 B 获取红色钥匙，打开红色门，归还红色钥匙，再归还蓝色钥匙，这样线程 B 获取蓝色钥匙，完成后续指令

一切都是这么的顺利，无死锁发生



但是，如果选取 解法 3 和 解法 5

![img](https://picb.zhimg.com/80/v2-4423d2645e0d0ef610cf63d34013792d_720w.jpg)



线程 A 在持有 蓝色钥匙的情况下阻塞等待获取红色钥匙，线程 B 在持有红色钥匙的情况下阻塞等待获取蓝色钥匙

两者都贪心的想要获取对方手里的资源，但都不想要放弃自己手里的资源，**因此发生了死锁**



> ### 死锁产生的条件

- 互斥条件：一个资源一次只能由一个线程拥有，其他线程如果想要获取，需要阻塞等待拥有者线程释放
  - 比如 一个门只有一把钥匙
- 请求和保持条件：线程很“贪心”，在持有资源的情况下请求别的资源，它们不会放弃自己手里的资源
  - 比如上面拿着红色钥匙的线程又去请求蓝色钥匙，陷入阻塞状态也不会放弃自己手里的红色钥匙
- 不剥夺条件：线程获取的资源在完成任务之前，不允许其他进程获取，只能等待线程主动释放
  - 比如上面拿着红色钥匙，在没有归还钥匙前其他线程是不能获取的
- 循环等待条件：有多个进程{P0,P1,P2...Pn}，而 P0 等待 P1 的资源，P1 等待 P2 的资源 。。。Pn 等待 P0 的资源，就这样陷入了循环等待的困境
  - 比如上面 只有两个线程，但是陷入了循环等待的局面，线程 A 拿着蓝色钥匙等待 线程 B 手中的红色钥匙，线程 B 拿着红色钥匙等待线程 A 手中的蓝色钥匙



## 2、死锁预防（破坏四个必要条件之一）

- 破坏互斥条件：互斥条件是因为资源只有一个，且一次只能被一个线程持有，其他线程只能等待，比如上面的一把钥匙对应一个门，那么可以复制钥匙的副本，给多个线程。但实际上复制成本高，而且效率低，有的资源也只能存在一个，比如键盘的控制权之类的
- 破坏循环等待条件：由于线程 A 和 线程 B 按照不同的指令执行造成的循环等待，那么我们可以让线程 A 和 线程 B 最开始都去获取 红色钥匙 或者 蓝色钥匙，这样没有获取的一方就会阻塞，不会去霸占另一把钥匙
- 破坏不剥夺条件：线程 A 和 线程 B 宁愿死等也不愿放弃自己手中的资源，因此我们可以设置一个等待时间，多久时间没有获取到就放弃自己手中的资源，即可以产生剥夺的条件
- 破坏循环等待条件：线程 A 和 线程 B 都在持有一个资源的情况下请求另外一个资源，这样的话，我们规定必须先使用完一个资源，归还该资源后才能再请求另外一个资源，即保证它们不会霸占资源





## 3、死锁避免 - 银行家算法

有多个进程，并且存在多个资源，每个进程请求的资源数是不同的

那么我们需要经过计算，生成一个安全分配的序列，提前知道如何进行资源分配，才会保证不会产生死锁

- 安全序列可以存在多个，并且一定不会产生死锁

- 不安全序列同样存在多个，并不是一定会产生死锁，但产生死锁的必定是不安全序列

银行家算法就是用来找到安全序列的



> ### 简单一句话

当一个进程去申请资源的时候，银行家算法会进行模拟，假设分配给了该进程资源，判断 是否能够使得该进程完成 或者 剩下的资源是否能够满足后续的进程完成，如果可以，那么就是安全序列，不会产生死锁，如果不可以，那么表示是不安全序列，可能产生死锁，不能分配给该进程



> ### 简单一幅图

![这里写图片描述](https://img-blog.csdn.net/20180508204335770?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNDE0Mjcx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)





> ### 银行家算法例子讲解

存在 P0 P1 P2 P3 P4 这五个进程，以及 4 种资源

Allocation 表示对应进程已经分配到的各个资源的数量

> 比如 P0 的 0 0 3 2 表示第一、二个资源分配到了 0 个，第三 个资源分配到了 3 个，第四个资源分配了 2 个

Need 表示对应进程在分配了的资源的基础上还需要的各个资源的数量

Available 表示如今资源库中各个资源剩下的可分配的数量



![img](https://img-blog.csdn.net/20180508210408944)



假设 P0 申请 (0,0,1,2) 个资源，银行家算法会进行模拟，过程如下：

- 给 P0 分配 (0,0,1,2) 个资源，那么剩下的可用资源为 (1,6,1,0)，但是 P0 已经拥有了需要的全部资源，因此它可以执行完毕，将所占有的资源全部归还，那么可用资源就变成了 (1,6,5,4)
- 后续看其他的进程，这时候可以先给 P3 分配 (0,6,5,2)，让 P3 完成任务，归还资源，可用资源就变成了 (1,9,8,6)
- 再给 P4 分配 (0,6,5,6)，让 P4 完成任务，归还资源，可用资源就变成了 (1,9,9,10)
- 再给 P1 分配 (1,7,5,0)，让 P1 完成任务，归还资源，可用资源就变成了 (2,9,9,10)
- 再给 P2 分配 (2,3,5,6)，让 P2 完成任务，归还资源
- 所有进程都完成任务，完美达成

**因此，可以给 P0 分配资源，安全序列为 P0 - P3 - P4 - P1 - P2，这样不会产生死锁**



假设 P2 申请 (1,2,2,2) 个资源，银行家算法模拟过程如下：

- 给 P2 分配 (1,2,2,2) 个资源，那么剩下的可用资源为 (0,4,0,0)
- P2 还需要资源，但是可用资源不足以供给，所以 P2 无法完成任务，归还资源，而可用资源同时无法给其他进程分配所需资源，使得它们完成任务
- 这样，就陷入了死锁，因为所有进程都无法完成任务，这样就一直都不会归还资源，使得每个进程都陷入等待状态

**因此，不能给 P2 分配资源**



## 4、死锁检测算法

> ### 每种资源只有一个

当每种资源只有一个时，那么成环就意味着必定发生了死锁，因为只有一个的话，进程 A 请求的资源被进程 B 占有了

而后成环表示各个进程都有请求的和占有的，而占有的是别人请求的，请求的是别人占有的，这样都不会释放，且都不会获取新资源，导致死锁

![img](https://pic3.zhimg.com/80/v2-15d05471cb6d97558eac7c026f2fc7d5_720w.jpg)

上面是资源分配图，圆圈表示资源，方框表示进程，箭头表示某个资源分配了某个进程，而某个进程又请求某个资源

图（b）成环了，所以发生了死锁



**死锁检测算法：**

dfs 从一个节点出发，对访问过的节点进行标记，判断是否会访问过已经标记过的点，如果是，那么表示成环，发生死锁



> ### 每种资源有多个

每种资源有多个，那么成环不一定发生死锁，因为成环了，表示 进程 A 占有某个资源，而进程 B 也刚好请求这个资源，但是由于这个资源不只 1 个，而 进程A 可能只占有其中一个而已，所以进程 B 还是能够请求成功，所以成环不一定死锁

但是成环是死锁的必要条件之一

![img](https://pic4.zhimg.com/80/v2-b7e8ba213e6589be48c923a4b0bb43b4_720w.jpg)

图 3-7 就发生了死锁，因为 各个资源都被分配完了，但是又都请求别的资源，所以不会释放，导致死锁



**死锁检测算法：**

跟银行家算法类似，列出总资源数，剩余资源数，进程占有资源数，进程请求资源数

判断将剩余的资源分配给某个进程，是否能够帮助某个进程完成任务，然后回收任务，然后再进行分配

也就是看是否能够跟银行家算法一样找到一个安全序列

![img](https://pic2.zhimg.com/80/v2-fda5b7573cc9383034d75d8993277ed5_720w.jpg)



上图中，有三个进程四个资源，每个数据代表的含义如下：

- E 向量：资源总量
- A 向量：资源剩余量
- C 矩阵：每个进程所拥有的资源数量，每一行都代表一个进程拥有资源的数量
- R 矩阵：每个进程请求的资源数量

进程 P1 和 P2 所请求的资源都得不到满足，只有进程 P3 可以，让 P3 执行，之后释放 P3 拥有的资源，此时 A = (2 2 2 0)。P2 可以执行，执行后释放 P2 拥有的资源，A = (4 2 2 1) 。P1 也可以执行。所有进程都可以顺利执行，没有死锁。



## 5、死锁恢复

- 资源剥夺法：逐步 剥夺掉陷入死锁的进程的资源，但不撤销（终止）进程，直至死锁解除
- 进程回退法：将进程回退到某个检查点，这种要求系统建立检查点
- 进程撤销法：
  - 撤销所有陷入死锁的进程，然后继续运行
  - 逐步撤销陷入死锁的进程，回收资源并重新分配
- 系统重启法


## **[887. 鸡蛋掉落](https://leetcode-cn.com/problems/super-egg-drop/)**

```java
你将获得 K 个鸡蛋，并可以使用一栋从 1 到 N  共有 N 层楼的建筑。

每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。

你知道存在楼层 F ，满足 0 <= F <= N 任何从高于 F 的楼层落下的鸡蛋都会碎，从 F 楼层或比它低的楼层落下的鸡蛋都不会破。

每次移动，你可以取一个鸡蛋（如果你有完整的鸡蛋）并把它从任一楼层 X 扔下（满足 1 <= X <= N）。

你的目标是确切地知道 F 的值是多少。

无论 F 的初始值如何，你确定 F 的值的最小移动次数是多少？

 

提示：
1 <= K <= 100
1 <= N <= 10000
```



## **示例 1：**

```java
输入：K = 1, N = 2
输出：2
解释：
鸡蛋从 1 楼掉落。如果它碎了，我们肯定知道 F = 0 。
否则，鸡蛋从 2 楼掉落。如果它碎了，我们肯定知道 F = 1 。
如果它没碎，那么我们肯定知道 F = 2 。
因此，在最坏的情况下我们需要移动 2 次以确定 F 是多少。
```



## **示例 2：**

```java
输入：K = 2, N = 6
输出：3
```



## **示例 3：**

```java
输入：K = 3, N = 14
输出：4
```





## 方法①、递归（超时）

### 实现思路

要求的是安全楼层，那么如果鸡蛋在 F 楼碎了，但在 F - 1 楼没碎，那么安全楼层就是 F - 1
并且要求在所有可能发生的条件下找出最少的扔的次数，即所有的最坏情况中的最好情况

比如 N = 100，鸡蛋有很多个，

- 第一个鸡蛋在 50 楼扔，会存在对应的最坏的情况
- 第一个鸡蛋在 10 楼扔，会存在对应的最坏的情况
- 第一个鸡蛋在 x 楼扔，会存在对应的最坏的情况
- 我们就是要求这所有的最坏情况中最好的情况，即扔的次数最少的

如果 N == 1，那么无论有多少个鸡蛋，我们都只需要扔一次
如果 K == 1，只有一个鸡蛋，那么我们必须保证在鸡蛋不碎的情况下去尝试所有的楼层，那么怎么做？
    我们只能从 1 楼开始扔，如果 1 楼碎了，那么安全楼层为 0，如果没碎，那么到 2 楼扔，再到 3 楼扔、... 、N 楼扔
    最坏的情况需要扔 N 次

递归：我们从 F 楼扔，然后判断 碎 和 没碎 的递归情况
碎：    `superEggDrop(K - 1, F - 1) + 1`
没碎：`superEggDrop(K, N - F) + 1`



### 实现代码

```java
class Solution {
    public int superEggDrop(int K, int N) {
        if(N == 0 || K == 0){
            return 0;
        }
        if(K == 1){
            return N;
        }
        if(N == 1){
            return 1;
        }

        int maxCount = (int)1e9;
        for(int F = 1; F <= N; F++){
            maxCount = Math.min(maxCount, Math.max(superEggDrop(K - 1, F - 1), superEggDrop(K, N - F)) + 1);
        }
        return maxCount;
    }
}
```



## 方法②、记忆化递归（超时）

### 实现思路

添加缓存，因为某个楼层 N 可能存在重复计算

我们需要记录 K 个鸡蛋 和 N 个楼层这两个状态对应的最坏的扔鸡蛋数

### 实现代码

```java
class Solution {
    Integer[][] cache;
    public int superEggDrop(int K, int N) {
        /*
        K 个鸡蛋， N 层楼
        在 T 层进行实验，有碎和不碎两种情况
        如果碎了，那么安全楼层在 [1, T - 1]
        如果没碎，那么安全楼层在 [T, N]

        如果 N == 1，那么无论多少个鸡蛋都只需要扔一次
        如果 K == 1，那么由于只能扔一次，因此我们需要一层一层扔，最坏情况扔 N 次
        */
        //没有鸡蛋或楼层，那么扔的次数为 0
        if(cache == null){
            cache = new Integer[K + 1][N + 1];
        }
        if(cache[K][N] != null){
            return cache[K][N];
        }
        if(N == 0 || K == 0){
            return 0;
        }
        if(N == 1){
            return 1;
        }
        if(K == 1){
            return N;
        }
        //获取从每层楼扔，碎和不碎的情况
        int max = (int)1e9;
        for(int i = 1; i <= N; i++){
            max = Math.min(max, Math.max(superEggDrop(K - 1, i - 1), superEggDrop(K, N - i)) + 1);
        }
        return cache[K][N] = max;
    }
}
```



## 方法③、动规（超时）

### 实现思路

**思路跟 递归一样**

**状态转移方程：**
	`dp[i][j] `表示 有 i 个鸡蛋的情况下检测 j 层楼 最坏情况下，扔鸡蛋最少的次数
	在有 j 层楼的情况下，任选一层 k 扔鸡蛋，那么存在 碎 和 不碎 两种情况，取得其中最坏的情况
	`dp[i][j] = Math.max(dp[i][j], Math.max(dp[i - 1][k - 1], dp[i][j - k]) + 1);`



### 实现代码

```java
class Solution {
    public int superEggDrop(int K, int N) {
        int[][] dp = new int[K + 1][N + 1];
        //只有一个鸡蛋的情况
        for(int i = 1; i <= N; i++){
            dp[1][i] = i;
        }
        //只有一层楼的情况
        for(int i = 1; i <= K; i++){
            dp[i][1] = 1;
        }
        //遍历鸡蛋和楼层的状态
        for(int k = 2; k <= K; k++){
            for(int n = 2; n <= N; n++){
                dp[k][n] = (int)1e9;
                //遍历从 [1, n] 各个楼层扔的情况
                for(int j = 1; j <= n; j++){
                    dp[k][n] = Math.min(dp[k][n], Math.max(dp[k - 1][j - 1], dp[k][n - j]) + 1);
                }
            }
        }
        return dp[K][N];
    }
}
```


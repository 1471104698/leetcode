# [375. 猜数字大小 II](https://leetcode-cn.com/problems/guess-number-higher-or-lower-ii/)

*![image.png](https://pic.leetcode-cn.com/1598163716-yhlvTa-image.png)*

## 题意描述

给定一个数字 n，庄家选择 {1， n] 中的其中一个数 x，让我们猜

假如我们猜错了，那么需要支付 x 元，然后庄家会告诉我们我们猜的数是大了还是小了，然后我们继续猜，直到猜中为止

现在求保底需要多少钱才能够保证猜中 数 x

即 给定 **n ≥ 1，**计算你至少需要拥有多少现金才能确保你能赢得这个游戏。

## **示例:**

```java
n = 10, 我选择了8.

第一轮: 你猜我选择的数字是5，我会告诉你，我的数字更大一些，然后你需要支付5块。
第二轮: 你猜是7，我告诉你，我的数字更大一些，你支付7块。
第三轮: 你猜是9，我告诉你，我的数字更小一些，你支付9块。

游戏结束。8 就是我选的数字。

你最终要支付 5 + 7 + 9 = 21 块钱。
```



## 方法一：dp

### **实现思路**

这道题我们最开始会想到的就是二分，二分猜测的数字，一步步逼近

但是，这其实是错误的

二分：假设 n = 5，那么 就是 1 2 3 4 5， 在第一次猜数时，我们只能猜3

当 n = 5，假如我第一次猜3，那么至少需要 7 元；假如我第一次猜4，则只需要 6 元.

由此可见，二分解法不是最优解法

这道题其实跟 扔鸡蛋 这道题差不多，仔细看我们就会发现，这其实是找每一次 猜测的 最坏情况中最好的情况

比如 n = 5，第一次可以猜 1 2 3 4 5 其中一个，我们需要枚举：

猜测 1 最坏需要多少钱，猜测 2 最坏需要多少钱，猜测 3 最坏需要多少钱，猜测 4 最坏需要多少钱，猜测 5 最坏需要多少钱

在这几种情况中找到最好的一种作为第一次猜测，这样就能够节省钱

这就是求所有猜测情况的最坏情况中的最好情况

当然，不能是求理想情况下的钱数，比如 第一次猜测就猜中了，那么不需要任何钱，按实际想法来看，你要赢得游戏，那么保底就不可能寄托于这种运气成分的，而是要实际保证能够赢得游戏，这就是求最少的代价

#### **状态转移方程：**

本来使用一个一维数组就够了的，即 n = 6 时，假如我们猜测了 3

如果猜大了，那么就猜左边的 2 个数，dp[2]，即求在 2 个数中猜测出答案的代价

如果猜小了，那么就右边的 3 个数， dp[3]，即求在 3 个数中猜测出答案的代价

但是这么做是有问题的，因为我们需要计算成本，即当时猜测的那个数是多少，因此，我们需要使用二维数组，而不能压缩成一维，

因此，`dp[i][j] `表示从 [i, j] 这个区间数字中猜测出结果的最少代价

由于是区间 dp，我们需要反向处理，即 i  从右往左， j 从左往右，然后对 [i, j] 区间中取一个数 k，作为本次猜测的数字，分为 [i, k - 1] 和 [k + 1, j] 两部分求得结果

`dp[i][j] = `

`Math.min(dp[i][j], Math.max(dp[i][k - 1] , dp[k + 1][j]) + j)`

### **实现代码**

```java
class Solution {
    public int getMoneyAmount(int n) {
        /*
            这道题类似 扔鸡蛋，都是求 考虑的所有 最坏情况 中的 最好情况
        */
        int[][] dp = new int[n + 2][n + 2];

        for(int i = 2; i <= n; i++){
            for(int j = i - 1; j >= 1; j--){
                dp[j][i] = (int)1e9;
                for(int k = j; k <= i; k++){
                    dp[j][i] = Math.min(dp[j][i], Math.max(dp[j][k - 1], dp[k + 1][i]) + k);
                }
            }
        }
        return dp[1][n];
    }
} 
```


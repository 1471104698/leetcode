## **[105. ä»å‰åºä¸ä¸­åºéå†åºåˆ—æ„é€ äºŒå‰æ ‘](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)**



```java
æ ¹æ®ä¸€æ£µæ ‘çš„å‰åºéå†ä¸ä¸­åºéå†æ„é€ äºŒå‰æ ‘ã€‚

æ³¨æ„:
ä½ å¯ä»¥å‡è®¾æ ‘ä¸­æ²¡æœ‰é‡å¤çš„å…ƒç´ ã€‚
```



## **ç¤ºä¾‹**

```java
ä¾‹å¦‚ï¼Œç»™å‡º

å‰åºéå† preorder =Â [3,9,20,15,7]
ä¸­åºéå† inorder = [9,3,15,20,7]
è¿”å›å¦‚ä¸‹çš„äºŒå‰æ ‘ï¼š

    3
   / \
  9  20
    /  \
   15   7
```





## **å®ç°ä»£ç **

```java
class Solution {
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        /*
            æ— è®ºæ˜¯å‰åºéå†è¿˜æ˜¯ä¸­åºéå†ï¼Œå³å­æ ‘éƒ½æ˜¯æœ€åè¿›è¡Œéå†çš„
            åªæ˜¯æ ¹èŠ‚ç‚¹å’Œå·¦å­æ ‘çš„éå†é¡ºåºä¸åŒè€Œå·²
            å¦‚ä¸‹æ ‘
             3
            / \
           9  20
             /  \
            15   7
        å‰åºéå† preorder = [3,9,20,15,7]
        ä¸­åºéå† inorder = [9,3,15,20,7]
        å¯¹äºæ ¹èŠ‚ç‚¹ 3ï¼Œ 9 æ˜¯å®ƒçš„å·¦å­æ ‘ï¼Œé‚£ä¹ˆå‰åºå’Œä¸­åºåªæœ‰å·¦å­æ ‘æ˜¯å å‰é¢åŒæ ·ä½ç½®çš„ï¼Œ
        æ¯”å¦‚ 3 9 ä½œä¸ºæ ¹èŠ‚ç‚¹å’Œå·¦å­æ ‘åŒæ—¶å äº†å‰åºå’Œä¸­åºçš„å‰é¢ 2 ä¸ªä½ç½®ï¼Œåé¢çš„éƒ½æ˜¯å³å­æ ‘

        æˆ‘ä»¬æ ¹æ®å‰åºçš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ä½œä¸ºæ ¹ï¼Œç„¶åéå†ä¸­åºæ•°ç»„ï¼Œæ‰¾åˆ°ä¸­åºçš„è¯¥èŠ‚ç‚¹çš„ä½ç½®ï¼Œè¿™æ®µåŒºé—´å°±æ˜¯æ ¹èŠ‚ç‚¹ + å·¦å­æ ‘
        */

        int len = inorder.length;
        //é¢„å¤„ç†ï¼Œå°†ä¸­åºéå† å…ƒç´  å’Œ ç´¢å¼•ä½ç½®è¿›è¡Œæ˜ å°„ï¼Œé¿å…åç»­æŸ¥æ‰¾æŸä¸ªèŠ‚ç‚¹éƒ½å»éå†æ•°ç»„
        Map<Integer, Integer> map = new HashMap<>();
        for(int i = 0; i < len; i++){
            map.put(inorder[i], i);
        }
        return dfs(preorder, map, 0, len - 1, 0, len - 1);
    }
    private TreeNode dfs(int[] preorder, Map<Integer, Integer> map, int p_left, int p_right, int i_left, int i_right){
        if(p_left > p_right){
            return null;
        }
        if(p_left == p_right){
            return new TreeNode(preorder[p_left]);
        }
        //æ ¹èŠ‚ç‚¹å€¼
        int rootVal = preorder[p_left];
        //ä¸­åºéå†ä¸­æ ¹èŠ‚ç‚¹ä½ç½®
        int rootIdx = map.get(rootVal);

        TreeNode root = new TreeNode(rootVal);
        /*
            [1,2,3]
            [3,2,1]
             1
            /
           2
          /
         3
        */
        //å·¦å­æ ‘çš„æ•°ç»„é•¿åº¦ é€šè¿‡ä¸­åºéå†æ¥è·å–
        int len = rootIdx - i_left;
        root.left = dfs(preorder, map, p_left + 1, p_left + len, i_left, rootIdx - 1);
        root.right = dfs(preorder, map, p_left + len + 1, p_right, rootIdx + 1, i_right);
        return root;
    }
}
```



## **é”™è¯¯ä»£ç **

```
é”™è¯¯çš„åŸå› ï¼š
ä¸‹åˆ—ä»£ç è®¡ç®—å·¦å³å­æ ‘çš„èŒƒå›´æ˜¯è¢«ä¸‹åˆ—æ¡ˆä¾‹ç»™è¿·æƒ‘äº†
æ¯”å¦‚åœ¨ preorder ä¸­ä»¥ p_left ï¼ˆå³ èŠ‚ç‚¹ 3ï¼‰ä½œä¸ºæ ¹èŠ‚ç‚¹ï¼Œç„¶ååœ¨ inorder ä¸­æ‰¾åˆ° èŠ‚ç‚¹ 3 çš„ä½ç½®ï¼Œ rootIdx = 1
æˆ‘ä»¬å¯ä»¥çœ‹å‡ºï¼Œä¸­åºéå† rootIdx å‰é¢çš„èŒƒå›´å°±æ˜¯å·¦å­æ ‘ï¼Œåé¢çš„èŒƒå›´å°±æ˜¯å³å­æ ‘
æˆ‘ä»¬è¢«è¿·æƒ‘äº†ï¼Œå¯¼è‡´è®¤ä¸º å‰åºéå† p_left åˆ° å¯¹åº”ä¸­åºæ ¹èŠ‚ç‚¹çš„ rootIdx - 1 æ˜¯å·¦å­æ ‘
preorder = [3,9,20,15,7]
		   ğŸ‘†
inorder = [9,3,15,20,7]
			 ğŸ‘†
å®é™…ä¸ç„¶ï¼Œä¸‹åˆ—æ¡ˆä¾‹å°±æ˜¯å¯¼è‡´é”™è¯¯çš„æ¡ˆä¾‹
æˆ‘ä»¬åº”è¯¥è·å–çš„æ˜¯ i_left åˆ° rootIdx - 1 è¿™ä¸ªé•¿åº¦ä½œä¸ºå·¦å­æ ‘çš„èŒƒå›´ï¼Œç„¶ååº”ç”¨åˆ° å‰åºéå†æ•°ç»„ä¸­ï¼Œè€Œä¸æ˜¯ç›´æ¥å¯¹åº”ä¸‹æ¥
            [1,2,3]
              ğŸ‘†
            [3,2,1]
              ğŸ‘†
             1
            /
           2
          /
         3
```



```java
class Solution {
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        int len = inorder.length;
        //é¢„å¤„ç†ï¼Œå°†ä¸­åºéå† å…ƒç´  å’Œ ç´¢å¼•ä½ç½®è¿›è¡Œæ˜ å°„ï¼Œé¿å…åç»­æŸ¥æ‰¾æŸä¸ªèŠ‚ç‚¹éƒ½å»éå†æ•°ç»„
        Map<Integer, Integer> map = new HashMap<>();
        for(int i = 0; i < len; i++){
            map.put(inorder[i], i);
        }
        return dfs(preorder, map, 0, len - 1);
    }
    private TreeNode dfs(int[] preorder, Map<Integer, Integer> map, int left, int right){
        if(left > right){
            return null;
        }
        if(left == right){
            return new TreeNode(preorder[left]);
        }

        int rootVal = preorder[left];
        int rootIdx = map.get(rootVal);

        TreeNode root = new TreeNode(rootVal);
        root.left = dfs(preorder, map, left + 1, rootIdx);
        root.right = dfs(preorder, map, rootIdx + 1, right);
        return root;
    }
}
```


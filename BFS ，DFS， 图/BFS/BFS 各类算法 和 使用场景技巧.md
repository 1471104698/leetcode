## BFS 各类算法 和 使用场景技巧



### 普通的 BFS

```java
1、
普通的 BFS 只适用于 无权图
比如给你一个二维数组，其中有 或 没有障碍物，求到终点的最短路径，这种就是无权图
比如 126. 单词接龙 II，每次进行一次修改变为其他的单词，这种同样是无权图
比如 210. 课程表 II，求课程完成顺序 之类的
比如 994. 腐烂的橘子

它是按层级分的，每一次 while(size-- > 0) 循环结束就多加一层

当第一个到达终点的结果即为最短路径结果，因为是按层级分的，当第一次遇到结果的 level = 3，那么最短肯定为 3，因为后面再遇到 level 肯定 >= 3

BFS 正是因为内部元素是按层级递增的，所以才能够找到最短路径，如果里面不是递增，而是乱序的，那么第一个遍历到的结果不一定是最短路径
也就是说，正是因为 BFS 内部元素层级递增，所以才存在第一个到达终点的结果是最短路径之说


2、
BFS 同时分为 单向 BFS 和 多源 BFS

比如上面的两个示例 就是单向 BFS

而对于像 1162. 地图分析 这种，求 所有海洋区域到离它最近的陆地区域的距离中最大的距离，就是使用多源 BFS ，从各个陆地出发，得到将所有海洋同化为陆地的步数

又比如 同时从起点和终点 出发，直到两个触角相遇，这个就是双向 BFS
```



### 0·1 BFS

```java
普通的 BFS 在无权图上秀得飞起，但如果在带权图上，只能让位给 dijsktra 算法，O(n) -> O(nlogn)
但如果权值比较特殊，只有 0 和 1 的情况下（0 1 权值通常需要我们自己观察出来），那么就继续考虑使用 BFS，
但不是上述普通的 BFS， 而是 用双端队列实现的 0-1 BFS

比如给你起点和终点，从起点出发，每个位置都标有指定的方向
1、如果像指定方向走，那么不需要花费任何代价，即权值为 0
2、如果不按指定方向走，那么需要花费 1 代价，即权值为 1
3、问到达终点的花费的最少代价
（注意：这里求的不是到达终点的最短路径，而是能够到达终点的最少代价，即可以绕远路，但是这条远路所花费的代价必须比近路的代价少）
比如题目：1368. 使网格图至少有一条有效路径的最小代价

但是像 1293. 网格中的最短路径 这种给定消除障碍物机会的，求在机会内到达终点的最短路径
虽然看起来如果不消除障碍物和消除障碍物的权值跟 0 和 1 一样，但是实际上又不同，
像 1368 是可以无限花费代价，但是只要求能够到达终点的最小代价，意思是无论怎么走都必定能够到达终点，只是代价数不同
但是这道题，是给定了代价数，如果路径上一味消除，那么最终可能在中途失去了所有的消除机会，后面遇到障碍物就无法消除，导致路径走不通
因此，我们不能使用 01 BFS，而是使用普通的 BFS，记录某个位置节点的消除机会，因为中途过程中消除机会不够的会被淘汰
因此最终第一次到达结果的，必定是使用了不超过指定消除机会的次数到达的终点，并且层级数最低，因此即为最短路径
```


# 进程和线程的基础



## 1、进程的结构（PCB）

CPU 的主要功能就是执行 进程的指令

由于 CPU 可以同时执行多个进程，从 CPU 角度看，CPU 只是在执行指令，这个指令是通过 程序计数器 中存储的值来实现的，CPU 在同一时刻只能执行一条指令，所以在物理层面上所有的进程共用一个程序计数器，并且一次只能有一个进程的指令放在程序计数器中

从逻辑上看，CPU 并发执行多个进程，因此涉及进程的切换，这样看来，每个进程都需要有一个属于自己的 指令计数器来记录自己指令的执行位置，但需要记录的不仅仅是 指令执行位置这么简单，还需要保存进程的变量、进程的状态（阻塞还是就绪），以及 CPU 正在计算的中间结果 等

对于 进程的信息，需要一种能够描述和控制进程运行的数据结果，这种就是 PCB



PCB 的内容：

- 进程标识符，每个进程的标识符是唯一的，跟文件描述符一样
- 进程的当前状态：标明进程是就绪还是阻塞状态，如果是就绪，那么就是等待 CPU 调度，如果是阻塞，那么需要在 PCB 中记录阻塞的原因
- 进程资源：所有的文件描述符、持有的 IO 设备等
- 进程优先级
- 进程的信号量
- CPU 保护现场：程序计数器的内容、通用寄存器内容等



## 2、用户态 和 内核态

> ### 用户态 和 内核态的关系

**内存假设为 4G，那么内核态和用户态共用瓜分这 4G 内存，即将一部分作为内核态，一部分作为用户态**



内核态中的程序可以访问的资源最多，权限最大，安全性要求最高

用户态中的程序可以访问的资源有限，但安全性要求低



凡是涉及到计算机资源的，都需要在内核态中运行，凡是只跟用户数据相关的，则在用户态运行

计算机资源：文件操作、内存管理

用户资源：比如一个进程的变量之类的

用户态的程序对于文件只能有一个文件描述符，具体的操作通过传输文件描述符给内核态，让 CPU 进入内核态中进行操作



> ### 什么时候用户态会切换到内核态？

- 系统调用：IO 操作
- 异常：当前i进程在用户态时，发生了异常事件，就会发生切换，比如 缺页异常
- 设备中断：外设完成用户请求时，会向 CPU 发送中断信号



> ### 系统调用

内核控制着计算机的硬件资源，并提供上层应用程序运行的环境

用户态看作是应用程序的活动空间，需要依赖于内核提供的资源运行，包括 IO 资源、存储资源等

内核为了方便用户态的应用程序能够访问这些资源，内核为用户态提供了访问的接口：系统调用



向公用库函数 和 shell 上连应用程序，下连系统调用，它们封装了系统调用，用户程序只需要通过 shell  和 调用函数就可以访问系统调用

shell 可以是 Linux 那种命令行，也可以是 windows 那种 图形化节面，反正就是用户跟操作系统交互的窗口



![这里写图片描述](https://img-blog.csdn.net/2018040909190679?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0pIX1poYWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)



像 C 中的库函数 malloc()，内部就是调用系统调用 sbrk() 这个函数来告知内核进行内存分配的

等调用了 sbrk()，就发生了用户态到内核态的切换，类似的还有 print()、write() 之类的，内部都是调用系统调用



## 3、线程



> ### 为什么使用线程？

我们举个例子，假设你要编写一个视频播放器软件，那么该软件功能的核心模块有三个：

- 从视频文件当中读取数据；
- 对读取的数据进行解压缩；
- 把解压缩后的视频数据播放出来；

对于单进程的实现方式，我想大家都会是以下这个方式：

![img](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcvw4t9kicec370n3cvX2JS929V7rcLXiaaB16boR9VraolG9Fgc9NpnxOSlHx7No6t0zSPrscaeuaA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

（这里需要说明一下，java 中，我们运行一个类 main() 方法的时候，它就是一个独立的进程，当我们运行两个类的 main() 方法的时候，它们就是两个独立的进程，互不干扰）

因此上面的这种方式是运行在一个类中的，是一个进程

单进程是按顺序执行的，即必须先 Read() 执行完毕后再 解压缩数据，再进行播放

由于需要边读取边播放，因此我们每读取 1 个字节就进行解压缩再播放，这样就可以边读取压缩边播放

对于单进程的这种方式，存在以下问题：

- 可能由于 CPU 的原因，我们在 Read() 方法这里卡住了，那么就会导致半天才能数据解压和播放，体验不友好
- 单进程的方式，各个函数之间不是并发执行的，而是顺序执行的影响效率

那改成多进程的方式：

![img](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcvw4t9kicec370n3cvX2JS9CInoGdDVyYvtTfju7gVeKLjDNOMmul4kPzicTbczNiaBSzGiaEzDXtYTA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

这就又产生一个问题了，多进程，其实就是多个类，一个类执行一个函数，那么这几个类怎么进行共享数据？比如你多个类同时执行 main() 方法，数据能共享吗？

不能吧！！！！

那到底如何解决呢？需要有一种新的实体，满足以下特性：

- 实体之间可以并发运行；
- 实体之间共享相同的地址空间；

这个新的实体，就是**线程( Thread )**，线程之间可以并发运行且共享相同的地址空间。



> ### 什么是线程？

通过上面我们可以看出，**线程是进程的一条执行路线流程**

即 Read() 可以作为一个线程，解压缩数据可以作为一个线程，播放可以作为一个线程

线程是在进程的基础上产生的，多个线程共享进程的资源，但又有自己的寄存器和栈，这样，就既能共享资源，又能有独立的运行空间而不受其他线程的影响，比如上面的 Read() 线程，它能跟别的线程一起 共享 进程的全局变量等，但又存在自己的局部变量



> #### 线程与进程的比较

**进程是资源分配的基本单位， 线程是调度的基本单位**。

这里我们可以看出来，最开始讲的进程是调度的基本单位，等到线程出来后，进程单单就变成了资源分配的基本单位了，即是提供一个资源共享的平台给它内部的线程使用，单单只是作为一个交流平台而已，所有的线程都可以来这里拿数据资源

所以，由于资源是共享的，所有线程都能拿到，才存在线程安全的问题，即到底是谁先拿到，以及谁做的改变才有效等问题



## 4、进程 和 线程的上下文切换

线程占有的：栈、寄存器、程序计数器

线程共享的：堆、全局变量、静态变量

进程占有的：地址空间、全局变量、文件描述符、子进程、信号量 



> ### 进程的上下文

- 系统级上下文：PCB 以及 逻辑地址到物理地址的映射（页表、段表）
- 寄存器上下文：CPU 中所有寄存器的集合，比如指令寄存器（指令寄存器存储的是从程序计数器拿出来的指令，用于执行）
- 用户级上下文：程序段、数据段、交换到外存（swap 区）的分页、分段





> ### 进程上下文切换

进程上下文切换的过程：

- 保存 CPU 信息
- 对被中断进程进行 PCB 更新（因为 PCB 内容是旧的）
- 将被中断进行的 PCB 移入到队列中（如果是时间片到了那么移到就绪队列，如果是 IO 阻塞那么移入到 阻塞队列）
- 进程调度选择一个新进程，将它的 PCB 刷新进来，同时获取 PCB 中的 页表、段表等 刷新地址空间
- 恢复新进程的 CPU 现场信息（CPU 指令寄存器、程序计数器 等）



> ### 线程上下文切换

对于同一个进程中的多个线程，每个线程都有自己独立的 工作内存（栈 和 指令寄存器），所以这些需要进行保存和更新

**对于不同进程中的线程切换，那么所有东西都是不共享的，那么切换就跟进程上下文切换一样了**



> ### 为什么说上下文切换导致 CPU 效率降低

 一个CPU主频是 2.6GHz，这意味着每秒可以执行：2.6*10^9 个指令，那么每个指令的时间大概是0.38ns！

而一次上下文切换，将近需要耗时2000ns！而这个时间内，CPU什么都干不了，只是做了保存上下文都动作！





## 5、多进程 和 多线程

> ### 多 CPU 和 多核 CPU 与 进程 和 线程 的关系

首先我们需要知道，进程作为 操作系统资源分配的基本单位，线程是 CPU 调度的基本单位

多 CPU 表示有多个 CPU，多核 CPU 表示一个 CPU 有多个核

我们需要知道，一个 CPU 对应一个进程，而 CPU 的核对应进程中的线程

即如果有多个 CPU，那么多个进程是并行执行的，如果 CPU 有多个核，那么多个线程是并行执行的

如果只有一个 CPU，那么多个进程是并发执行的，如果 CPU 只有一个核，那么多个线程是并发执行的



CPU 是看不到进程的，CPU 一旦进入了进程内部，只能调用线程

而一个 CPU 对应一个进程的原因就是一个 CPU 在同一时刻只能进入到一个进程内部，调用里面的线程

一个 CPU 的多核 是能够在同一时间调用同一个进程的多个线程



> ### CPU 密集型 和 IO 密集型

CPU 密集型表示任务需要大量的计算，需要大量占用 CPU 的资源

IO 密集型表示任务 99%情况下进行的是 IO 操作，IO 操作中 线程 会挂起，所以不会占用太大的 CPU 资源



- CPU 密集型由于需要大量的 CPU 资源，或者 需要重复的计算，因此多个 CPU 情况下可以开多个 (相同) 进程进行计算，高效使用了 CPU 资源

- IO 密集型由于大多数情况下需要 IO，不怎么需要 CPU 资源，而 IO 操作的时候线程会挂起，CPU 会没事干，所以可以开多个线程来运行，这样 一个线程挂起了，CPU 可以去处理另外一个线程
  - 由于 IO 操作时，基本很大的时间都耗费在寻道上，而这个时间 CPU 不知道可以执行多少条命令了，如果 CPU 在 IO 时空闲着不动，那这效率，，，因此 CPU 可以在 IO 的时候去执行其他的线程





## 6、僵尸进程 和 孤儿进程

每个进程都有自己的唯一一个 ID 号（PID），并且都附带一个它的父进程的 ID 号（PPID），进程死亡时，ID 号会被回收

### 1、孤儿进程

子进程还没有结束，而父进程自己先执行完退出了，那么这个子进程就是一个孤儿进程，它会被交给 init 进程进行管理

相比僵尸进程，孤儿进程不会占用资源，因为它最终还是会被回收的



### 2、僵尸进程



子进程死亡后，它的 PCB 会交给父进程进行处理释放，但是如果父进程只顾着指向自己的代码，而一直没去释放这个 PCB，那么子进程就会变成一个僵尸进程

僵尸进程实际上是一个已经死掉的进程，即已经执行完所有代码，释放了几乎所有的内存空间，没有任何可执行的代码指令，也不能被调度，仅仅只是在进程列表保留一个位置而已

如果父进程一直在进行循环，而不去处理这个僵尸进程，那么这个僵尸进程的 PCB 基本不会被释放

如果父进程自己结束了也没有处理这个僵尸进程，那么这个僵尸进程会交给 init 进程（1 号进程）进行处理



**需要注意的是，每个进程都必定会经历过僵尸进程，只是时间长度而已**

如果一个子进程 调用 exit() 退出后，我们还没来得及调用 ps 命令查看，它就被父进程释放了，但是在子进程 exit() 到被父进程释放的这个过程，它就是属于僵尸进程的



**僵尸进程的危害：**僵尸进程如果一直不被释放，但是它的 PCB（进程号、终止状态、CPU 运行时间）会占用系统资源，虽然不大，但是一旦僵尸进程一多，那么占用的就多了，并且会占用进程号，每个进程的进程号是 唯一的，僵尸进程的进程号是不会被回收的



**预防僵尸进程的方法**

> ### 1、wait()

父进程调用 wait() 方法，等待任意一个子进程退出后，释放掉子进程的 PCB，然后返回，该方法会阻塞父进程，如果子进程全都迟迟不退出，那么父进程会一直阻塞，父进程无法继续执行自己的代码，这样效率低得一批



> ### 2、`waitpid(int pid,int *status,int options)`

该方法可以控制阻塞和非阻塞，内部有 3 个参数，第一个 是 pid, pid 取不同的值有不同的效果

- pid > 0，指定等待进程 ID == pid 的子进程，无论其他子进程是否退出，只要这个子进程没有退出，那么该方法就不会退出
- pid == -1，等待任意一个进程退出，跟 wait() 一样的效果
- pid == 0，等待同个进程组的任意一个进程，如果子进程加入了别的进程组，那么直接忽略该子进程
- pid < -1，等待指定进程组的任意一个子进程，进程组 ID == pid 的绝对值

上面这个 pid 等待的模式的，但是好像还是会阻塞啊，怎么使它不阻塞？

第三个参数 options，它可以控制是阻塞还是不阻塞，如果是 0 ，那么就是阻塞，如果是  WNOHANG ，那么就是非阻塞

当传入 WNOHANG 时，那么就查看对应的子进程是否已经退出，如果退出了，那么进行处理，如果没有，那么直接返回



我们可以发现，wait() 其实就是 waitpid() 中的 pid == -1 的一个包装而已，代码类似如下：

```java
public int wait(){
	return waitpid(-1, null, 0);
}
```



> ### 3、信号

**信号 是 进程间通信的方式之一**

直接调用 wait() 之类的方法显然是不明智的，阻塞进程效率太低

因此存在 信号 这个方法（参考进程间通信方法的 信号, kill 命令也是使用的信号），当子进程 exit 退出后，内核会发送一个  SIGCHLD（子进程退出信号） 信号给父进程，父进程接收到信号后，可以调用 wait() 方法去进行处理，不过当然也可以选择忽略这个信号



缺点：当创建 5 个子进程的时候，如果这 5 个子进程同时挂了，都给父进程发送  SIGCHLD 信号，那么可能其中的  SIGCHLD 信号到达时，父进程正在处理某个子进程的  SIGCHLD 信号，因此这个  SIGCHLD 信号会丢失，而 内核并没有使用队列等方式来存储同类信号，因此丢失了也就丢失了，所以最终可能会存在 一两个 僵尸进程没有被处理

因此，为了解决这个问题，只能调用 waitpid() 来进行处理

```java
for (;;) {
    //循环等待子进程退出，直到不存在任何子进程时，返回了 0
    if (waitpid(-1, NULL, WNOHANG) == 0)
        break;
}
```





> ### 4、两次 fork()

父进程 A fork) 出一个子进程 B，然后调用 waitpid(子进程 B 的 pid, null, 0) 等待给子进程 B 收尸

然后子进程 B 创建出真正需要的子进程，等创建完成后，子进程 B 调用 exit() 方法退出，这样 B 创建的子进程就变成了孤儿进程，交给 init 进程进行管理，也就不会变成僵尸进程了，这些子进程 和 进程 A 是爷孙关系，没有直接的父子关系，所以 A 不会接管这些进程

而父进程 A 只需要在 子进程 B 调用 exit() 后给它收尸，然后就可以去干自己的事了，这样就避免了僵尸进程



> ### 机器出现大量的僵尸进程

处于 defunct（已死）状态的僵尸进程是不能被 kill 命令解决的，因为它已经死了

如果机器出现大量的僵尸进程，占用了大量的系统资源，解决方法有二：

- 重启服务器电脑，这是最简单的，但是如果服务器上运行有其他不能关闭的程序，那么这个方法代价就很大了
- 找到 defunct 状态的僵尸进程的父进程，将该进程的父进程杀掉，则此 defunct 状态的僵尸进串池自动消失
  - 使用 ps -ef | grep defunct | more 找到僵尸进程
  - 使用 ps -ef | grep defunct_process_pid 找到父进程
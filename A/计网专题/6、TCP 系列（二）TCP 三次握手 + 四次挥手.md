# TCP 三次握手 + 四次挥手



## 1、三次握手



**三次握手过程：**

服务器 socket bind() 绑定监听的 ip 和 端口，然后调用 accept() 处于 LISTEN 状态

- 第一次握手：客户端 socket 调用 conncet()，内核创建一个 TCP 报文，初始化一个 seq_1，放在 序列号位置，标志位置为 SYN，发送报文，处于 SYN_SENT 状态（SYN 发送）
- 第二次握手：服务端 收到 SYN 包，内核创建一个 TCP 报文，初始化一个 seq_2 放在序列号位置，然后将确认号位置设置为 seq_1 + 1，标志位置为 SYN 和 ACK，发送报文，处于 SYN_RCVD 状态（SYN 接收）
- 第三次握手：客户端收到 SYN + ACK 包，内核创建一个 TCP 报文，序列号设置为 seq_1 = seq_1 + 1，确认号设置为  seq_2 + 1，标志位置为 ACK，发送报文，此时处于 ESTABLISHED 状态（已连接）
- 服务端收到 ACK，处于 处于 ESTABLISHED 状态（已连接）



**第一、二次握手不能传输数据，第三次握手可以顺便携带用户数据**



> ###  抓包分析

*![image.png](https://pic.leetcode-cn.com/1601703573-JVpYxb-image.png)*

```
源ip				目的 ip		 协议 包长	  源端口->目的端口 标志位	序列号seq + 确认号ACK
10.21.71.101	118.178.116.8	TCP	66		52296 → 80 	[SYN] Seq=0 Win=64240 Len=0 MSS=1460
118.178.116.8	10.21.71.101	TCP	66		80 → 52296 	[SYN, ACK] Seq=0 Ack=1 Win=29200 Len=0 MSS=1300
10.21.71.101	118.178.116.8	TCP	54		52296 → 80 	[ACK] Seq=1 Ack=1 Win=131072 Len=0
```

第一次握手 发送方 只有一个自己的随机序列号 seq_1（实际上都是 seq，这里为了好区分进行标号），因为还没有交流，没有对方的序列号，标志位为 【SYN】

第二次握手 接收方 发送一个自己的随机序列号 seq_2，以及一个 ACK = seq_1 + 1，既告知了对方自己收到了它的序列号，并且又表明了下一个希望收到的包的 seq_1 的值，标志位为 【SYN,ACK】

第三次握手 发送方 发送一个 ACK = seq_2 + 1，告知已经收到对方的序列号，并且希望下一个收到的 seq_2 的值





> ### 2、为什么是三次握手？不是两次、四次？

有 3 个原因：

- 确保双方的发送和接受能力都正常
  - 如果只有两次握手，即 SYN、SYN + ACK，那么接收方无法确保发送方的接收能力正常

- 三次握手才可以避免历史连接（主要原因）
  - 如果只有两次握手，那么假设发送方最开始发送一个 SYN，后面由于网络拥堵，发送方又重发了一个 SYN，这样当第一个 SYN 到达时，接收方发送完一个 SYN + ACK 后就将接收方将 socket 连接放入到 accept 队列中，后续重发的 SYN 又到达服务端，那么这时候服务端无法确认这是否是历史连接，同样的发送一个 SYN + ACK 后就放入 accept 队列中，造成重复连接，导致混乱
  - 如果是三次握手，那么第二个 SYN 在接收方发送 SYN + ACK，发送方接收到后，对比序列号发现这不是正常的连接，因此回送一个 RST 包告知接收方中断该连接
- 三次握手才可以同步双方的初始序列号
  - 如果只有两次握手，发送方知道接收方同步了自己的序列号，但是接收方不知道发送方是否同步了自己的序列号，由于序列号在后面的数据传输意义重大，所以如果没有同步的话那么数据就无法正常接收





## 2、四次挥手



客户端和服务端都可以主动发起关闭连接

**四次挥手过程：**

- 第一次挥手：发送方调用 close() 发起 FIN + ACK 数据包，表示数据发送完毕，可以关闭连接，处于 FIN_WAIT1 状态
- 第二次挥手：
  - 服务端收到 FIN + ACK，发送一个 ACK，表示确认收到数据包，但是可能还有数据没有处理完毕，或者还有数据没有发送，不能关闭连接，处于 CLOSE_WAIT 状态
  - 发送方收到 ACK，处于 FIN_WAIT2 状态
- 第三次挥手：服务端数据处理或者发送完毕，调用 close()，发送 FIN，处于 LAST_ACK 状态
- 第四次挥手：
  - 客户端收到 FIN，发送一个 ACK，处于 TIME_WAIT 状态
  - 服务端收到 ACK 后，处于 CLOSED 状态
  - 客户端等到 TIME_WAIT 超时，也进入 CLOSED 状态



主动关闭的有 TIME_WAIT 状态

被动关闭的有 CLOSE_WAIT 状态



> ### 抓包分析

*![image.png](https://pic.leetcode-cn.com/1601705109-tpmVPo-image.png)*

```
源ip				目的 ip		 协议 包长	  源端口->目的端口 标志位	序列号seq + 确认号ACK
118.178.116.8	10.21.71.101	TCP	60		80 → 52296 [FIN, ACK] Seq=357 Ack=1539 Win=32768 Len=0
10.21.71.101	118.178.116.8	TCP	54		52296 → 80 [ACK] Seq=1539 Ack=358 Win=130816 Len=0
10.21.71.101	118.178.116.8	TCP	54		52296 → 80 [FIN, ACK] Seq=1539 Ack=358 Win=130816 Len=0
118.178.116.8	10.21.71.101	TCP	60		80 → 52296 [ACK] Seq=358 Ack=1540 Win=32768 Len=0
```

同样是存在 序列号 seq 和 确认号 ACK



**以下是对 FIN + ACK 包的分析：**

*![image.png](https://pic.leetcode-cn.com/1601705467-DrMzYF-image.png)*

![1601705764639](C:\Users\蒜头王八\AppData\Roaming\Typora\typora-user-images\1601705764639.png)

# [字节：140. 单词拆分 II](https://leetcode-cn.com/problems/word-break-ii/)

![1595741122058](C:\Users\蒜头王八\AppData\Roaming\Typora\typora-user-images\1595741122058.png)

```java
给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，在字符串中增加空格来构建一个句子，使得句子中所有的单词都在词典中。返回所有这些可能的句子。

说明：
分隔时可以重复使用字典中的单词。
你可以假设字典中没有重复的单词。
```



## **示例 1：**

```java
 输入:
s = "catsanddog"
wordDict = ["cat", "cats", "and", "sand", "dog"]
输出:
[
  "cats and dog",
  "cat sand dog"
]
```



## **示例 2：**

```java
输入:
s = "pineapplepenapple"
wordDict = ["apple", "pen", "applepen", "pine", "pineapple"]
输出:
[
  "pine apple pen apple",
  "pineapple pen apple",
  "pine applepen apple"
]
解释: 注意你可以重复使用字典中的单词。
```



## **示例 3：**

```java
输入:
s = "catsandog"
wordDict = ["cats", "dog", "sand", "and", "cat"]
输出:
[]
```



## 方法①、dfs + 前缀树

### 实现思路

题目给定字典序列 wordDict，我们可以创建一棵前缀树，将字典全部插入到前缀树中

然后查找可以分割的索引位置，进行分割，并对剩下的字符串进行 dfs



#### 步骤：

s = "catsandog"
wordDict = ["cats", "dog", "sand", "and", "cat"]

我们将 wordDict 插入到前缀树中

字符串 s 的各个字符对应索引如下：

c a t s a n d o g

0 1 2 3 4 5 6 7 8

- 我们从前往后，通过前缀树查找后，发现 2 和 3 位置可以进行分割，即前面可以分割为 cat 或者 cats

- 我们先分割 2 位置，然后对剩下的字符串 s a n d o g 进行 dfs 同样操作，直到整个字符串都处理完

- 然后我们回溯，再分割 3 位置，然后对剩下的字符串 a n d o g 进行 dfs，直到整个字符串都处理完
- dfs 过程中，我们使用 StringBuilder 进行拼接



但是在以下测试用例超时了：(后面会说明这个用例)

**"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
["a","aa","aaa","aaaa","aaaaa","aaaaaa","aaaaaaa","aaaaaaaa","aaaaaaaaa","aaaaaaaaaa"]**



### 实现代码

```java
class Solution {
    public List<String> wordBreak(String s, List<String> wordDict) {
        trie = new Trie();
        for(String str : wordDict){
            trie.insert(str);
        }

        res = new ArrayList<>();
        map = new HashMap<>();
        dfs(new StringBuilder(), s, 0);
        return res;
    }
    List<String> res;
    Trie trie;
    private void dfs(StringBuilder sb, String s, int i){
        int len = s.length();
        if(i == len){
            //删除最后一个空格
            sb.deleteCharAt(sb.length() - 1);
            res.add(sb.toString());
            return;
        }
        int sblen = sb.length();
        List<Integer> indexs = trie.search(s, i);
        for(int index : indexs){
            sb.append(s.substring(i, index + 1)).append(" ");
            dfs(sb, s, index + 1);
            sb.setLength(sblen);
        }
    }
    
	//前缀树模板
    class TrieNode{
        TrieNode[] childern;
        //记录当前节点是否是某个单词的结尾
        boolean end = false;
        public TrieNode() {
			childern = new TrieNode[26];
        } 
	}
    
    class Trie {

        TrieNode root;

        public Trie() {
            root = new TrieNode();
        }
        
        public void insert(String word) {
            TrieNode cur = root;
            for(int i = 0; i < word.length(); i++){
                int ch = word.charAt(i) - 'a';
                if(cur.childern[ch] == null){
                    cur.childern[ch] = new TrieNode();
                }
                cur = cur.childern[ch];
            }
            cur.end = true;
        }
		
        //查找可以分割的索引位置集合
        private List<Integer> search(String word, int i){
            List<Integer> res = new ArrayList<>();
            TrieNode cur = root;
            for(; i < word.length(); i++){
                int num = word.charAt(i) - 'a';
                if(cur.childern[num] == null){
                    return res;
                }
                cur = cur.childern[num];
                if(cur.end){
                    res.add(i);
                }
            }
            return res;
        }
    }
}
```



## 方法②、dp 

### 实现思路

s = "catsandog"
wordDict = ["cats", "dog", "sand", "and", "cat"]

s 中，catsand 可以分割为 [cats, and] 和 [cat, sand]，因此我们遍历过程中，存储好 [0, i] 位置可以分割成的所有字符串，比如 catsand，它可以分割的字符串集合为 ["cat sand", "cats, and"] ，那么我们后面的字符串 dog 就可以直接跟这两个序列进行拼接, 变成 ["cat sand dog"] 和 ["cats and dog"]

我们同时需要跟 139.单词拆分一样，使用一个 dp 数组记录哪个位置能够进行拆分

dp[i] = true; 表示 [0, i] 位置可以分割为 wordDict  中存在的单词

​	

```java
boolean[] dp = new boolean[len + 1];
dp[0] = true;
/*
strs[i] 存储 [0, i] 分割组成的所有字符串，
比如  catsand 中 strs[6] = ["cat sand dog", "cats and dog"]
*/
List<String> strs = new List[len + 1];
for(int i = 1; i <= len; i++){
    for(int j = 0; j < i; j++){
        String str = s.substring(j, i);
        /*
        只有 [0, j) 可以分割为字典中的单词，以及 [j, i] 这个子串存在于字典中时，才能够进行拼接
        c a t s a n d o g
        0 1 2 3 4 5 6 7 8
        比如 dp[6] = true，并且 dog 存在于字典中，因此 dog 才可以跟前面的 catsand 进行拼接
        */
        if(dp[j] && set.contains(str)){
            //进行字符串拼接，跟上面的 dog 和 前面的拼接例子一样
        }
    }
}
```



### 实现代码

```java
class Solution {
    public List<String> wordBreak(String s, List<String> wordDict) {
        int len = s.length();
		
        //将字典存放在 set 中，方便 O(1) 查找
        Set<String> set = new HashSet<>(wordDict);

        boolean[] dp = new boolean[len + 1];
        dp[0] = true;
        
        
        List<String>[] strs = new List[len + 1];
        for(int i = 0; i <= len; i++){
            strs[i] = new ArrayList<>();
        }        
        for(int i = 1; i <= len; i++){
            for(int j = 0; j < i; j++){
                String str = s.substring(j, i);
                if(dp[j] && set.contains(str)){
                    
                    dp[i] = true;
                    
                    //进行字符串拼接，跟上面的 dog 和 前面的拼接例子一样
                    if(j == 0){
                        strs[i].add(str);
                    }else{
                        for(String ss : strs[j]){
                            StringBuilder sb = new StringBuilder(ss).append(" ").append(str);
                            strs[i].add(sb.toString());
                        }
                    }
                }
            }
        }
        return strs[len];
    }
}
```



但是遗憾的是，上面的方法仍然是在方法① 中的案例超时：

**"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"**
**["a","aa","aaa","aaaa","aaaaa","aaaaaa","aaaaaaa","aaaaaaaa","aaaaaaaaa","aaaaaaaaaa"]**



这时我们看了看别人 AC 的方法，基本都是使用 139 的方法提前判断 s 是否能够分割，如果不能，那么直接返回，

上面那个测试属于无法分割的例子，因此直接返回了，而如果把中间的 b 改成 a ，那么那些 AC 的方法也超时了

这大概就是面向测试用例编程，不过没办法，我也只能进行提前判断



## 方法③、dp 优化

### 实现思路

使用 O(n) 时间提前预处理 字符串可以分割的位置

如果 最后 dp[len] == false，那么表示原串 s 无法进行分割，提前返回，否则，按照 方法② 进行分割



### 实现代码

```java
class Solution {
    public List<String> wordBreak(String s, List<String> wordDict) {
        int len = s.length();

        Set<String> set = new HashSet<>(wordDict);

        /*
        dp 处理，dp[i] 表示 [0, i] 是否能够 通过分割 或 不分割 使得处理后的字符串存在于字典中
        比如  s = catsand, wordDict = ["cat", "sand"]
        我们可以通过分割成 cat 和 sand 使得分割后的字符串存在于字典中, dp[i] = true;
        比如  s = catsand, wordDict = ["catsand"]
        我们可以不分割就使得原字符串存在于字典中, dp[i] = true;
        比如  s = catsand, wordDict = ["cats"]
        我们无论分割还是不分割都无法使得字符串都存在于字典中, dp[i] = false;
        */
        boolean[] dp = new boolean[len + 1];
        dp[0] = true;
        for(int i = 1; i <= len; i++){
            for(int j = 0; j < i; j++){
                if(dp[j] && set.contains(s.substring(j, i))){
                    dp[i] = true;
                }
            }
        }
        //原字符串 s 无法处理成字典中的字符串
        if(!dp[len]){
            return new ArrayList<>();
        }
        List<String>[] strs = new List[len + 1];
        for(int i = 0; i <= len; i++){
            strs[i] = new ArrayList<>();
        }        
        for(int i = 1; i <= len; i++){
            if(!dp[i]){
                continue;
            }
            for(int j = 0; j < i; j++){
                if(!dp[j]){
                    continue;
                }
                String str = s.substring(j, i);
                if(!set.contains(str)){
                    continue;
                }
                if(strs[j].isEmpty()){
                    strs[i].add(str);
                }else{
                    for(String ss : strs[j]){
                        strs[i].add(new StringBuilder(ss).append(" ").append(str).toString());
                    }
                }
            }
        }
        return strs[len];
    }
}
```


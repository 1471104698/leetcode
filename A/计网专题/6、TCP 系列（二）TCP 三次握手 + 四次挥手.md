# TCP 三次握手 + 四次挥手



## 1、三次握手



**三次握手过程：**

最开始服务端处于 LISTEN 状态

- 客户端 初始化一个 seq_1，发送 SYN 包给服务端，处于 SYN_SENT 状态（SYN 发送）
- 服务端接收到后，初始化一个 seq_2，以及一个 ACK = seq_1 + 1，发送 SYN + ACK 包给客户端，处于 SYN_RCVD 状态（SYN 接收）
- 客户端收到后，seq_1 = seq_1 + 1，ACK = seq_2 + 1，然后发送一个 ACK 包给服务端，此时处于 ESTABLISHED 状态（已连接）
- 服务端受到 ACK 后，处于 处于 ESTABLISHED 状态（已连接）



**第一、二次握手不能传输数据，第三次握手可以顺便携带用户数据**



> ###  抓包分析

*![image.png](https://pic.leetcode-cn.com/1601703573-JVpYxb-image.png)*

```
源ip				目的 ip		 协议 包长	  源端口->目的端口 标志位	序列号seq + 确认号ACK
10.21.71.101	118.178.116.8	TCP	66		52296 → 80 	[SYN] Seq=0 Win=64240 Len=0 MSS=1460
118.178.116.8	10.21.71.101	TCP	66		80 → 52296 	[SYN, ACK] Seq=0 Ack=1 Win=29200 Len=0 MSS=1300
10.21.71.101	118.178.116.8	TCP	54		52296 → 80 	[ACK] Seq=1 Ack=1 Win=131072 Len=0
```

第一次握手 发送方 只有一个自己的随机序列号 seq_1（实际上都是 seq，这里为了好区分进行标号），因为还没有交流，没有对方的序列号，标志位为 【SYN】

第二次握手 接收方 发送一个自己的随机序列号 seq_2，以及一个 ACK = seq_1 + 1，既告知了对方自己收到了它的序列号，并且又表明了下一个希望收到的包的 seq_1 的值，标志位为 【SYN,ACK】

第三次握手 发送方 发送一个 ACK = seq_2 + 1，告知已经收到对方的序列号，并且希望下一个收到的 seq_2 的值





> ### 2、为什么是三次握手？不是两次、四次？

有 3 个原因：

- 确保双方的发送和接受能力都正常
  - 如果只有两次握手，即 SYN、SYN + ACK，那么接收方无法确保发送方的接收能力正常

- 三次握手才可以避免历史连接（主要原因）
  - 如果只有两次握手，那么假设发送方最开始发送一个 SYN，后面由于网络拥堵，发送方又重发了一个 SYN，这样当第一个 SYN 到达时，接收方发送完一个 SYN + ACK 后就将接收方将 socket 连接放入到 accept 队列中，后续重发的 SYN 又到达服务端，那么这时候服务端无法确认这是否是历史连接，同样的发送一个 SYN + ACK 后就放入 accept 队列中，造成重复连接，导致混乱
  - 如果是三次握手，那么第二个 SYN 在接收方发送 SYN + ACK，发送方接收到后，对比序列号发现这不是正常的连接，因此回送一个 RST 包告知接收方中断该连接
- 三次握手才可以同步双方的初始序列号
  - 如果只有两次握手，发送方知道接收方同步了自己的序列号，但是接收方不知道发送方是否同步了自己的序列号，由于序列号在后面的数据传输意义重大，所以如果没有同步的话那么数据就无法正常接收





## 2、四次挥手



客户端和服务端都可以主动发起关闭连接

**四次挥手过程：**

- 发送方发起 FIN + ACK 数据包，表示关闭连接，处于 FIN_WAIT1 状态
- 接收方收到后，发送 ACK 数据包，表示收到，处于 CLOSE_WAIT 状态
- 发送方收到 ACK 后，处于 FIN_WAIT2 状态
- 如果接收方有数据进行处理，那么会等待数据处理完毕，没有数据 或者 数据处理完毕后，发送 FIN + ACK 包，处于 LAST_ACK 状态
- 发送方收到 FIN + ACK 后，会回发一个 ACK 包，处于 TIME_WAIT 状态
- 接收方收到 ACK 后，正式关闭连接，处于 CLOSE 状态
- 发送方过了 TIME_WAIT 超时时间，进入 CLOSE 状态



主动关闭的有 TIME_WAIT 状态

被动关闭的有 CLOSE_WAIT 状态



> ### 抓包分析

*![image.png](https://pic.leetcode-cn.com/1601705109-tpmVPo-image.png)*

```
源ip				目的 ip		 协议 包长	  源端口->目的端口 标志位	序列号seq + 确认号ACK
118.178.116.8	10.21.71.101	TCP	60		80 → 52296 [FIN, ACK] Seq=357 Ack=1539 Win=32768 Len=0
10.21.71.101	118.178.116.8	TCP	54		52296 → 80 [ACK] Seq=1539 Ack=358 Win=130816 Len=0
10.21.71.101	118.178.116.8	TCP	54		52296 → 80 [FIN, ACK] Seq=1539 Ack=358 Win=130816 Len=0
118.178.116.8	10.21.71.101	TCP	60		80 → 52296 [ACK] Seq=358 Ack=1540 Win=32768 Len=0
```

同样是存在 序列号 seq 和 确认号 ACK



**以下是对 FIN + ACK 包的分析：**

*![image.png](https://pic.leetcode-cn.com/1601705467-DrMzYF-image.png)*

![1601705764639](C:\Users\蒜头王八\AppData\Roaming\Typora\typora-user-images\1601705764639.png)





> ### 为什么第二次握手 和 第三次握手不能合并？

客户端发送 FIN 给服务端，表示所有数据都传输完毕了，可以关闭连接了，但仍然能够接收消息

服务端接收到 FIN 后，会发送一个 ACK ，但可能还有数据没有处理完，因此需要等到数据处理完毕后，才发送 FIN 给客户端，告知客户端数据处理完毕，可以关闭连接

对比三次挥手，因为服务端中间可能存在数据没有处理，因此 ACK 和 FIN 需要分开发送，所以需要四次挥手

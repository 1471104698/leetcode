# 线程池



## 1、为什么使用线程池？

(关于线程 和 进程，看 进程 和 线程 的基础 中的 6 、总结)



传统的线程使用，都是需要的时候就创建一个线程，执行完任务后，将线程进行销毁

这里面有两个开销：创建线程的开销 和 销毁线程的开销，都是需要 CPU 执行的

当高并发的情况下，大多数的任务都是短时间内可以完成的，这样频繁的执行和销毁只会降低效率，说夸张点，假设一个线程的创建和销毁需要 1s，那么 高并发 情况下 1s 可能有 10W 个请求，那么创建 10W 个线程，到时候创建销毁需要 10W s，这就不得了了

这一方面没有控制线程的数量，10 W 个线程，内存哪里顶得住，一方面是频繁的创建和销毁，CPU 都浪费时间，降低效率



因此，需要线程池来解决

线程池 能够指定线程的数量，因此不会创建太多的线程，同时创建的线程不会用完即毁，而是能够复用

这样就基本解决了上面的两个问题





## 2、线程池的参数

- `corePoolSize`：核心线程数，创建了线程池后，内部是没有线程的，当然可以调用 `prestartAllCoreThreads() `或者 `prestartCoreThread() ` 来预创建线程，这样任务到达就可以直接执行了，如果没有这么做，那么只有在任务到达的时候，查看是否有空余线程，如果没有，那么创建一个线程来让这个任务执行，当已经创建的线程数等于 指定的 `corePoolSize` 时，那么就不会再创建线程了，而是将任务放入到任务队列中，等其他线程执行完毕再来这个任务队列中调用任务继续执行
- `maximumPoolSize`：线程池允许创建的最大线程数，上面说了，线程数到 `corePoolSize` 个数时，就会将任务放到任务队列，当然也不是一直放，任务队列有一个指定大小的，当任务队列满了之后，就会再次创建线程，而这次的最大边界就是这里指定的 `maximumPoolSize`，当线程池中线程数到达这个数量时，之后就不会再创建线程了，除非销毁掉一些旧的线程
- `keepAliveTime`：线程空闲时间，也可以叫空闲存活时间，当线程没事干呆在线程池的时候，超过这个时间就会销毁了，一般这个销毁的是超过 `corePoolSize` 个数的线程，`corePoolSize`个数内的线程是不会销毁的
- `unit`：时间单位，显然是跟上面那个存活时间共用的
- `workQueue`：任务队列，就是上面说的，没有线程可以调用时任务存放的队列，**都是阻塞队列**
  - `ArrayBlockingQueue`：基于数组结构的阻塞队列，空间大小有限，阻塞就是线程来拿任务，发现没有任务就是处于阻塞状态，进入空闲时间
  - `LinkedBlockingQueue`：基于链表结构的阻塞队列，空间大小有限。`newFixedThreadPool()` 就是使用该队列
  - `SynchronousQueue`：同步队列，没有存储空间，当向线程池提交一个任务的时候，如果线程池没有空闲线程，那么重新开一个线程来允许该任务。`newCachedThreadPool()` 就是使用该队列
  - `PriorityBlockingQueue`：基于元素优先级排序的阻塞队列，空间大小无限
- `threadFactory`：创建线程的工厂，可以通过线程工厂在创建线程时赋予线程更有意义的名字
- `handler`：拒绝策略，当线程池内的线程数达到 max 级别，并且任务队列内的元素已经满了，那么就对于后来的任务就会使用 指定的 拒绝策略，默认情况下是对于新来的任务抛出异常
  - 丢弃 ，抛异常
  - 丢弃，不抛异常
  - 由调用线程池的线程处理任务，比如 main() 线程，不抛异常
  - 丢弃队首任务，将该任务入队，不抛异常



## 3、线程池运行原理



我们需要先知道，线程池的几个主要方法：

- execute()：执行任务，无返回值
- submit()：执行任务，有返回值，会返回一个 Future 类，可以通过 future.get() 获取执行结果，不过会等待阻塞，可以控制等待的时间
- shutdown()：关闭线程池，不会去强制中断正在执行的线程，只是去销毁掉空闲线程，然后等待所有线程执行完毕，才会进入人 SHUTDOWN 状态
- shutdownNow()：顾名思义，立马关闭线程，不论线程是否执行完毕，都强制中断，立马进入 SHUTDOWN 状态



### 1、任务提交流程

workCount：工作线程，即已经创建的线程数

corePoolSize：核心线程数

maximumPoolSize：最大线程数

workQueue：任务队列



当提交一个任务给线程池的时候，线程池执行过程如下：

1、检查线程状态，判断是否是 RUNNING，如果不是，则直接拒绝

2、如果 workCount < corePoolSize，那么创建一个新的线程去执行任务

3、如果 workCount >= corePoolSize，那么放入到 workQueue

4、如果 workCount > corePoolSize 并且 workCount < maximumPoolSize，并且 

workQueue已满，那么创建新的线程去执行任务

5、如果  workCount == maximumPoolSize，并且任务队列已满，那么启动拒绝策略

![img](https://pic1.zhimg.com/80/v2-b06a332965a66469ac512d92ff70e2db_720w.jpg)





### 2、Worker类





```java
private final class Worker
    extends AbstractQueuedSynchronizer
    implements Runnable
{

    //执行线程
    final Thread thread;
    //创建 Worker 时传进来的第一个任务
    Runnable firstTask;

    Worker(Runnable firstTask) {
        this.firstTask = firstTask;
        this.thread = getThreadFactory().newThread(this);
    }

    public void run() {
        runWorker(this);
    }

    protected boolean tryAcquire(int unused) {
        //CAS，尝试获取锁
        if (compareAndSetState(0, 1)) {
            setExclusiveOwnerThread(Thread.currentThread());
            return true;
        }
        return false;
    }

    protected boolean tryRelease(int unused) {
        setExclusiveOwnerThread(null);
        setState(0);
        return true;
    }

    public void lock()        { acquire(1); }
    public boolean tryLock()  { return tryAcquire(1); }
    public void unlock()      { release(1); }
    public boolean isLocked() { return isHeldExclusively(); }
```

Worker 类是 线程池的一个内部类，内部有 thread 和 firstTask 两个变量，其中 firstTask 是在创建 Worker 时通过构造方法传入的，表示当前需要执行的任务，而 thread 是通过 ThreadFactory 直接创建的

里面还有一个 run() ，内部调用了 runWorker() 来执行任务



**Worker 类继承了 AQS，内部定义了 lock() 等方法，跟 ReentrantLock 类似，只是这个 lock() 不是用来防止竞争的，而是当调用 shutdown() 的时候，调用 worker 的 tryLock() 尝试获取锁，以此来判断线程是否处于空闲状态，如果是，那么进行回收**



### 3、execute() 和 addWorker()

```java
public void execute(Runnable command) {
    if (command == null)
        //获取当前线程数 c
        int c = ctl.get();
    //c 小于核心线程数，那么直接调用 addWorker 并且将任务交给它执行
    if (workerCountOf(c) < corePoolSize) {
        if (addWorker(command, true))
            return;
        c = ctl.get();
    }
    /*
    isRunning(c) 判断线程池是否还在执行， workQueue.offer(command) 将任务提交到任务队列中
    这里的意思是如果 线程数小于 corePoolSize，那么直接将任务交给新创建的核心线程执行
    如果大于 corePoolSize，那么将任务放到任务队列中
    如果放入成功，那么就在队列中等待
    如果放入失败，表示任务队列满了，尝试添加一个 Worker，如果超过了 max，那么添加失败，实施拒绝策略，如果添加成功，那么执行
    */
    if (isRunning(c) && workQueue.offer(command)) {
        int wc = ctl.get();
        if (!isRunning(wc) && remove(command))
            reject(command);
        else if (workerCountOf(wc) == 0)
            addWorker(null, false);
    }
    else if (!addWorker(command, false))
        reject(command);
}

private boolean addWorker(Runnable firstTask, boolean core) {
    for (;;) {
        int c = ctl.get();
        int rs = runStateOf(c);
        for (;;) {
            //获取线程数量，如果超过了 max ，那么不能创建新线程
            int wc = workerCountOf(c);
            if (wc >= CAPACITY ||
                wc >= (core ? corePoolSize : maximumPoolSize))
                return false;
        }
    }
    
    Worker w = null;
    try {
        //创建 Worker，并且调用 t.start() 执行任务
        w = new Worker(firstTask);
        final Thread t = w.thread;
        if (t != null) {
            t.start();
            workerStarted = true;
        }
    }
    return workerStarted;
}
```

当调用 execute() 提交任务的时候，会先判断线程数量 c 是否小于 corePoolSize

如果是，那么直接调用 addWorker() 创建新的 Worker 执行任务

如果不是，那么先将任务放入任务队列排队

如果放入成功，那么就这样不管

如果放入失败，表示队列已满，那么调用 addWorker() 创建新的线程

在第二次调用的  addWorker() 中，会判断线程数量是否已经超过 max，如果超过，那么不创建，直接返回。如果不超过，那么创建新的 Worker 并获取 Worker 中的 thread 调用 run() 执行任务，而 run() 中调用的是 runWorker()

即最终任务的执行是在 runWorker() 中的





### 4、任务执行 runWorker()

```java
final void runWorker(Worker w) {
    Thread wt = Thread.currentThread();
    Runnable task = w.firstTask;
    try {
        while (task != null || (task = getTask()) != null) {
            w.lock();
            try {
                task.run();
            } finally {
                task = null;
                w.unlock();
            }
        }
    } 
}
```

我们可以看出，它会使用一个 while() 循环不断从 getTask() 中获取任务执行

当 task != null，即获取到一个任务的时候，那么就会调用 lock() 加锁，前面也说了，lock() 不是为了防止别的线程进行竞争，而是为了告知线程池现在自己有任务要执行，不是处于空闲状态

当任务执行完毕后，会将 task 置 null，然后释放锁，然后再继续循环调用 getTask() 获取任务



### 5、任务获取 getTask()



```java
private Runnable getTask() {
        boolean timedOut = false; // Did the last poll() time out?
		
    	//循环判断
        for (;;) {
            int c = ctl.get();
            int rs = runStateOf(c);

            // 检查线程池状态，如果线程池是关闭状态 或者 任务队列为空，那么返回 null,表示无任务可做
            if (rs >= SHUTDOWN && (rs >= STOP || workQueue.isEmpty())) {
                decrementWorkerCount();
                return null;
            }
			//获取工作线程数
            int wc = workerCountOf(c);
			
            // 线程数量 wc 超过 corePoolSize 时为 true
            boolean timed = allowCoreThreadTimeOut || wc > corePoolSize;
			//当工作线程数超过 max，或者 (等待时间超时 并且 线程数量 wc 超过 corePoolSize)，那么返回 null
            if ((wc > maximumPoolSize || (timed && timedOut))
                && (wc > 1 || workQueue.isEmpty())) {
                if (compareAndDecrementWorkerCount(c))
                    return null;
                continue;
            }

            try {
                //workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) 是一个阻塞方法
                //表示等待一定时间，如果没有任务，就停止等待
                Runnable r = timed ?
                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :
                    workQueue.take();
                if (r != null)
                    return r;
                timedOut = true;
            } catch (InterruptedException retry) {
                timedOut = false;
            }
        }
    }
```



getTask() 的作用是空闲的线程用来获取任务执行的

而它其实还有一个重要作用：减少超过 corePoolSize 之外的线程数量，即控制线程数量



它的执行流程如下：

- 如果线程数量超过 max 或者 (线程数量超过 core 并且 timeout = true)，那么就不再循环获取任务，直接返回 null
- 如果前面没有返回 null，那么调用 任务队列的 poll() ，指定等待获取任务的时间，如果这段时间获取不到任务，那么设置 timeout = true，并且进入下一轮等待
- 当获取到任务时，直接将任务返回



我们可以看出

对于 core 数量内的线程来说，在 getTask() 中获取不到任务也会一直循环，这样就导致 core 线程不会处于空闲状态，从而不会被回收

而对于 core 外的线程来说，它会给这些线程一次获取任务的机会，如果在 poll() 等待过程中获取到了任务，那么就返回执行，如果等待超时也没有获取任务，表示这段时间用户没有提交任务了，线程资源不需要这么多了，那么就设置 timeout = true。在下一轮中返回 null，即不再获取任务，这样的话，对于 runWorker() 在 while() 中调用了 getTask()，发现返回了 null，那么 while() 也会停止循环，这样的话线程就处于空闲状态，等到达一定的空闲时间，这些线程就会被回收了，就是这样保证了线程池线程的数量



### 6、线程池 shutdown() 和 shutdownNow()



> ### shutdown()

shutdown() 是先回收空闲线程，然后等正在执行的其他线程执行完毕后才进行回收

关于空闲线程的判断，就是利用 线程在执行任务前调用的 lock()，线程池通过调用 tryLock() 尝试获取锁判断线程的执行状态

```java
private void interruptIdleWorkers(boolean onlyOne) {
        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock();
        try {
            for (Worker w : workers) {
                Thread t = w.thread;
                //调用 tryLock() 尝试获取锁，获取成功表示线程处于空闲状态
                if (!t.isInterrupted() && w.tryLock()) {
                    try {
                        t.interrupt();
                    } catch (SecurityException ignore) {
                    } finally {
                        w.unlock();
                    }
                }
                if (onlyOne)
                    break;
            }
        } finally {
            mainLock.unlock();
        }
    }
```





> ### shutdownNow()

该方法调用后会直接中断所有在执行的线程，然后进行回收
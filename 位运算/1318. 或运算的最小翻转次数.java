
给你三个正整数 a、b 和 c。

你可以对 a 和 b 的二进制表示进行位翻转操作，返回能够使按位或运算   a OR b == c  成立的最小翻转次数。

「位翻转操作」是指将一个数的二进制表示任何单个位上的 1 变成 0 或者 0 变成 1 。

 

示例 1：

翻转前 a 和 b 或运算结果
0010 -> a
0110 -> b
---------
0110 -> res

0101 -> c

翻转后
0001 -> a
0100 -> b
---------
0101 -> res

0101 -> c

输入：a = 2, b = 6, c = 5
输出：3
解释：翻转后 a = 1 , b = 4 , c = 5 使得 a OR b == c
示例 2：

输入：a = 4, b = 2, c = 7
输出：1
示例 3：

输入：a = 1, b = 2, c = 3
输出：0

class Solution {
    public int minFlips(int a, int b, int c) {
        /*  
            我们先求 a 和 b  | 运算结果 ores 和 ^ 异或运算结果 xres ，然后将 ores 与 c 不同的位置找出来
            如果不用的位置 ores 是 0，这意味着 a 和 b 该位置都是 0，而 c 该位置是 1
                那么我们只需要将 a 和 b 其中一个该位置翻转为 1 即可，那么我们翻转次数 + 1
            如果不同的位置 ores 是 1，这意味着 a 和 b 中至少有一个该位置是 1，而 c 该位置是 0
                那么我们判断异或结果 ores，
                该位置在 xres 中是 1 时，表示 a 和 b 其中一个为 1，那么我们只需将该位置为 1 的翻转为 0 即可，那么翻转次数 + 1，
                如果是 0，表示 a 和 b 两个该位置都为 1，那么我们需要将该位置都翻转为 0，那么翻转次数 + 2
        */
        int ores = a | b;
        int xres = a ^ b;

        int res = 0;

        for(int i = 0; i < 32; i++){
            int bit = (ores >>> i) & 1;
            if(bit != ((c >>> i) & 1)){
                if(bit == 0){
                    res++;
                }else{
                    if(((xres >>> i) & 1) == 1){
                        res++;
                    }else{
                        res += 2;
                    }
                }
            }
        }
        return res;
    }
}
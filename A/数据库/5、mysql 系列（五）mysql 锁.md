# Mysql 锁



## 1、mysql 如何锁数据？

**表锁：**给整个聚簇索引树上的节点加锁

**行锁：**给 聚簇索引/非聚簇索引 上的某个节点加锁



查询聚簇索引：

```java
update user set age = 10 where id = 49; 
```

解释：id 是聚簇索引，因此会在 id = 49 上加写锁



查询非聚簇索引：

```java
update user set age = 10 where name = 'Tom'; 
```

解释：name 是非聚簇索引，因此它会在叶子节点得到的是聚簇索引的值

假设它的聚簇索引 id = 49，再到聚簇索引树上查询，

因此会在非聚簇索引树将所有 name = 'Tom' 的节点 和 聚簇索引树的节点 id = 49 上都加锁



## 2、mysql 锁分类



### 1、行锁：共享锁 和 排他锁

InnoDB 中有两种类型的行锁

- **共享锁（S：share）**：同时也叫读锁，当某个事务对某行上读锁后，允许其他事务读取该数据行，即可以上读锁，但不能写，即不能上共享锁
- **排他锁（X）**：同时也叫写锁，但某个事务对某行上写锁后，不允许其他事务 读写 该数据行，即不能够上读锁或者写锁，可以说是重量级锁

| 锁类型       | 共享锁 S | 排他锁 X |
| ------------ | -------- | -------- |
| **共享锁 S** | [兼容]() | 冲突     |
| **排他锁 X** | 冲突     | 冲突     |

通过 select...for share 加读锁， select...for update、update、delete 加写锁



**select...for xxx 出现的意义是什么？为什么普通的读还要加锁**

```java
insert、update 这些操作会加写锁，这样别人就不能动这些数据了

但是可能 一个事务 执行过程中 不一定存在是 insert、update，它仅仅只需要进行 读而已，但是事务执行过程中又不想要别人修改 数据，即每次当前读 都要保证数据不被修改，因此就使用 select...for share 和 select...for update 加锁，效果跟 insert 和 update 一样的
```



### 2、表锁：意向共享锁 和 意向排他锁



> 为什么需要意向锁？

[意向锁的作用](https://www.zhihu.com/question/51513268/answer/127777478)

`start`

当获取表的写锁时，意味着可以对表的任意数据进行修改

那么当事务 A 获取某行数据的写锁时，事务 B 想要再来获取表的写锁，那么一般情况下它会怎么做呢？

- 判断是否存在表锁
- 遍历表中的每行数据，判断是否存在数据加了写锁或者读锁

很显然，第二种效率低得一批，当一个表存在 1000W 数据行，那么一次需要判断 1000W 次，显然不可能



因此，对应第一种方法 出现了 意向锁，意向锁是 mysql 自动添加的

- 意向共享锁（IS）：事务在获取某行的读锁前，需要先获取该表的意向共享锁
- 意向排他锁（IX）：事务在获取某行的写锁前，需要先获取该表的意向排他锁

`end`



执行 当前读 都会给对应的表加上意向锁

select...for share 的时候 mysql 会自动给表加上 意向共享锁

select...for update、insert、update 的时候 mysql 会自动给表加上 意向排他锁

| 锁类型        | 意向共享锁 IS | 意向排他锁 IX |
| ------------- | ------------- | ------------- |
| 意向共享锁 IS | [兼容]()      | 冲突          |
| 意向排他锁 IX | 冲突          | 冲突          |



## 3、排他锁 的 类型



### 1、记录锁

记录锁就是对索引数据行加锁，只锁住满足条件的数据行



**1、通过主键操作**

```java
select * from t where id = 1 for update;
+----+------+------+------+
| id | c1   | c2   | c3   |
+----+------+------+------+
|  1 |    1 |    1 |    1 |
+----+------+------+------+
```

 使用`SHOW ENGINE INNODB STATUS`命令查看 InnoDB 监控中关于锁的事务数据，可以看到以下内容： 

```java
    2 lock struct(s), heap size 1136, 1 row lock(s//两个锁， 1 个是行锁
MySQL thread id 103, OS thread handle 140437513750272, query id 23734 localhost root
TABLE LOCK table `hrdb`.`t` trx id 43764 lock mode IX	//表 t 加上了 IX 锁
RECORD LOCKS space id 101 page no 4 n bits 72 index PRIMARY of table `hrdb`.`t` trx id 43764 lock_mode X locks rec but not gap	//主键索引上加了 X 锁
```

总共加了 2 个锁，表 t 加上了 IX 锁，主键索引节点 上加上了一个 X 锁



**2、通过唯一索引操作**

```java
select * from t where c1 = 1 for update;
+----+------+------+------+
| id | c1   | c2   | c3   |
+----+------+------+------+
|  1 |    1 |    1 |    1 |
+----+------+------+------+
```

 使用`SHOW ENGINE INNODB STATUS`命令查看 InnoDB 监控中关于锁的事务数据，可以看到以下内容： 

```java
3 lock struct(s), heap size 1136, 2 row lock(s) //三个锁，2 个是行锁
MySQL thread id 103, OS thread handle 140437513750272, query id 23722 localhost root
TABLE LOCK table `hrdb`.`t` trx id 43761 lock mode IX	//表 t 加上了 IX 锁
RECORD LOCKS space id 101 page no 5 n bits 72 index idx_t_c1 of table `hrdb`.`t` trx id 43761 lock_mode X locks rec but not gap

RECORD LOCKS space id 101 page no 4 n bits 72 index PRIMARY of table `hrdb`.`t` trx id 43761 lock_mode X locks rec but not gap
```

总共加了 3 个锁，表 t 上加了 IX 锁，唯一索引 c1 上加了一个 X 锁，主键索引上加了一个 X 锁

即如果使用唯一索引查询出来的结果，该数据对应的主键索引也会进行加锁

即锁定 非聚簇索引 会同时锁定 聚簇索引



### 2、间隙锁

```sql
       Table: test
Create Table: CREATE TABLE `test` (
  `id` int(11) NOT NULL default '0',
  `v1` int(11) default NULL,
  `v2` int(11) default NULL,
  `v3` int(10) unsigned NOT NULL default '0',
  PRIMARY KEY  (`id`),
  UNIQUE KEY `v3` (`v3`),
  KEY `idx_v1` (`v1`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8


mysql> select * from test;
+----+------+------+----+
| id | v1   | v2   | v3 |
+----+------+------+----+
|  0 |    4 |   15 |  0 |
|  1 |    1 |    0 |  1 |
|  2 |    3 |    1 |  2 |
|  3 |    4 |    2 |  3 |
|  5 |    5 |    9 |  5 |
|  7 |    7 |    4 |  7 |
|  8 |    7 |    3 |  8 |
| 10 |    9 |    5 | 10 |
| 30 |    8 |   15 | 30 |
+----+------+------+----+
9 rows in set (0.00 sec)
```



两个事务执行的 sql 语句如下：

 ![img](https://pic4.zhimg.com/755752d226efac5c7ef1d599636ed4a2_b.png)



**上面阻塞的原理是什么？**

 这是在 RR 模式下的，因此当前读需要加 间隙锁

而 v1 是普通索引，所以可能会存在重复值

根据表中已经存在的记录，并且索引树是叶子节点存储 数据 data 和 聚簇索引值，那么在叶子除 v1 的值是有序且连续的

即 v1 索引树叶子节点的链表如下排列

v1	1	3	4	4	5	7	7	8	9

id	 1	2	0	3	5	7	8   30  10

v1 存在的间隙有  （-∞,1],(1,3],(3,4],(4,4],(4,5],(5,7],(7,7],(7,8],(8,9],(9,+∞) 

首先看 session1，它操作的是 v1 = 7 的数据行，它有两个数据行，因此对两个数据行都加间隙锁

间隙内的数值为  行(v1=5,id=5),行(v1=7,id=7),行(v1=7,id=8),行(v1=8,id=30) 

即锁上包括 v1 = 7 所有数据行左右两边的数据之间的间隔

这些间隙内的其他事务无法进行更新、插入、删除



再看 session2：

- 修改 (v1=9, id=10) 为 (v1=6, id=10)
  - 假设修改成功，那么 v1 索引树的叶子节点链表变成： (v1=5,id=5),**(v1=6,id=10)**,(v1=7,id=7),(v1=7,id=8),(v1=8,id=30) ，这个 (v1=6,id=10) 在锁定的间隙中，所以会阻塞
  - 假设执行的是 update test set v1 = 4 where v1 = 9，即 变成 (v1=4,id=10)，那么就不会阻塞，因为不在间隙中
- 修改 (v1=9,id=10) 为 (v1=8,id=10)
  - 假设修改成功，那么链表变成：(v1=5,id=5),(v1=7,id=7),(v1=7,id=8),**(v1=8,id=10)**,(v1=8,id=30) ，这个 (v1=8,id=10) 在间隙中，因此会阻塞
  - 假设将 v1 = 9 的 id 修改为 40，那么这样修改就不会在间隙中，就不会阻塞
- 修改 (v1=9,id=10) 为 (v1=5,id=10)
  - 假设修改成功，那么链表变成：(v1=5,id=5),**(v1=5,id=10)**,(v1=7,id=7),(v1=7,id=8),(v1=8,id=30) ，这个 (v1=5,id=10) 在间隙中，因此会阻塞
  - 假设将 v1 = 9 的 id 设置为 -1，那么就不会阻塞
- 修改 (v1=9,id=10) 为 (v1=9,id=10)
  - 会修改成功的原因是：(v1=5,id=5),(v1=7,id=7),(v1=7,id=8),(v1=8,id=30),**(v1=9,id=10)**，由于 (v1=9,id=10) 不在间隙锁中，所以会修改成功



### 3、Next-key 锁

**Next-key 锁 = 记录锁 + 间隙锁**

由于记录锁只会锁某行记录，而间隙锁只会锁间隙，不会锁记录，因此将它合并起来

**RR 就是使用 MVCC + Next-key 锁 完全解决幻读问题的**





## 4、RC 和 RR 级别 各种索引 如何锁数据？

### 1、RC级别



> ### 聚簇索引

```sql
delete from t1 where id = 10;
```

id 是主键， 那么就是先对表加 IX 锁，再直接对 id 所在的叶子节点进行加 X 锁（记录锁）

 ![img](https://pic4.zhimg.com/80/v2-a34f111a461bac17c7cfdc62ba0647e2_720w.jpg) 



**因为聚簇索引对应的值是唯一的，因此不会再插入 id = 10 的数据，即不会造成幻读**



> ### 唯一索引

```sql
delete from t1 where id = 10;
```

id 是唯一索引，同时也是非聚簇索引，因此需要在 id 对应的非聚簇索引树 上对 id = 10 的节点 加 X锁（记录锁），并且再查找聚簇索引，找到对应的聚簇索引所在节点，对聚簇索引值所在节点加 X 锁（记录锁）

对聚簇索引加 X 锁，是因为这个数据行已经被事务进行操作了，防止别的事物通过 聚簇索引直接获取数据行进行修改

 ![img](https://pic1.zhimg.com/80/v2-2d1518813e1b1e6ffde3bc070e2e9c82_720w.jpg) 



**同聚簇索引一样，因为唯一索引对应的值是唯一的，因此不会再插入 id = 10 的数据，即不会造成幻读**



> ### 普通索引

```sql
delete from t1 where id = 10; 
```

id 是普通索引，那么表示它的值会存在重复，那么就意味着操作的不只一条数据行

由于是等值查询，因此对于 id 所在的索引树来说，它也是连续的，它找到对应的节点位置，并且连续读取满足条件的节点，全部 加 X 锁（记录锁），然后根据这些节点上的 聚簇索引值找到在 聚簇索引树上的节点，加 X 锁（记录锁）

 ![img](https://pic3.zhimg.com/80/v2-3027331e18395ec65709dcb2dacf4422_720w.jpg) 



**由于 RC 级别下只加记录锁，所以其他事物只是不能操作这些加锁的数据行，但却可以新添加数据行，比如可以添加一些 id = 10 的数据行，因此会导致幻读**



> ### 无索引

```sql
delete from t1 where id = 10; 
```

没有索引，那么必定全表扫描，**全表扫描的话是走 聚簇索引的索引树**

如果执行的是当前读，它会先对所有叶子节点，即所有数据行都加 X 锁，然后再遍历，将不满足条件的数据行的 X 锁进行释放，这样就剩下其他满足条件的数据行加 X 锁了

 ![img](https://pic2.zhimg.com/80/v2-931c0e3cddaf0fa9956478db1ea4a12e_720w.jpg) 



正是因为不走索引会遍历 聚簇索引树的所有叶子节点，虽然是链表形式可以直接顺序方法，但是当数据量过大时，效率就很低

并且其他涉及到对不满足条件的数据行 加锁和释放锁的操作，更加降低了效率



### 2、RR 级别



> ### 聚簇索引

操作跟 RC 级别一样，只需要对 聚簇索引树 上满足条件的那个叶子节点加 X 锁（记录锁）即可，因为值是唯一的，不会导致幻读



> ### 唯一索引

操作跟 RC 级别一样，只需要对 非聚簇索引树 和 聚簇索引树 上满足条件的那个叶子节点加 X 锁（记录锁）即可，因为值是唯一的，不会导致幻读



> ### 普通索引

```sql
delete from t1 where id = 10; 
```

id 是普通索引，因此会出现重复值，即会存在多条数据

首先跟 RC 级别一样，找到 非聚簇索引树上所有满足条件的节点加 X 锁，并且找到对应在 聚簇索引树上的节点加 X 锁

**但是由于 RR 级别需要解决幻读，而 如果仅仅只是对目前满足的数据行加 X 锁，那么这样就无法阻止后续的事务添加 id = 10 的新数据行，这样就又会导致幻读，因此，它会在 id 这个非聚簇索引树上的满足条件的数据行都加上上面提到的间隙锁，这样就能避免幻读**

**无需在 聚簇索引上添加间隙锁，因为当插入一条 id = 10 的新数据时，必定会需要插入到 id 这个非聚簇索引树，而这时被加了间隙锁，因此会插入失败**

 ![img](https://picb.zhimg.com/80/v2-85ef76008ef0f94964c3857a4b49e78b_720w.jpg) 



> ### 无索引

跟 RC 一样走聚簇索引的全表扫描，如果进行的是当前读，那么会锁上所有的叶子节点，并且给所有的数据行加上间隔锁，以此来避免幻读，后面再将不满足条件的叶子节点上的锁去掉

 ![img](https://pic1.zhimg.com/80/v2-71ce022c81c16ddf8ad3503d85dc61e2_720w.jpg) 
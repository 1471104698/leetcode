## **[817. 链表组件](https://leetcode-cn.com/problems/linked-list-components/)**

```java
给定链表头结点 head，该链表上的每个结点都有一个 唯一的整型值 。

同时给定列表 G，该列表是上述链表中整型值的一个子集。

返回列表 G 中组件的个数，这里对组件的定义为：链表中一段最长连续结点的值（该值必须在列表 G 中）构成的集合。
```



## **示例 1：**

```java
输入: 
head: 0->1->2->3
G = [0, 1, 3]
输出: 2
解释: 
链表中,0 和 1 是相连接的，且 G 中不包含 2，所以 [0, 1] 是 G 的一个组件，同理 [3] 也是一个组件，故返回 2。
```



## **示例 2：**

```java
输入: 
head: 0->1->2->3->4
G = [0, 3, 1, 4]
输出: 2
解释: 
链表中，0 和 1 是相连接的，3 和 4 是相连接的，所以 [0, 1] 和 [3, 4] 是两个组件，故返回 2。
```





## **实现思路**

```java
题目意思是，如果在链表连续的某一段在 G 中存在，那么这一段算作是一个组件

//例子
①、
head = [0,3,2,4,1]
G = [3,0,2]
这里 G 中的元素在 链表中是连续的，即 0->3->2，因此它们算是一个组件

②、
head = [0,3,2,4,1]
G = [3,0,2,1]
这里 3 0 2 是一个组件，而 另外的 1 由于跟它们不连续，因此算作另外一个组件，因此组件数为 2
    
//分析
我们可以计算有多少个组件头部，
比如 上面的 3 0 2 的头部是 0，因为它在这个组件中最先出现在链表当中，那么组件数 + 1
    而对于后面的 3 存在前驱节点 0 以及 后面的 2 存在前驱节点 3，因此它们不是组件头，直接跳过
    
    
//有点像求 甲板上的战舰数 那道题
```



## **实现代码**

```java
class Solution {
    public int numComponents(ListNode head, int[] G) {
        
        Set<Integer> set = new HashSet<>();
        for(int num : G){
            set.add(num);
        }
        int c = 0;

        ListNode cur = head;
        int preVal = -1;
        while(cur != null){
            if(set.contains(cur.val) && !set.contains(preVal)){
                c++;
            }
            preVal = cur.val;
            cur = cur.next;
        }
        return c;
    }
}
```


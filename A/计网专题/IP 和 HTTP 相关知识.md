# IP 和 基础知识



# 1、前置了解知识

---



## 1、网络层（IP） 和 数据链路层（MAC） 的关系

**MAC 的作用则是实现「直连」的两个设备之间通信，而 IP 则负责在「没有直连」的两个网络之间进行通信传输。**



>  举个例子

IP 我们可以当作是一个人的姓名，而 MAC 可以当作是一个人的居住地址

当送快递的时候，如果仅仅知道 IP，而不知道 MAC，那么就无法将快递送出去

快递公司会将快递从某个转接站送到某个转接站，一站过一站，直到到达目的 IP

而 这些转接的站点就是 MAC 地址



快递传送途中虽然不断变化了站点位置，但是起始地址和目的地址始终都没变。

其实，在网络中数据包传输中也是如此，**源IP地址和目标IP地址在传输过程中是不会变化的，只有源 MAC 地址和目标 MAC 一直在变化。**



## 2、IP地址划分

首先，最基础的当然就是 IP 地址是怎么划分的啦

首先我们需要知道 IP 地址的数量

以 IPv4 为例，每个 IP 由 32 位二进制组成，这里没有负数的概念，因此总的有 42 亿 IP 地址

*![image.png](https://pic.leetcode-cn.com/1598011080-gucfqx-image.png)*



常用划分为 A、B、C 类

各类的网络号和主机号位数不同，因为都是 32 位，因此网络号位数多的主机号位数就少

划分出网络号的目的是为了方便数据传输，路由器可以根据 IP 目的地址的网络号 确定是哪个网络段的来进行传输

*![image.png](https://pic.leetcode-cn.com/1598011098-zyTTOy-image.png)*

*![image.png](https://pic.leetcode-cn.com/1598010654-jidKYZ-image.png)*



一般我们自己电脑下的就是 C 类地址，以 192.x.x.x 的

*![image.png](https://pic.leetcode-cn.com/1598011333-DtpXyL-image.png)*









## 3、划分子网 - 子网掩码

**就比如我们上面说的，为什么要划分出网络号和主机号，网络号的作用是什么？**

两台计算机要通信，首先要判断是否在同一个网络段，如果是，那么直接发送数据包到目的主机，如果不是，那么通过 路由器寻址，通过网络号来寻找对应的网络段位置

![1598011512649](C:\Users\蒜头王八\AppData\Roaming\Typora\typora-user-images\1598011512649.png)



> ### 子网掩码

掩码的意思就是掩盖掉主机号，剩余的就是网络号，即将主机号和网络号进行分离

由于我们要掩盖掉主机号来留下网络号，因此，对于 C 类地址，号码 8 位都是主机号

因此，子网掩码为 255.255.255.0，这样按位与操作后，主机号就都变成 0 了，而 网络号不变

*![image.png](https://pic.leetcode-cn.com/1598011628-yKmTMc-image.png)*



同样的，如果是 B 类地址，那么后 16 位为主机号，那么子网掩码为 255.255.0.0









## 4、DNS



> ### 域名

使用域名的主要原因就是方便用户记忆，不然你每次都输入一串 IP 地址去访问，这样多麻烦

输入 访问 url 后，需要先通过 DNS 域名解析，获取到 目的 IP 地址，才能进行 TCP/UDP 通信

 

**根 DNS 服务器最高级，每台 DNS 服务器中都有记录 根域 DNS 服务器**

**根域 DNS 服务器 记录了所有 的 DNS 服务器，这样其他 DNS 服务器可以通过访问 根域 DNS 服务器 来获取其他 DNS 服务器的位置**



> ### 域名解析的工作流程

当我们输入 url 后，浏览器会看自己缓存中是否存在 域名对应的 IP 地址，如果没有，那么找操作系统缓存要，如果没有，那么找本地 host 文件要，如果还没有，那么就会通过 DNS 服务器查询，具体过程如下：

- 客户端首先会发送一个 DNS 请求给本地 DNS 服务器（点开网络配置可以看到，一般我们是不会配置的，是默认的 DNS 服务器，具体可以看 IP 地址划分那张图，或者自己点开网络配置看），问 www.server.com  的 IP 地址是什么
- 本地 DNS 服务器获取到请求后，如果自己有记录，那么将 IP 地址返回，如果没有，那么找到自己记录的     根 DNS 服务器，询问对应的 IP 地址，“老大， 能告诉我 www.server.com 的 IP 地址吗？”  
- 需要注意的是，根DNS 服务器 并不参与域名解析，但是我们上面说了，根DNS 服务器 存储了所有 DNS 服务器，因此它可以查询出管理 com 的 DNS 服务器，将地址发给 本地 DNS 服务器，（不参与解析，但会指明一条道路）
- 本地 DNS 服务器获取到管理 com 的顶级域名服务器的地址后，发起请问问它：“老二， 你能告诉我 www.server.com  的 IP 地址吗？”
- 顶级域名服务器会告诉 本地 DNS 服务器 管理 server.com 的权威域名服务器地址
- 本地 DNS 获取 权威域名服务器地址，发起请求问：“老三，www.server.com对应的IP是啥呀？”
- 权威 DNS 服务器查询后将对应的 IP 地址 X.X.X.X 告诉本地 DNS。
- 本地 DNS 再将 IP 地址返回客户端，客户端和目标建立连接。

#### ![1598012683746](C:\Users\蒜头王八\AppData\Roaming\Typora\typora-user-images\1598012683746.png)



> ### 迭代和递归两种方式

上面的方式就是默认的递归解析的方式，**DNS 解析是递归还是迭代主要看的是 客户端与什么进行**

如果跟上面一样 都是本地 DNS 跟其他的域名服务器进行交流的，那么就是递归，我们分解来看，本地 DNS 和 其他域名服务器之间是迭代的格式，但是对于客户端来说，它是直接最终获取到结果的，并没有参与中间的过程，对它来说就是递归的

**![img](https://upload-images.jianshu.io/upload_images/1446087-729b159e25523fe9.png?imageMogr2/auto-orient/strip|imageView2/2/w/799/format/webp)**



如果客户端请求一个域名，本地DNS 没有找到缓存，给客户端 根域名服务器的地址，让它自己发请求询问，当发起请求后，根域名服务器给它 顶级域名服务器的地址，让它自己去发请求询问，。。。，这样下去，都是客户端自己与各个域名服务器进行交流，这样的方式称作 DNS 迭代

![img](https://upload-images.jianshu.io/upload_images/1446087-c15f2ecb770d0ff0.png?imageMogr2/auto-orient/strip|imageView2/2/w/802/format/webp)



> ###  DNS 哪个地方使用了 UDP，哪个地方使用到了 TCP 协议

人们默认 DNS 使用的是 UDP 协议，其实不然，DNS 同时使用了 UDP 和 TCP 协议，占用了 UDP 和 TCP 的 端口53

TCP 主要就是保证可靠传输 和 数据的有序性，而 UDP 是不可靠传输并且不能保证数据的有序性

既然 UDP 是不可靠的，为什么还要使用 UDP 呢？

因为 UDP 的速度是 TCP 望尘莫及，TCP 加入了各种安全保障功能，使得占用了大量的开销，速度严重下降



**DNS 中有两种行为：一种是域名解析，一种是区域传送**



```java
域名解析使用 TCP 连接：
DNS 域名解析时间 = TCP 连接时间（三次握手、四次挥手） + DNS 交易时间

域名解析使用 UDP 连接：
DNS 域名解析时间 = DNS 交易时间
```

就从上面看，可以发现好像只不过是多了 TCP 连接时间么，但其实，在用户访问冷门网站的时候，由于 DNS服务器 没有冷门网站的缓存，需要到根服务器、顶级域名服务器、权威域名服务器迭代查询，知道查询到冷门网站所在的权威服务器，这种间会需要很多次的 TCP 连接，多几次查询，就多几次 TCP 连接时间，时间开销大

**因此，域名解析使用 UDP 协议**





DNS 规定了两种 DNS 服务器，一种叫主 DNS 服务器，一种叫辅助 DNS 服务器，主 DNS 服务器从自己的本地文件中读取 该区的 DNS 数据，辅助 DNS 服务器从 主 DNS 服务器上同步该区的 DNS 服务器；当一个 辅助 DNS 服务器启动时，它会与 主 DNS 服务器进行通信，并且同步数据，**这个叫做区域传送**

这个 主 DNS 服务器 和 辅助 DNS 服务器就类似 redis 的主从复制，辅助 DNS 服务器是为了在 主 DNS 服务器崩溃时顶上去的，以及平时帮主 DNS 服务器减轻读的压力

因为需要同步数据，要保证 主 DNS 服务器和 辅助 DNS 服务器 的数据一样，所以必须使用可靠的 TCP 协议，同时，基于 UDP 协议 的 DNS 报文最大为 512 字节，如果同步的数据超过 512 字节的话就有点问题了，

**因此，区域传送使用 TCP 协议**





# 2、面试问题

---



## 1、get 和 post 的区别

首先应该先搞清楚 get 和 post 是什么

get 是 **从服务器获取资源**，而 post 是 **向指定的 url 提交数据**

get 的资源可以是文本、图片、视频等，比如我们打开一篇文章，就是发送 get 请求给服务器，然后返回文章的内容

post 则是我们在一篇文章下面评论，就是通过 post 请求将评论内容作为数据，通过 TCP 协议传输给服务器



> GET 和 POST 方法都是安全和幂等的吗？

先说下安全和幂等的概念

- 安全是指方法请求不会 破坏 和 改变 服务器上的资源
- 幂等是指无论请求多少次，结果都是相同的（无论是查询还是别的）

通过上面这个概念，就可以看出来了，get 是安全和幂等的，因为 get 仅仅是查询

而 post 不是，因为 会新增 和 更新资源，会改变服务器上的资源，所以是不安全的，而多次提交会创建多个相同资源，因为 post 可能是更新或者删除或者插入





## 2、一次HTTP的完整请求过程（输入一个 url 的过程，后面还需要进行补充，详细讲解）

- 通过 DNS 解析域名，获取 IP 地址
- 客户端获取 IP 地址，向目的 IP 地址的服务端发起 TCP 连接（三次握手）
- 建立连接后，客户端向服务端发起 HTTP 请求（比如 get 请求获取静态资源）
- 服务端接收这个请求，在后台进行处理，比如请求某个页面，那么将 HTML 页面代码返回给浏览器
- 浏览器获取到完整的 HTML 页面代码，进行渲染，里面的图片等静态资源也通过一个个 HTTP 请求 进行加载（可以看出 HTML 代码 和 图片之类的是分开获取的，需要多次 HTTP 请求）
- 浏览器渲染完成，将页面展示给用户，如果没有后续请求，浏览器会向服务器发起断开连接（四次挥手）



## 3、HTTP 常见的状态码 

## ![img](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfXG1113Sjm0iaOXfoOv0tlUfV6qkzg4yHtOibAfTv6hTicOx73F55WWl4nW2FWlXnDJ7Igd9kvrrRnA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1) 



**1xx**

提示信息，中间状态，比如我转账给你，钱转过去需要一段处理时间，这段时间可以理解为 1xx



**2xx**

成功状态码，我们最愿意看到的

 「**200 OK**」是最常见的成功状态码，表示一切正常 ，可能服务器返回的 body 中会有数据

 「**204 No Content**」 也是是最常见的成功状态码，服务器不会返回数据

 「**206 Partial Content**」是 **应用于 HTTP 分块下载 或 断电续传**，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。 



**3xx**

表示用户请求的资源位置发生了改变，告知用户需要向新的 URL 发送请求（即旧的 URL 不再提供服务）

 「**301 Moved Permanently**」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。 

 「**302 Moved Permanently**」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。

上面这两个服务器会将新的 URL 一同返回，客户端自动进行访问

 「**304 Not Modified**」表示资源未修改，发送 get 方法请求资源的时候，服务器告知资源未修改，直接用原来的缓存就行了



2xx 和 3xx 都跟错误搭不上边，错误是指 客户端 或 服务端 某方面的错误



**4xx**

客户端方面的错误，服务端不能处理

 「**400 Bad Request**」表示客户端请求的报文有错误，笼统的错误，即并不知道什么错误

 「**403 Forbidden**」表示服务器禁止访问资源，即客户端访问了不能访问的资源

 「**404 Not Found**」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。 



**5xx**

客户端方面没有错误，而是服务端内部出现 了错误

 「**500 Internal Server Error**」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。 

 「**501 Not Implemented**」表示客户端请求的功能还不支持，服务端无法处理，类似“即将开业，敬请期待”的意思。

 「**502 Bad Gateway**」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。 

 「**503 Service Unavailable**」表示服务器当前很忙，暂时无法响应服务器，高并发下可能就有这样的返回码，类似“网络服务正忙，请稍后重试”的意思。 



**上面列举的是常见的状态码，一些不常见的就没列举了，比如 303，401，402 之类的**





## 4、HTTP 各个版本的区别 以及 演变的逻辑



### 1、HTTP 0.9

最原始的 HTTP 版本

- 只 支持 GET 请求：由于不支持其他请求，而 GET 是在 URL 中携带请求信息的，因此客户端无法向服务端发送太多信息
- 没有请求头/响应头 概念：不能指定版本号，同时只有一个版本，也无需指定，服务端只有返回 HTML 字符串的能力
- 短连接，即响应请求后，无需再进行通信，断开连接



HTTP 0.9 的局限性很大，能做的事很少



### 2、HTTP 1.0

- 新增了 POST、DELETE、PUT 等方式
- 增加了 请求头/响应头的概念，在请求/响应头 中指定 HTTP 版本号，以及状态码、权限、编码等
- 扩充了传输内容，可以传输图片、音频、二进制数据等



传输内容的扩容：**Content-Type**

Content-Type 是 请求头 和 响应头 中的一个字段，它指定传输资源的格式，可以通过解析这个字段来判断是什么类型的资源

比如客户端上传文件，需要在 Content-Type 指定二进制流的形式



特性：

- 无状态：服务端不会保存客户端的信息，这样就不会占用服务器内存
  - 可以通过 cookie/session 机制来做身份认证和状态记录
- 无连接：使用短连接，用完即断，表示连接的时间短，浏览器每次请求都需要建立 TCP 连接



HTTP 1.0 的缺点：

- 使用的是短连接，一次  HTTP 请求后都会断开连接（可以通过服务器配置支持多次），每次都需要进行 三次握手、慢启动、四次挥手，频繁通信情况下效率低，   其中 慢启动 主要对文件类大的传输影响大
- 存在 HTTP 队头阻塞





> ### 队头阻塞

- TCP 队头阻塞：即使使用滑动窗口，当一个数据包丢失，它将会导致后续的数据包无法发送，该数据包会重传直到接受方接收到发送 ACK 并且发送方接收到 ACK 为止
- HTTP 队头阻塞：请求 和 请求之间是有顺序的，下一个请求必须在上一个请求得到服务端响应后才能发出去，如果上一个请求阻塞了，那么后面的请求都会阻塞





### 3、HTTP 1.1



- 新增长连接：新增了一个 Connection 字段，里面有个 keep-alive 字段，可以设置保持连接不断开，以此成为长连接，因此一个  TCP 连接可以处理多个请求；HTTP1.1 是默认长连接的
- 管道化：对 HTTP 1.0 的修改，**管道化使得每个请求可以无需等待上一个请求响应即可发出去，不过响应还是按照请求的顺序返回**
- 缓存处理：新增字段：cache-control，对于 get 请求，浏览器会先看看自己是否有缓存，如果有，那么直接用，如果没有再请求，然后进行缓存，通过 cache-control 字段来控制缓存
- 断点传输：资源过大，可以分割传输，并且遇到网络故障的情况下，下次传输也可以从上次传输的地方接着传输



> ### 管道化

基于长连接的基础，我们先看没有管道化请求响应：

TCP 没有断开，用的同一个通道

```
请求1 > 响应1 --> 请求2 > 响应2 --> 请求3 > 响应3
```

管道化的请求响应：

```
请求1 --> 请求2 --> 请求3 > 响应1 --> 响应2 --> 响应3
```



管道化虽然解决了请求阻塞的问题，但是响应返回的顺序还是按照请求的顺序返回

这样的话，即使 响应2 比 响应1 事先准备好，但是还是要等 响应1 整完返回，响应2 才能返回

这是为了防止服务器返回 响应的时候，如果不按照顺序的话，那么服务器不知道相应对应哪个请求

本质上还是没有解决 HTTP 队头阻塞的问题





### 4、HTTP 2.0



HTTP 2.0 进行了全面改造，从数据传输的基本单位 到 使用的 协议 全部发生了改变

在 HTTP 2.0 中，有两个重要的新概念：帧 和 流

HTTP2.0 抛弃了 HTTP/1 使用的文本格式，使用的是二进制数据帧传输



> ### HTTP2.0 新加入的几个概念

连接(Connection)：一个 TCP 连接包含多个 Stream

流（Stream）：一个双向通讯流，代表一个完整的 请求-响应 过程

消息（message）：将每个 HTTP 请求 / 响应 看作一个消息，包含一个或者多个 frame

帧（frame）：数据传输的最小单位

- length：帧的最大长度
- type：帧的类型，比如设置流的优先级之类的
- stream identifier：流的id，即用来标识这个帧是属于哪个流的，**HTTP 1.1 中的队头阻塞就是因为响应和请求没有标识符，不知道怎么对应，所以响应才需要按照顺序返回，而这里给定了标识符了，所以就可以打破这个 HTTP 队头阻塞了**



> ### 上面各个概念的简单描述

首先我们需要搞清楚它们之间的关系

首先 连接(Connection) 就是一个 TCP 连接

那么 流（Stream）是什么？

流 它不是一个具体的事物，它代表着一次完整的 HTTP 请求/响应 过程

当客户端发起请求的时候，就是概念上建立起一个流（Stream），然后 请求/响应 的 帧（frame）进行传输，我们称 帧（frame）是在流上传输的

消息（message）就是每个 请求/响应，将它划分为多个部分，每个部分叫做 帧（frame）

即流上传输的就是 消息的部分，即 帧（frame）

消息（message）分块后是需要按照顺序进行传输的，这样接收方接收到后可以按照接收的顺序进行拼接，保证了有序性



一个 连接(Connection) 可以存在多个流，即用户可以同时发起多个请求，这样的话每个请求对应一个流



> ### 到底什么是流，以及什么是多路复用

**我们还需要再讲明，流，它不是一个具体的事物，既然不是一个具体的事物，那么怎么在 连接(Connection)  表示出 流（Stream）这个东西呢？**



帧（frame）上面有一个 stream identifier 字段，表示它是属于哪个流的

这样的话，其实就是像下面这样，所有的流的帧都在一条道上传输，不过是按照帧上的流的 id，来记录这个帧是属于哪个流的

不同流（Stream）的帧（frame）可以交错传输，而同一个流上的帧需要保证传输的顺序，这样才能够根据接收的顺序进行拼接，保证了有序性



下面的图不管发送还是接收都一条道，不过为了方便指明方向所以画成两条道

![img](https://upload-images.jianshu.io/upload_images/16844918-b13e6490eedb402c.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

*![image.png](https://pic.leetcode-cn.com/1599402910-XBmxXM-image.png)*



由于上面这波操作，将本来只有一条道的，给抽象成了多条流，即每条流的帧都是在各自的道上进行传输

然而，实际上它们还是在一条道上，不过是根据流的不同来区分出不同的道

![img](https://user-gold-cdn.xitu.io/2019/10/12/16dbed8846d82eee?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

而由于它们存在流的 id 标识符，因此可以发送多个请求，以及无需按照请求的顺序进行响应，因为它们有 流 id 进行标记，可以根据这个 流 id 识别出响应是属于哪个请求的，以此来解决了 HTTP 队头阻塞的问题

同时，上面这个讲解过程就是在讲解多路复用了



## 5、HTTPS

> ### HTTPS 产生的原因

由于 HTTP 是明文传输的，因此通信内容都是明文可见的，别人可以获取数据报看见这些内容，也可以篡改这些内容

因此，HTTP 显得就不够安全了



而 HTTPS 就是在 HTTP 的基础上加一层 TSL（传输层安全协议） 或者 SSL （安全套接层），用来保护通信内容

**实际上就是使用加密算法**（当然，还有什么身份认证什么的，太麻烦了，不说了）

![img](https://pic1.zhimg.com/80/v2-5f4b161e47f7c1a1cd8c2b8081914753_720w.jpg)





### 加密算法



> ### 对称加密

**对称加密：**对明文进行加密，将看得懂的内容，变成一段看不懂的内容，而解密，实际上就是一种逆运算，并且加密解密使用的是同一把密钥

比如，对两个二进制数 A 和 B 进行异或，得到结果 C，这算作加密过程，而再将 C 与 B 进行异或，得到结果 A，这算作解密过程，在这个对称加密的算法中，A 是明文内容，C 是加密后的内容，而 B 则是密钥

加密和解密使用的是同一把密钥，并且加密后需要将密钥发送给对方，让对方进行解密

![img](https://pic1.zhimg.com/80/v2-93dcf73fbc36b8a0032172260f96c688_720w.jpg)



这样一来就有个问题了，这要是在传输过程中被拦截了，密钥不就被获取了么？

因此，就需要 非对称加密了



> ### 非对称加密

**非对称解密：**加密和解密使用的不是同一把密钥，并且分为公钥和私钥



![img](https://picb.zhimg.com/80/v2-8c648c8545d46d2f12dc6c0cd4ed3d4b_720w.jpg)

这就是非对称加密，Bob 的保险箱空着的时候，任何人都可以去获取，这个保险箱相当于公钥

然后别人将 通信内容明文 放入到保险箱，并关上，这就是使用 公钥对内容进行加密

而保险箱只有 Bob 有钥匙可以打开，这就是公钥加密的内容只有 Bob 自己手中的私钥才能解密





## 6、OSI 七层模型 和 TCP/IP 网络的五层模型 以及 对应的协议

> ### OSI 七层模型 和 网络的 五层模型

![img](https://pic4.zhimg.com/80/v2-71ec8729cfbe02a524ba808dac267528_720w.jpg)

可以看出 OSI 七层模型是在 TCP/IP 五层模型基础上添加了两层，分别是 表示层 和 会话层

位于 应用层 和 传输层之间



> ### 每层使用的协议

应用层即我们运行的服务，进程： HTTP 、DNS、FTP 等

传输层： TCP/UDP 协议

网络层 ：IP、ICMP（ping 使用的协议）、ARP、RARP

链路层：以太网协议



> OSI 的七层模型
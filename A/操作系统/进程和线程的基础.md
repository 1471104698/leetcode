# 进程和线程的基础



> ### 先来看看一则小故事

我们写好的一行行代码，为了让其工作起来，我们还得把它送进城（**进程**）里，那既然进了城里，那肯定不能胡作非为了。

城里人有城里人的规矩，城中有个专门管辖你们的城管（**操作系统**），人家让你休息就休息，让你工作就工作，毕竟摊位（**CPU**）就一个，每个人都要占这个摊位来工作，城里要工作的人多着去了。

所以城管为了公平起见，它使用一种策略（**调度**）方式，给每个人一个固定的工作时间（**时间片**），时间到了就会通知你去休息而换另外一个人上场工作。

另外，在休息时候你也不能偷懒，要记住工作到哪了，不然下次到你工作了，你忘记工作到哪了，那还怎么继续？

有的人，可能还进入了县城（**线程**）工作，这里相对轻松一些，在休息的时候，要记住的东西相对较少，而且还能共享城里的资源。



## 1、进程

最开始进程的概念是：我们首先写的代码，它是一个磁盘中的静态文件，通过编译变成二进制文件，当我们执行这个文件的时候，它会加载到内存中，变成含有一条条的指令的程序，而执行这个程序的时候，就是在执行这些指令，这个执行的程序就被称作进程



> ### 什么是并发？

当执行某个进程的时候，它需要读取磁盘文件，这个过程对人来说可能很快，但是换成计算机视角，是非常缓慢的，CPU 不可能等到这个进程读取完数据再继续执行它，这样效率低得一批（这里需要注意的是，进程读取磁盘文件是进程自己的事，无需 CPU 参与）

做个类比，你去煮开水时，你会傻傻的等水壶烧开吗？很明显，小孩也不会傻等。我们可以在水壶烧开之前去做其他事情。当水壶烧开了，我们自然就会听到“嘀嘀嘀”的声音，于是再把烧开的水倒入到水杯里就好了。

同样的，人类设置的 CPU 也不会这么傻，当进程 A 读取磁盘文件的时候，CPU 就不管这个进程 A，去执行另外一个进程 B，当进程 A 读取完毕后，CPU 收到中断指令，停止执行进程 B 再去执行进程 A

![img](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcvw4t9kicec370n3cvX2JS9ROKhytS0ATz3KUictSI0rDntHcibw6wdfrJyDgvVgxdicEic6jkRW0692A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1) 

进程交替运行，由于进程切换的速度对于人类来说非常的快，因此给人一种几种程序同时进行的感觉，其实不然，这就是并发，而并行才是人类感觉的哪一种

![img](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcvw4t9kicec370n3cvX2JS9kkSqrpkMYqI035yU7Ricpv368zOBOCicrk5EOMf7T5j9UicUvficEQdCxg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



> ### 进程和程序的关系

按我的理解，静静的躺在电脑桌面上的软件就是程序，我们没有运行它，它只是磁盘的静态文件而已，当我们运行它了，加载到内存当中供 CPU 调度了，就变成了进程，即运行中的程序



## 2、进程的状态

**进程至少存在 3 个状态：【运行、就绪、阻塞】**

状态变化如下：

运行状态 -> 就绪状态、阻塞状态

就绪状态 -> 运行状态

阻塞状态 -> 就绪状态

即阻塞状态不可能一下就变成运行状态，因为运行状态需要 CPU 的调度，当阻塞时间完成后，不可能保证 CPU 立马调度它，因此会先进入就绪状态等待调度

![img](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcvw4t9kicec370n3cvX2JS9EfRviciaGMLREQ1nqvjWkibKlREGPI9JyfhA5XlmzFRRiaIATAEiaLbCx4w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

**阻塞事件**：比如 java 中的 scanner，即等待输入，等待的过程中，即使给进程 CPU 的控制权也没什么意义，因为它被 I/O 事件阻塞了，无法继续执行



## 3、进程的结构（PCB）

操作系统中， 进程控制块 - PCB 就是用来标识进程的

**PCB 是进程的唯一标识符**，即创建进程的时候就创建对应的 PCB，销毁进程的时候就销毁对应的 PCB



>  ### PCB 包含什么？为什么对进程来说如此重要？

PCB 包含了：

进程当前的状态：如 运行态、阻塞态、就绪态等

进程的优先级：进程抢占 CPU 的优先级

内存地址 或 虚拟内存的空间信息

当前运行的状态信息：比如进程切换时，那么需要保存当前运行的状态信息，即下次运行进程时需要从什么地方开始，方便下次 CPU 调度时 CPU 直接获取 PCB 来继续执行进程

> ### 每个 PCB 是如何组织的呢？

PCB 包含了进程的 状态，那么我们获取运行、就绪、阻塞状态的进程就是根据 PCB 来的，那么各个进程的 PCB 是如何串联起来的呢？

一般是通过 **链表** 的方式

由于 PCB 也是一种数据结构，这里我们就可以把 PCB 看作是链表的 Node 节点，有以下定义：

```java
class PCB{
    //进程号
    int pid;
    //优先级
    //...
    
    //下一个进程 PCB
    PCB next;
}
```

由于是链表的形式，通过 next 指针来获取下一个进程 PCB

把具有相同状态的 PCB 串成一条链表，**组成各种队列**。

- 将所有处于就绪状态的进程链在一起，称为**就绪队列**；
- 把所有因等待某事件而处于等待状态的进程链在一起就组成各种**阻塞队列**；
- 另外，对于运行队列在单核 CPU 系统中则只有一个运行指针了，因为单核 CPU 在某个时间，只能运行一个程序。

![img](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcvw4t9kicec370n3cvX2JS9q2vgjxfNQq38MNmricWU9jicJtxKDqu8MiaFtvia2qJ7LVxjlsMCcRDShQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



## 4、进程的上下文切换（就是进程切换）

CPU 从一个进程切换到另一个进程，就叫做 线程的上下文切换



> ### 进程的上下文切换是切换什么？

当 进程 A 的 时间片用完后，CPU 就会执行 进程 B，而进程 A 的状态信息需要保存下来，这样下次执行进程的时候才能保证 任务 看起来连续运行

进程的状态信息：

1、当前执行的位置：或者说程序计数器，最开始的时候也说 了，进程的执行实际上就是按照顺序执行每条指令，因此我们需要记录当前已经执行完的指令，方便下次从接下来的指令位置开始执行

2、全局变量、栈等资源

这些都保存在 PCB 中，等到下次 CPU 调用到该进程时，会从 PCB 中获取到这些信息，然后继续执行进程

进程上下文的切换由于需要保存旧进程的状态信息，读取新进程的状态信息，也是有点花费时间的，我们自然希望 开销越小越好



## 5、线程

上面我们提到的进程，是作为 CPU 调度的基本单位

即我们可以把上面的进程看作一个线程

但是由于某些原因，因此又提出了更小的独立运行的基本单位：线程



> ### 为什么使用线程？

我们举个例子，假设你要编写一个视频播放器软件，那么该软件功能的核心模块有三个：

- 从视频文件当中读取数据；
- 对读取的数据进行解压缩；
- 把解压缩后的视频数据播放出来；

对于单进程的实现方式，我想大家都会是以下这个方式：

![img](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcvw4t9kicec370n3cvX2JS929V7rcLXiaaB16boR9VraolG9Fgc9NpnxOSlHx7No6t0zSPrscaeuaA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

（这里需要说明一下，java 中，我们运行一个类 main() 方法的时候，它就是一个独立的进程，当我们运行两个类的 main() 方法的时候，它们就是两个独立的进程，互不干扰）

因此上面的这种方式是运行在一个类中的，是一个进程

单进程是按顺序执行的，即必须先 Read() 执行完毕后再 解压缩数据，再进行播放

由于需要边读取边播放，因此我们每读取 1 个字节就进行解压缩再播放，这样就可以边读取压缩边播放

对于单进程的这种方式，存在以下问题：

- 可能由于 CPU 的原因，我们在 Read() 方法这里卡住了，那么就会导致半天才能数据解压和播放，体验不友好
- 单进程的方式，各个函数之间不是并发执行的，而是顺序执行的影响效率

那改成多进程的方式：

![img](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcvw4t9kicec370n3cvX2JS9CInoGdDVyYvtTfju7gVeKLjDNOMmul4kPzicTbczNiaBSzGiaEzDXtYTA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

这就又产生一个问题了，多进程，其实就是多个类，一个类执行一个函数，那么这几个类怎么进行共享数据？比如你多个类同时执行 main() 方法，数据能共享吗？

不能吧！！！！

那到底如何解决呢？需要有一种新的实体，满足以下特性：

- 实体之间可以并发运行；
- 实体之间共享相同的地址空间；

这个新的实体，就是**线程( Thread )**，线程之间可以并发运行且共享相同的地址空间。



> ### 什么是线程？

通过上面我们可以看出，**线程是进程的一条执行路线流程**

即 Read() 可以作为一个线程，解压缩数据可以作为一个线程，播放可以作为一个线程

线程是在进程的基础上产生的，多个线程共享进程的资源，但又有自己的寄存器和栈，这样，就既能共享资源，又能有独立的运行空间而不受其他线程的影响，比如上面的 Read() 线程，它能跟别的线程一起 共享 进程的全局变量等，但又存在自己的局部变量



> #### 线程与进程的比较

**进程是资源分配的基本单位， 线程是调度的基本单位**。

这里我们可以看出来，最开始讲的进程是调度的基本单位，等到线程出来后，进程单单就变成了资源分配的基本单位了，即是提供一个资源共享的平台给它内部的线程使用，单单只是作为一个交流平台而已，所有的线程都可以来这里拿数据资源

所以，由于资源是共享的，所有线程都能拿到，才存在线程安全的问题，即到底是谁先拿到，以及谁做的改变才有效等问题





## 6、进程 和 线程 的总结

首先我们需要先知道，线程是什么？

最开始 进程是 CPU 调度的基本单位，单进程的情况下是代码串行执行，但对于某些方法，串行的效率太低，比如 播放电影，分为 三个步骤：读取二进制数据、解压缩数据、播放电影

这三个步骤如果是串行执行，那么如果在读取数据的过程中出现延迟，那么就会影响后面的操作，用户体验不好，效率也低

这就跟你烧水的时候什么事都不干，在那干等着一样

因此，就出现了多进程，读取二进制数据作为一个进程，解压缩数据作为一个进程，播放电影作为一个进程，各干各的，单核 CPU 下并发执行，多核 CPU 下并行执行，都差不多

但是，这就产生了一个问题：各个进程的内存是相互独立的，怎么进行共享？

虽然可以将内核作为资源共享平台，但是这样的话，一次电影播放，就需要无数次的经历 将用户态的数据复制到内核态，再将内核态的数据复制到用户态的过程，效率极低（进程间通信的消息队列就是需要经历 用户态核内核态的切换，所以效率低）

于是，产生了比进程更小的独立运行单位 - 线程，线程是在进程内部产生的，它们共享进程的资源，同时又有自己的内存空间（JMM 规定了 工作内存）

自此，进程变成了 资源分配的基本单位，线程变成了 CPU 调度的基本单位

同个进程间的线程资源共享，不存在 用户态和内核态之间的切换开销，线程切换开销比进程切换小

当然，如果是不同进程间的线程切换，那么也是需要发生 用户态和内核态 切换

但是，如果我们上面使用的是同个进程间的线程，那效率就高了， 既能够共享资源，切换开销又小，大大提升了效率





## 7、僵尸进程 和 孤儿进程

每个进程都有自己的唯一一个 ID 号（PID），并且都附带一个它的父进程的 ID 号（PPID），进程死亡时，ID 号会被回收

### 1、孤儿进程

子进程还没有结束，而父进程自己先执行完退出了，那么这个子进程就是一个孤儿进程，它会被交给 init 进程进行管理

相比僵尸进程，孤儿进程不会占用资源，因为它最终还是会被回收的



### 2、僵尸进程



子进程死亡后，它的 PCB 会交给父进程进行处理释放，但是如果父进程只顾着指向自己的代码，而一直没去释放这个 PCB，那么子进程就会变成一个僵尸进程

僵尸进程实际上是一个已经死掉的进程，即已经执行完所有代码，释放了几乎所有的内存空间，没有任何可执行的代码指令，也不能被调度，仅仅只是在进程列表保留一个位置而已

如果父进程一直在进行循环，而不去处理这个僵尸进程，那么这个僵尸进程的 PCB 基本不会被释放

如果父进程自己结束了也没有处理这个僵尸进程，那么这个僵尸进程会交给 init 进程（1 号进程）进行处理



**需要注意的是，每个进程都必定会经历过僵尸进程，只是时间长度而已**

如果一个子进程 调用 exit() 退出后，我们还没来得及调用 ps 命令查看，它就被父进程释放了，但是在子进程 exit() 到被父进程释放的这个过程，它就是属于僵尸进程的



**僵尸进程的危害：**僵尸进程如果一直不被释放，但是它的 PCB（进程号、终止状态、CPU 运行时间）会占用系统资源，虽然不大，但是一旦僵尸进程一多，那么占用的就多了，并且会占用进程号，每个进程的进程号是 唯一的，僵尸进程的进程号是不会被回收的



> ### 解决僵尸进程的方法



> 1、wait()

父进程调用 wait() 方法，等待任意一个子进程退出后，释放掉子进程的 PCB，然后返回，该方法会阻塞父进程，如果子进程全都迟迟不退出，那么父进程会一直阻塞，父进程无法继续执行自己的代码，这样效率低得一批



> 2、`waitpid(int pid,int *status,int options)`

该方法可以控制阻塞和非阻塞，内部有 3 个参数，第一个 是 pid, pid 取不同的值有不同的效果

- pid > 0，指定等待进程 ID == pid 的子进程，无论其他子进程是否退出，只要这个子进程没有退出，那么该方法就不会退出
- pid == -1，等待任意一个进程退出，跟 wait() 一样的效果
- pid == 0，等待同个进程组的任意一个进程，如果子进程加入了别的进程组，那么直接忽略该子进程
- pid < -1，等待指定进程组的任意一个子进程，进程组 ID == pid 的绝对值

上面这个 pid 等待的模式的，但是好像还是会阻塞啊，怎么使它不阻塞？

第三个参数 options，它可以控制是阻塞还是不阻塞，如果是 0 ，那么就是阻塞，如果是  WNOHANG ，那么就是非阻塞

当传入 WNOHANG 时，那么就查看对应的子进程是否已经退出，如果退出了，那么进行处理，如果没有，那么直接返回



我们可以发现，wait() 其实就是 waitpid() 中的 pid == -1 的一个包装而已，代码类似如下：

```java
public int wait(){
	return waitpid(-1, null, 0);
}
```



> 3、信号

直接调用 wait() 之类的方法显然是不明智的，阻塞进程效率太低

因此存在 信号 这个方法（参考进程间通信方法的 信号, kill 命令也是使用的信号），当子进程 exit 退出后，内核会发送一个  SIGCHLD（子进程退出信号） 信号给父进程，父进程接收到信号后，可以调用 wait() 方法去进行处理，不过当然也可以选择忽略这个信号



缺点：当创建 5 个子进程的时候，如果这 5 个子进程同时挂了，都给父进程发送  SIGCHLD 信号，那么可能其中的  SIGCHLD 信号到达时，父进程正在处理某个子进程的  SIGCHLD 信号，因此这个  SIGCHLD 信号会丢失，而 内核并没有使用队列等方式来存储同类信号，因此丢失了也就丢失了，所以最终可能会存在 一两个 僵尸进程没有被处理

因此，为了解决这个问题，只能调用 waitpid() 来进行处理

```java
for (;;) {
    //循环等待子进程退出，直到不存在任何子进程时，返回了 0
    if (waitpid(-1, NULL, WNOHANG) == 0)
        break;
}
```





> 4、两次 fork()

父进程 A fork) 出一个子进程 B，然后调用 waitpid(子进程 B 的 pid, null, 0) 等待给子进程 B 收尸

然后子进程 B 创建出真正需要的子进程，等创建完成后，子进程 B 调用 exit() 方法退出，这样 B 创建的子进程就变成了孤儿进程，交给 init 进程进行管理，也就不会变成僵尸进程了，这些子进程 和 进程 A 是爷孙关系，没有直接的父子关系，所以 A 不会接管这些进程

而父进程 A 只需要在 子进程 B 调用 exit() 后给它收尸，然后就可以去干自己的事了，这样就避免了僵尸进程



## 8、用户态 和 内核态

> ### 用户态 和 内核态的关系

在 CPU 指令中，有些指令是非常危险的，如果错用，那么可能将导致整个系统崩溃，比如：清内存 等，如果所有的程序都能够使用这些指令，那么有一天系统死机也就不为过了，黑客搞进一个程序随随便便用这些指令分分钟整死电脑

因此，不同的操作给予不同的权限，指令分为了两种：特权指令 和 非特权指令

普通的应用程序一般只能使用那些不会造成危险的指令，而那些危险的指令由操作系统内部进行调用



位于用户态的程序只能使用这些非特权指令，位于内核态的程序可以使用这些特权指令

**简单来讲，用户态 和 内核态 就是根据 使用指令的权限 而 划分出来两个区域，它们的区别就是 指令权限不同**



需要注意的是，程序的执行的 过程 就是 CPU 调用指令执行的过程，而 用户态 和 内核态 是 CPU 的两种不同状态，操作系统跟 CPU 配合，设置哪些内存可访问，哪些不可访问之类的，比如虚拟内存，应用程序只能访问已经映射了的地址空间，未映射的不能进行访问，防止用户越权



> ### 什么时候用户态会切换到内核态？

- 系统调用
- 异常中断：当前i进程在用户态时，发生了异常事件，就会发生切换，比如 缺页异常
- 设备中断：外设完成用户请求时，会向 CPU 发送中断信号



> ### 系统调用

内核控制着计算机的硬件资源，并提供上层应用程序运行的环境

用户态看作是应用程序的活动空间，需要依赖于内核提供的资源运行，包括 IO 资源、存储资源等

内核为了方便用户态的应用程序能够访问这些资源，内核为用户态提供了访问的接口：系统调用



向公用库函数 和 shell 上连应用程序，下连系统调用，它们封装了系统调用，用户程序只需要通过 shell  和 调用函数就可以访问系统调用

shell 可以是 Linux 那种命令行，也可以是 windows 那种 图形化节面，反正就是用户跟操作系统交互的窗口



![这里写图片描述](https://img-blog.csdn.net/2018040909190679?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0pIX1poYWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)



像 C 中的库函数 malloc()，内部就是调用系统调用 sbrk() 这个函数来告知内核进行内存分配的

等调用了 sbrk()，就发生了用户态到内核态的切换，类似的还有 print()、write() 之类的，内部都是调用系统调用
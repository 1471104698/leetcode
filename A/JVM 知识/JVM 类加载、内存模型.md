# JVM 类加载、内存模型





## 1、类编译 到 类加载 过程 及 产物



**我们需要先知道，Java 有两种对象：实例对象 和 Class 对象**



> ### 类编译

当我们写完代码后，生成的是一个 .java 的静态文件，这个文件在磁盘中

当我们点击运行 .java 文件的时候，它会先开始编译，将代码转变成二进制数据，其中是一条条的指令，变成 .class 文件（字节码文件）



> ### 类加载

JVM 将某个 .class 文件中的二进制数据加载进内存中，创建出对应的一个 `java.lang.Class` 对象，类加载的最终产物就是 JVM 中的 Class 对象



### 1.1、什么是 Class 类（类加载的最终产物）

---



> ### `java.lang.Class` 类 和 我们自己写的类的关系

除了 int 等基本数据类型之外**（基本数据类型不是类）**，**Java 的其他类型（包括 interface）都是 Class 类的实例**

其他类（接口）是 Class 类的实例？ 那么 Class 类是谁写的？

Class 类是 `jvm` 动态加载进内存的，它是 private 类型的，用户无法自己创建

```java
public final class Class {
    private Class() {}
}
```



Class 类里包含了 某个 class 类的所有方法变量信息，当 JVM 加载一种新的 class 类的时候，比如 String 类，那么就会**获取 String 的信息，为这个 String 类创建一个 Class 类实例，然后关联起来**

```java
Class cls = new Class(String);
```



也就是说，**除了 Class 外的其他所有 class 类，每个 class 类对应一个 Class 类实例，在 JVM 中的类都是 Class 实例**

```ascii
┌───────────────────────────┐
│      Class Instance       │──────> String
├───────────────────────────┤
│name = "java.lang.String"  │
└───────────────────────────┘
┌───────────────────────────┐
│      Class Instance       │──────> Random
├───────────────────────────┤
│name = "java.util.Random"  │
└───────────────────────────┘
┌───────────────────────────┐
│      Class Instance       │──────> Runnable
├───────────────────────────┤
│name = "java.lang.Runnable"│
└───────────────────────────┘
```



**注意：是一个 class 类对应一个 Class 实例，而不是一个 class 对象对应一个 Class 实例，即相当于我们平常的内存中的 Cat 类，它是一个 Class 实例，不过这个 Class 实例的名字对外暴露的是 Cat，它具有我们自己写的对应的变量，然后使用这个 Class 对象创建出更多的我们自定义的 所谓的 Cat 实例对象**





> ### 反射的概念

换言之，所有 class 类的信息都存储在对应的 Class 类实例中，那么我们只需要获取对应的 Class 类实例，就意味着获取了这个 class 类的所有信息，**通过`Class`实例获取`class`信息的方法，就是反射**



### 1.2、类加载的基本知识点

---

类加载需要知道几个基本知识点：

- JVM 只有在 两个类 的 类名（包名 + class 类名）相同 并且 由同一个类加载器加载的时候，才算作是同一个类
- 父类加载器加载的类子类可以看到，子类加载器加载的类父类看不到





### 1.3、双亲委派模型

---



> ### 什么是双亲委派模型？



当某个类加载器要加载类的时候，会将这个类一层层传递给父类加载器加载，如果父类加载器有这个类，加载成功，那么返回成功，否则就自己加载，这就是双亲委派模型



> ### 双亲委派模型的过程

ClassLoader 中有两个主要方法：loadClass() 和 findClass()

**其中 加载类的方法主要是 loadClass()，而 findClass() 是一个空方法，它需要子类去实现**

**loadClass() 是双亲委派机制的逻辑体现，而 findClass() 是类加载器对类进行加载的逻辑**

双亲委派模型加载过程：

- findLoadedClass() 判断该类是否已经被加载过了
- 如果没有，则判断当前加载器的父加载器是否为空，不为空那么交给父加载器去加载
- 如果为空，那么表示父加载器是 根加载器，那么交给根加载器去加载
- 如果都加载不成功，那么调用 findClass() 方法，进行加载（这里我们可以看出，我们自定义类加载器主要实现加载逻辑就是将 parent 设置为 null，这样根加载器肯定加载不了，然后再重写这个 findClass() 方法）

```java
    protected Class<?> loadClass(String name, boolean resolve)
        throws ClassNotFoundException
    {
        synchronized (getClassLoadingLock(name)) {
            //查看这个类是否自己已经加载过了
            Class<?> c = findLoadedClass(name);
            
            if (c == null) {
                long t0 = System.nanoTime();
                try {
                    //父类加载器不为空
                    if (parent != null) {
                        c = parent.loadClass(name, false);
                    } else {
                        //父类加载器为空，调用根类加载器加载
                        c = findBootstrapClassOrNull(name);
                    }
                } catch (ClassNotFoundException e) {
                }

                if (c == null) {
                    //调用自己的加载逻辑
                    c = findClass(name);
                }
            }
            return c;
        }
    }
```



> ### 双亲委派模型的好处



最开始也说了，JVM 认定类的原理，如果我们不使用双亲委派模型，自己写了一个 `java.lang.Object` 类，那么将会由 `AppClassLoader` 去加载

由于官方的 Object 类 和 我们自定义的 Object 类的类加载器不同

那么内存中就存在两个 Object 类，那么当我们使用 Object 类的时候，导入的` java.lang.Obejct`，也不知道是哪一个类

编译不会出错，但是运行会出错

```java
package java.lang;
//自定义 java.lang.Object 类
public class Object {
    public static void main(String[] args) {
        Object object = new Object();//编译不报错，运行报错
    }
}

```

  

双亲委派机制的好处：

- 用户写的类覆盖核心类
- 避免类重复加载（如果不是双亲委派，那么多个类加载器加载同个类，内存中就存在重复对象，并且算作是不同的对象，因为我们上面说了，只有被同个类加载器加载的类才是相同的类）



> ### 如何打破双亲委派机制

双亲委派模型的体现主要就是 ClassLoader 中的 loadClass() 方法

它会先调用父加载器进行加载，失败了才调用当前类加载器的 findClass() 

因此，我们自定义一个类加载器，有两种选择：

- **重写 loadClass() 方法：**自定义类加载的模型，这样就**破坏了双亲委派机制**
- **重写 findClass() 方法：** 将自定义类加载器的父类加载器设置为 null，这样就默认父加载器是根类加载器，它必定不能加载我们自己写的类，因此会交给我们自定义类加载器进行加载，因此我们重写 findClass() 方法，自定义类加载逻辑，但这实际上**并没有打破类加载机制**，因为它还是存在委托给 根类加载器的情况，虽然没起什么作用就是了



> ### 为什么要破坏双亲委派模型

**看起来双亲委派机制好像挺好的，那么为什么还需要打破呢？**

对于一般情况下，用户类使用的是基础类，但是有的情况下，基础类也需要使用到用户类

在基础类的代码中使用用户类，该用户类需要加载，那么怎么进行加载？看调用方法，比如 Class.forName()，它的方法逻辑是使用调用类的类加载器进行加载的，如果是 基础类内部调用了 Class.forName()，并且加载的是一个用户类，显然，根类加载器是无法加载这个用户类的，因为 根类加载器只能加载特定的类，那么需要调用 AppClassLoader 来加载这个类，这样，从父类加载器调用子类加载器加载类，就破坏了双亲委派机制



**什么时候基础类会去使用用户写的类呢？**

SPI 机制：service provider interface（服务提供商接口）

比如 jdbc，jdk 提供的是一个规范接口 Driver，并不提供实现，提供实现的是数据提供商，它们的所有实现都需要根据这个 接口规范，而在第三方的类总不能放在 jdk 目录里作为基础类被 根加载器加载吧。。。

为什么这里会说 第三方实现类是由 根类加载器加载的，我们需要从没有 SPI 的时候说起

在没有 SPI 的时候，jdbc 我们不能使用接口编程，即不能：

```java
Class clz = Class.forName("java.sql.Driver"); Driver d = (Driver)clz.newInstance();
```

通过反射 Driver 类，因为 Driver 只是一个接口，没有具体的实现类，这样会报错

我们可以在  classpath 中引入一个  mysql-connector-java.jar ，里面有 Driver 的一个实现类，因此我们可以写成

```java
Class clz = Class.forName("com.mysql.jdbc.Driver"); Driver d = (Driver) clz.newInstance();
```

具体反射这个实现类，这就是我们自己硬编码指定加载某个类

这样的硬编码显然不合适，这种做法无法面向接口编程

因此，引入了 SPI 后，代码就变成：

```java
Connection connection = DriverManager.getConnection("jdbc:mysql://xxxxxx/xxx", "xxxx", "xxxxx");
```

DriverManager 自动根据 jdbc:mysql 去找实现，而 DriverManager 是根类加载器加载的，这样的话，它找到实现类，这个实现类是第三方类，使用默认的双亲委派机制的话，它没有父类，而自己(根类加载器)也无法加载，因此，就引入了线程上下文类加载器，可以通过线程上下文类加载器获取 AppClassLoader，来加载这个第三方类





## 2、JVM 内存模型



**JVM 内存结构有三大块：程序计数器、方法区、堆内存 和 虚拟机栈**

其中，堆内存是最大的一块

**堆内存 和 方法区 是线程共享的，栈 是线程私有的**



### 2.1、程序计数器

---

线程私有，即每个线程都有一个程序计数器，记录指令的执行位置



### 2.2、虚拟机栈

------

线程私有，即每个线程都有一个虚拟机栈，每个线程都有自己的方法调用链，虚拟机栈存储调用的方法的栈帧

> **它是 JVM 用来描述 Java 方法执行的内存模型**

每当一个方法被调用时，就会创建一个新的栈帧，当某个方法执行完毕后，那么就会将栈顶的栈帧弹出

由于是栈模型，所以表示栈顶的栈帧是最新的，即对应的是当前正在执行的方法



栈的内存空间也是有限的，即存储的栈帧是有限的，即递归调用的方法数是有限的

如果一直深入递归，那么就会栈溢出，那么抛出 StackOverflowError 异常

```java
package cn.oy;

public class Fuxk {
    public static void main(String[] args) {
        dfs();
    }
    public static void dfs(){
        dfs();
    }
}
```



### 2.3、本地方法栈

---

线程私有，跟虚拟机栈差不多的，不过是存储 native 方法的栈帧

native 方法可以在 Object 中找到：getClass()、clone()、wait()、notify()



### 2.4、堆内存

---

线程共享

堆内存 是 JVM 内存中最大的一块内存，基本上所有 的实例对象都是在这里分配内存，即基本上所有的实例对象都是存储在堆内存中

**堆内存分为：新生代（一个伊甸区、两个幸存区，比例为 8：1：1）和 老年代**

**当堆内存无法给新的实例对象进行内存分配的时候，那么就会抛出 OutOfMemoryError 的异常**



### 2.5、方法区

---

线程共享

存储 JVM 加载的类的信息、常量、静态变量、代码段等

反射获取的类型、方法名、变量等都是在方法区获取的



**当方法区无法满足内存分配需求时，将抛出 OutOfMemoryError 异常。**





## 3、JVM 内存分配策略



JVM 内存分配 有 5 钟策略

**注：新生代划分为 伊甸区（E区） 和 两个幸存区（S区），比例为 8：1：1**



> ### 对象优先进入新生代

大多数情况下，对象都是在 E区 中分配内存，当 E区 无法给申请内存的对象分配连续的内存的时候，那么就会触发一次 minor GC（young GC）

将 E区、S区① 存活的对象放到 S区② 中，然后 S1 和 S2 互换指针，保持 S区② 指针指向的区域 是空的



> ### 大对象直接进入老年代

大对象是需要大量连续的内存空间的，比如大数组和超长字符串，由于存放在 E 区的话很容易导致内存不足而频繁产生 GC，所以直接放到 老年代

对于多大的对象才直接进入老年代，可以通过参数设置



> ### 根据对象年龄判断是否进入老年代

所谓的年龄，如果经历过一次 young GC 对象仍然存活，那么年龄 +1，如果没有存活，那么直接享年 x 岁

某个对象第一次经历 young GC 存活时，会将该对象从 E区 移动到 S区①，且对象年龄为 1，往后只要经历过 指定次 young GC 还活着，那么就将该对象移动到 老年代



> ### S区 中相同年龄的所有对象大小 之和 超过 S区 空间一半，直接进入老年代

上述讲的 对象年龄到达阈值 才进入老年代的，其实并不是一定的，因为幸存区可能很多个对象都存活，并且都存活了很多次，那么我们可以根据这个判断条件，将相同年龄的对象数超过幸存区空间一半的时候，将大于等于该年龄的对象提前放入老年代



> ### 空间分配担保（这个就不太容易理解了，后续有时间再来理解吧）





## 4、类的生命周期（类加载过程）

类加载（加载 class 文件到内存中，生成 Class 对象） - 验证（校验 class 文件中的字节流信息符合虚拟机的规范，防止恶意代码）- 准备（给静态变量赋 jvm 内部设定的初始值，执行静态代码块） -解析（类加载时的 符号引用转换为直接引用） -初始化（执行类的构造器，比如 new 之类的代码，执行构造代码块，给变量赋值）-卸载（回收对象）



**加载：**上面都说了，是加载 class 文件到内存当中，创建一个 Class 对象，这时候方法区里面的数据代码段和常量池之类的都准备好了

**验证：**上面说了

**准备：**静态变量赋 jvm 设置的初值，比如 int 设置为 0

**解析：**符号引用转换为直接引用

**初始化**：主动使用 时进行初始化，关于初始化什么，看下面

**卸载：**1、该类没有任何实例   2、该类的 Class 对象没有在任何地方引用，即无法同个反射获取 Class 对象



主动使用：常见的就是 new 了

> ### 初始化 是在干什么？

首先，如果是 new 这种的话，那么执行的顺序为：

- 先是父类，静态变量赋值，执行静态代码块
- 然后是子类，静态变量赋值，执行静态代码块
- 然后再是父类，非静态变量赋值，执行构造代码块，调用构造方法
- 然后再是子类，非静态变量赋值，执行构造代码块，调用构造方法

new 这种的话会使得 静态和非静态 都进行初始化

而如果是 调用静态变量 或者 静态方法，或者 在某个类上执行 静态的 main()，或者 Class.forName() 进行反射

那么上面的顺序不变， 只是 非静态变量  不会赋值，构造代码块和构造方法不会执行

**注意：**如果是在 子类使用 main()，那么父子都会静态初始化，如果是在 父类使用 main()，那么只有父类会静态初始化





## 5、符号引用 和 直接引用



> ### 符号引用

编译成 class 文件后，代码变成一条条的指令，而这些指令就是都是字符串的形式

这些字符串包含了足够多的信息， 如：“java/io/PrintStream.println:(Ljava/lang/String;)V”。

里面有类的信息，方法名，方法参数等信息。 就是一个开发者自己指定的模板



> ### 直接引用

第一次运行时，根据符号引用这个模板，拆分出信息，然后定位到 该方法/变量

比如上面的例子，定位到 java.io.PrintStream 类里的参数为 String 的 println() 方法

然后使用 直接引用 替代，后续就无需再次搜索




## **[1020. 飞地的数量（从边界开始向内部进行扩展）](https://leetcode-cn.com/problems/number-of-enclaves/)**

```java
给出一个二维数组 A，每个单元格为 0（代表海）或 1（代表陆地）。

移动是指在陆地上从一个地方走到另一个地方（朝四个方向之一）或离开网格的边界。

返回网格中无法在任意次数的移动中离开网格边界的陆地单元格的数量。
```



## **示例 1：**

```java
输入：[[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]]
输出：3
解释： 
有三个 1 被 0 包围。一个 1 没有被包围，因为它在边界上。

/*
[0,0,0,0]
[1,0,1,0]
[0,1,1,0]
[0,0,0,0]
*/
```



## **示例 2：**

```java
输入：[[0,1,1,0],[0,0,1,0],[0,0,1,0],[0,0,0,0]]
输出：0
解释：
所有 1 都在边界上或可以到达边界。

/*
[0,1,1,0]
[0,0,1,0]
[0,0,1,0]
[0,0,0,0]
*/
```



## 实现思路

```java
我们不能直接遍历到每一个陆地，然后对该陆地进行 dfs，再判断是否能够到达边界，这样是错误的
因为我们必定会对中途遍历过的节点记录结果
比如 示例 2
[0,1,1,0]
[0,0,1,0]
[0,0,1,0]
[0,0,0,0]

我们找到第一个 陆地 (0, 1)，如果这时候它往右边走，到达 陆地 (0, 2)，如果这时候它先往下走，到达陆地 (1, 2)
由于陆地 (1, 2) 不能往上走，因为为了防止重复遍历，我们设置 (0, 2) 为已访问，因此它只能往下走，这样一直到最后发现到不了边界
这样返回，导致陆地 (1, 2) 的 arrived[1][2] = false，但其实它是能够到达陆地的，只是需要往上走，但是因为我们堵住了去路，导致它无法往上走，导致错误

因此，换种思路，我们从边界的 陆地 出发，向内部延伸，能够延伸到的陆地都是能够到达边界的

//防止重复访问的处理：将访问过的陆地同化为海洋
```



## 实现代码

```java
class Solution {
    public int numEnclaves(int[][] A) {
        /*
        从边界向内扩展
        */
        this.rlen = A.length;
        this.llen = A[0].length;

        //处理边界能够延伸到的地方
        //上下边界
        for(int col = 0; col < llen; col++){
            dfs(A, 0, col);
            dfs(A, rlen - 1, col);
        }
        //左右边界
        for(int row = 0; row < rlen; row++){
            dfs(A, row, 0);
            dfs(A, row, llen - 1);
        }
        int c = 0;
        for(int i = 0; i < rlen; i++){
            for(int j = 0; j < llen; j++){
                if(A[i][j] == 1){
                    c++;
                }
            }
        }
        return c;
    }
    int rlen;
    int llen;
    int[][] pos = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
    private void dfs(int[][] A, int i, int j){
        //可以走出边界
        if(i < 0 || i == rlen || j < 0 || j == llen || A[i][j] == 0){
            return;
        }
        //将陆地同化为海洋，表示已经访问过了
        A[i][j] = 0;
        for(int[] p : pos){
            int x = i + p[0];
            int y = j + p[1];
            dfs(A, x, y);
        }
    }
}
```


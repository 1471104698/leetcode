## [面试题 16.07. 最大数值（比较 a 和 b 的大小，没见过基本不会的）](https://leetcode-cn.com/problems/maximum-lcci/)

```java
编写一个方法，找出两个数字a和b中最大的那一个。不得使用if-else或其他比较运算符。
```



## **示例：**

```java
输入： a = 1, b = 2
输出： 2
```



## 实现思路

```java
比较 a 和 b 的大小，没见过基本不会的

问题1：
由于不能使用比较运算符，那么意味着我们不能简单的使用 a > b 之类的直接进行判断，那么需要怎么进行判断？
我们可以通过 a 和 b 的差值 的正负情况来判断 a 大于 b 还是 a 小于 b

问题2：
即使我们得到了 a 和 b 之间的差值 int diff = a - b，由于不能使用比较运算符，那么我们怎么知道 diff 是正的还是负的呢？
首先我们需要知道计算机中 正数 和 负数 的二进制存储情况
比如 int 32 位，最高位是符号位，为 0 表示是 正数，为 1 表示是负数
    那么对于此题，我们可以通过 借助这个 高位 来判断正负，如果 diff 最高位是 0 ，表示 diff 是正的，如果是 1，表示 diff 是负的

需要注意的是：
比如 a = Integer.MAX_VALUE ，b = -1 之类的，那么  a - b 就会溢出，为了防止溢出造成的错误结果，
我们需要将结果转换为 long 型 来保证结果的正确性
转换为了 long 型，那么就有 64 位，我们可以直接判断 最高位是 0 还是 1 即可

问题3：
我们得到了 最高位的 二进制数 k，但是同样的不能使用 比较运算符来 根据 0 和 1 来返回结果，
即不能直接 k == 0 ? a : b，那么我们需要怎么处理 k 来返回 a 和 b?
由于 k 不是 0 就是 1，由于存在 这两条性质：0 * a = 0, 1 * a = 1，因此我们可以直接 (1 - k) * a + k * b 来返回
这里解释一下：
	如果 k == 0，表示 a > b，那么 (1 - 0) * a + 0 * b = a + 0 = a
	如果 k == 1，表示 a < b，那么 (1 - 1) * a + 1 * b = 0 + b = b
```



## 实现代码

```java
class Solution {
    public int maximum(int a, int b) {
        /*
        
        */
        long res = (long) a - b;
        //k 为 0 或 1, 为 0 表示 a 大，为 1 表示 b 大
        int k = (int)((res >>> 63) & 1);
        return a * (1 - k) + b * k;
    }
}
```


# Mysql 索引



## 1、索引作用以及局部性原理

mysql 存储大量数据，底层的存储数据结构和查找结构 的设计 显得十分重要

索引是用来做数据的快速查找的，而快速查找的底层本质涉及到的是数据结构，通过不同数据结构的选择，可以实现不同的快速查找

在数据库中，使用高效的查找算法显得十分重要，当不使用索引的时候，那么查找 id = 7 的数据，只能通过暴力查找，找到 id = 7 的数据需要比较 7 次，如果表存储的是 1000W 的数据，那么查找 id = 1000W 的数据需要比较 1000W 次，这显然是无法接收的

因此，就出现了索引，用来加速查找

而选择哪种数据结构 作为索引的底层实现，就显得格外重要了

需要考虑到查找某个数据、范围查找 等各种查找条件的效率，除此之外，索引数据本身很大，所以不可能存储在 内存中，因此需要存储在硬盘中，这样的话查询 索引 就需要进行 磁盘 IO，而一次磁盘 IO 的消耗比内存存取要高几个数量级，因此，使用索引要尽量减少 磁盘 IO，即 磁盘 IO 的次数也成了索引 数据结构的选择之一



> ### 局部性原理

**局部性原理：当某个位置的数据被使用时，那么在不久的将来它附近的数据也会被使用**



由于磁盘 IO 中，寻道（磁头旋转到数据所在位置）时间消耗的时间最长，因此一般数据读取都会用局部性原理

每次磁盘 IO 读取数据往往不是按需读取，而是每次都会预读，假设本次 磁盘 IO 只需要一个字节，那么也会从这个字节的位置开始，往后读取一定长度的数据放入内存，由于操作系统的内存是分页管理的，因此每次预读的长度都是 页 的整数倍。

这样的 磁盘 IO 是顺序 IO，不需要进行寻道，直接往下读就行了，顺序 IO 下，从磁盘读取 1 B 的数据和 读取 1 KB 的数据花费的时间基本上是一致的



**因此，索引的底层数据结构选择要能够进行满足局部性原理的**



综上，索引的选择需要满足以下条件：

- 快速定位到某个值
- 能够进行范围查询，效率要高
- 磁盘 IO 次数少
- 利用磁盘每次预读 页 的整数倍的局部性原理，减少磁盘 IO



## 2、索引的底层数据结构选择



### 1、哈希表

哈希表 可以 O(1) 定位到某个位置

假设我们求 id = 7 的数据，给 id 计算出一个 hash 值，然后通过 % capa 得到存储槽位，获取对应的数据

但是 hash 算法会存在数据冲突，即两个以上的数据经过 hash 计算出的结果是一样的，这样就产生 哈希冲突

常见的做法是使用链地址法，这样的话，遍历数据就需要 从链表头遍历到链表尾



我们可以看出，Hash 索引 的 Node 数据结构类似如下：

```java
class Node{
    //hash 值
	int hash;
    //数据行指针
    Data data;
    //下一个节点
    Node next;
}
```

Node 保存 索引列 Hash 计算过后的 Hash 值 以及 指向的数据行的指针、以及指向的下一个节点



![img](https://images.xiaozhuanlan.com/photo/2020/d03e9a1bda94819f46dc53ace46610d8.png)![img](https://images.xiaozhuanlan.com/photo/2020/77f494919bbd12605a768801960f9953.png)  

  ![img](https://img-blog.csdn.net/20170104204929966)





可以看出，哈希表能够 O(1) 查找数据，效率很高，但为什么索引不使用 哈希表呢？

[Hash 索引的弊端](https://www.cnblogs.com/igoodful/p/9361500.html)

1. Hash 索引只能满足 '='、'in' 等一些等值查询，不支持 '>'、'<' 等范围查询，因为 Hash 索引比较的是 Hash 运算后的 Hash 值（类似 HashMap 中的 Node.hash），所以只能用于等值过滤，O(1) 定位，但是比如 where a > 2 这种，Hash 运算后 a > 2 的数据分布没有规律可言
2. Hash 索引无法避免排序，比如使用 order by 这种，在 B+ 树作为索引的时候，可能查询的顺序结果集就是已经排完序的结果集，而 Hash 索引查询出来的数据本身可以看作是乱序的
3. Hash 索引不能用于联合索引的部分查询，即不满足最左匹配原则，因为 Hash 的联合索引是 几个列值合并后再一起计算的 Hash 值，不能够单独拆分，比如 (a, b, c) 联合索引，查询 where a = 1 and b > 2 时是无法使用联合索引的，因为差了 c，索引无法利用
4. Hash 索引不能避免回表扫描，我们从上面的 Hash 索引的 Node 节点可以看出，它没有保存任何的关于列的信息，比如我们给 b 建索引，查询 where b = 2，但是我们只是给 b = 2 进行 Hash 计算得到 Hash 值 h1，然后定位到指定的槽位，遍历链表，然后找到 Hash 值为 h1 的节点，但是我们并不知道它的其他列的值为什么，这样的话就必定需要进行回表。上面也说了，它不支持联合索引的部分索引扫描，那么就意味着不能使用覆盖索引了，那么就必须回表了，我们总不能是 select b from user where b = 2 吧，根据查询条件 b 查询出 b 值。。。我们要查询显然是查询我们不知道的列的值，而 Hash 索引不会保存列值，这才导致了它必须进行回表



### 2、二叉查找树

很简单，由于不会自己保持平衡，所以可能会退化成链表，查询效率低



### 3、AVL 树 和 红黑树

AVL 树 和 红黑树的区别就是 AVL 树是高度平衡的，保持平衡的开销比 红黑树大

但是由于保证了平衡，因此 AVL 的树的高度一般比 红黑树 低，这样的话，磁盘 IO 的次数也就比 红黑树少了



但是不使用它们的原因是因为它们本身节点存储的数据量少，当节点个数多时，树的高度很大，导致磁盘 IO 次数增加，降低效率

基本 AVL 和 红黑树都是数据存储在 内存中才会使用到的数据结构，因为这样可以避免磁盘 IO



### 4、B 树

B 树 是一棵平衡的多叉查找树，它与二叉树最大的不同就是，每个节点可以存储多个数据，而二叉树每个节点只能存储一个数据



当我们设置 B 树的每个节点可存储 key 的个数越多时，那么高度越小，比如 存储 16 个数据的 B 树，只需要 2 次 磁盘 IO，效率超过 AVL 树一半

![img](https://pic3.zhimg.com/80/v2-7d5e34c698b1e4192ad0ff93c2c897d0_720w.jpg)





B 树作为索引树，是通过 增加节点存储的数据量来减少树的高度，进而减少磁盘 IO

并且他每个节点都存储数据行，因此不会存在 聚簇索引 和 非聚簇索引 的概念

![img](http://cdn.17coding.info/WeChat%20Screenshot_20190620221029.png)



mysql 中的 B 树有几个特点：

- B 树查找效率为  O(hlogn)，h 为树的高度，n 为每个节点关键词的个数，当我们找到某个节点的时候，可以通过二分查找判断某个关键词是否存在，这样的话就是 O(logn)，而高度为 h，最坏需要 h 次，因此时间复杂度为 O(hlogn)
- 减少了磁盘 IO
- 每个节点既存储索引，又存储数据



```java
这里需要说下，B 树扩充每个节点存储的 key 的个数也同样利用了局部性原理加快速率

因为磁盘预读每次都是以 页的整数倍进行读取的，因此 B 树将每个节点的大小设置为页
这样每次读取的话就是刚好按照页为单位，读取一整个节点，既一次 IO 获取了整个节点
而这个节点中又存储了很多的 key，提高了查询的数据量，因此提高了查询的效率
```



### 5、B+ 树



节点值 [P 4 P 8 P] 代表的含义：

P 表示指针，在 4 左右两边存在 两个 指针，左边的指针表示指向的数据是比 4 小的，右边的指针指向的页表示是大于等于 4 的

同理 8 左右两边也存在两个指针

![img](http://cdn.17coding.info/WeChat%20Screenshot_20190621220003.png)

 ![img](https://user-gold-cdn.xitu.io/2019/5/30/16b0646cdc6268b7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

 

B+ 树只有叶子节点才存储数据，其他的节点都是存储索引值

由于 B 树每个节点存储了索引和数据，而 B+ 树除叶子节点外每个节点只存储 索引，因此 B+ 树一个节点能存储更多的 key，借此可以直接通过 一次 磁盘 IO 和 二分查询 判断更多的数据

并且由于每个节点能够存储的 key 更多，导致每一层的数据量就更多，从而使得树**的高度减少，磁盘 IO 数量减少**

同时 B+ 树的叶子节点是通过指针相连来构成链表的，**方便范围查询**



#### 5.1、B+ 树 3 层存储数据量为多少？

[B+ 数存储数据量计算]( https://blog.csdn.net/qq_41999455/article/details/104946754 )



InnoDB 一页的大小为 16KB，而 B+树设置的每个节点的大小为 一页，即 B+ 树每个节点可以存储 16KB 数据

在 大部分文件系统，包括 windows ，最小存储单元为 块，一块为 4KB

磁盘空间是划分为一个一个扇区的，每个扇区大小为 512B，即 0.5KB，硬盘的读写以扇区作为基本单位

比如下面的文件，实际数据大小只有 1B，但是却占用了 4KB 的空间

*![image.png](https://pic.leetcode-cn.com/1604650481-hGoCmv-image.png)**



我们已经知道 InnoDB 存储引擎每个 页的大小为 16KB，那么一棵 3层 B+ 树存储的数据量如何计算？

首先，B+ 树包含叶子节点和非叶子节点，非叶子节点只存储 索引值和指针的 Node，叶子节点存储数据行 data

假设索引值为 int 型，那么是 4B，指针大小在 InnoDB 源码中为 6B，那么一共 10B，这样的话，一个页能够存储的 Node 数 为 16KB / 10B = 1600，即一个页可以存储 1600 个 Node（实际上 指针数 = 索引值数 + 1，但这里忽略不计）

**第一层：**因为树都只有一个根节点，那么最大为 1600 个 Node

**第二层：**第一层的每个 指针 又可以指向 一个页，这样总的 Node 数为 1600 * 1600 = 2,560,000（两百万）

**第三层：**第二层的每个 指针 又可以指向 一个页，这个页中存放着数据行 data，假设一行数据 大小为 1K，那么一个页可以存储 16 行数据，这样总的存储数据量为 1600 * 1600 * 16 = **40,960,000（四千万）**



## 3、索引 的 种类

### 1、聚簇索引

聚簇索引 表示索引树的叶子内的数据就是完整的数据行

如果表设置了主键，那么主键构成的索引树就是 聚簇索引，它的叶子节点存储完整的数据行

如果没有设置主键，那么找到第一个 not null 属性 的唯一索引作为聚簇索引

如果还没有，那么使用 InnoDB 在每行数据后面 生成的隐藏字段之一的 row_id 作为 聚簇索引



如下图就是 聚簇索引 的索引树，叶子节点就是完整的数据行

*![image.png](https://pic.leetcode-cn.com/1599556528-sXLuAF-image.png)*



### 2、非聚簇索引

除 聚簇索引 索引外的其他所有，都是 非聚簇索引

比如设置了主键为 聚簇索引 后，那么剩下的唯一索引也会称为 非聚簇索引

它的特点是叶子节点存储的是 对应所在数据行的 聚簇索引

意思是我们查找 非聚簇索引 的话，需要进行两次查找才能得到完整数据行

- 第一次查找 非聚簇索引 的索引树，在叶子节点处得到 聚簇索引 的值
- 第二次查找 聚簇索引 的索引树，在叶子节点处得到完整的数据行

因此查找 聚簇索引 效率比 查找 非聚簇索引 效率高



**拿着 从 非聚簇索引 的索引树上查找到的 聚簇索引 的值，再从 聚簇索引 的索引树上查找数据，这个过程叫做回表**



下图就是查找 非聚簇索引 的索引树，以 age 字段构成的索引，对比上述的 聚簇索引的索引树看，叶子节点对应的是上述 聚簇索引 的值

*![image.png](https://pic.leetcode-cn.com/1599556509-eedyXk-image.png)*



> ### 为什么一个表只存在一个 聚簇索引 ？多设置几个提高查询效率不好吗？

我们需要知道，聚簇索引 它的叶子节点存储的是完整的数据行，当一个表的数据量达到 上千万，上亿 的时候，那么对应的这个 索引文件将会是非常大，如果多设置几个，并且还有多个表，这空间占用，这谁顶得住？？？





### 3、联合索引

联合索引说的是多个列组成一个索引，构建一棵索引树

比如 (id, age, name) 就是将 id、name、age 三个列建立成一个索引树，数据存放 以及 查询的顺序从左到右，因为 索引树是 B+ 树，它是一棵多路平衡查找树，内部自动是有序的，而这个排序则是按照 联合索引的列的定义顺序来的，因此排序是先按照 id，如果 id 相同再按照 age，如果 age 相同则再按照 name

因此，当我们使用联合索引进行查询的时候，需要注意查询条件的使用，因为索引树内部是有排序的，因此表面看来，所有数据的排序初始是根据索引的第一个列来进行排序的，尔后才是根据第二个列。因此如果第一个列没有使用到，这就意味着对后面的字段来说这棵索引树就变成了无序的了



比如 `idx_a_b_c` (`a`,`b`,`c`) 

```java
 select  * from test where a = '333' and b = '333' and c = '333'; //走索引，走 a b c

 select  * from test where a = '333' and b = '333'; //走索引，走 a b 

 select  * from test where a = '333' and c = '333';//走索引，走 a

 select  * from test where  b = '333' and c = '333'; //不走索引，因为索引树是按照 a 排序的，a 不查询的话 索引树就无序了

 select  * from test where c = '333' and b = '333' and a = '333'; //走索引，走 a b c

 select * from myTest  where a=3 and b>7 and c=3; //走索引，走 a 和 b，而 c 被 b 阻断了
 
 select * from myTest  where a>4 and b=7 and c=9; //走索引，只有 a , 后面的 b 被 a 阻断了

 select  * from test where a = '333' and b like '%3' and c = '333'; //走索引，只走 a，因为 b 无法确定前面的数值，这样的话就是无序的了

 select  * from test where a = '333' and b like '3%' and c = '333'; //走索引，走 a 和 b，因为 b 能够确定前面的数值，因此还是有序的
```



> ### 索引 区分度

索引的区分度，可以用来衡量索引值的优劣

索引区分度 = 不重复的索引值个数 / 数据表的总记录数， 这表示区分度越高，查询某个数据越能过滤掉更多的数据

越接近 1，区分度越高



如果对 性别 sex 建立索引，那么只有 0 和 1 两个值，整张表假设 千万数据，区分度低得一批，那么查询也不能过滤掉多少数据，因此没必要建立索引，直接走 聚簇索引扫描



> ### 最左匹配原则

建立联合索引的时候，区分度最高的放在左边，因为这样能够过滤掉很多数据

需要注意的是

- 最左匹配原则当匹配到范围查询的时候会停止匹配
- 索引的建立 跟 where 字段的顺序没有多大关系，因为查询优化器会自动进行优化



假设我们对 (a, b) 建立索引，那么索引树如下

我们可以看到，a 是全局有序的，而 b 是局部有序的，即在 a 相同的情况下， b 保证了有序

而在 a 不同的情况下，b 是无序的，这就是导致 范围查询 停止匹配的原因，因为范围查询字段后面的字段是无序的

![img](https://pic3.zhimg.com/v2-fcde0ef783885b6b17999f39ca2808b5_b.jpg)



> ### 索引建立 练习

```sql
SELECT * FROM table WHERE a = 1 and b = 2 and c = 3;
```

可以对 (a,b,c)、(a,c,b)、(b,a,c)、(b,c,a) 建立索引，具体情况看哪个区分度最高



```sql
SELECT * FROM table WHERE a > 1 and b = 2;
```

由于 最左匹配原则 会在范围查询处停止，所以即使 a 的区分度更高，我们也不能建立 (a,b) 索引，而应该建立 (b,a) 索引



```sql
SELECT * FROM `table` WHERE a > 1 and b = 2 and c > 3;
```

可以建立 (b,a) 或者 (b,c)，具体看 a 和 c 哪个区分度更高



```sql
SELECT * FROM `table` WHERE a = 1 and b = 2 and c > 3;
```

可以建立 (a,b,c) 或者 (b,a,c)，具体看 a 和 b 哪个区分度更高



```sql
SELECT * FROM `table` WHERE a = 1 ORDER BY b;
```

对 (a,b) 建立索引，这样 a 查找完 b 也是有序的



```java
SELECT * FROM `table` WHERE a > 1 ORDER BY b;
```

对 (a) 建立索引，因为 a 是范围查找，对 b 来说是无序的，用不到索引，没必要建立 (a,b) 索引



```sql
SELECT * FROM `table` WHERE a = 1 AND b = 2 AND c > 3 ORDER BY c;
```

建立 (a,b,c) 或者 (b,a,c)，具体看 a 和 b 哪个区分度更高



```sql
SELECT * FROM `table` WHERE a IN (1,2,3) and b > 1;
```

对 (a,b) 建立索引，因为 IN 相当于等值查询，查询完 a = 1 ，b  是有序的，然后再去查询 a = 2，b 也是有序的，a = 3 也是如此



```sql
SELECT * FROM `table` WHERE a = 1 AND b IN (1,2,3) ORDER BY c;
```

可以建立 (b,a) 或者 (a,b)，具体看 a 和 b 哪个区分度更高

对于 order by c 来说，是用不到索引的，因为 a 和 b 中按照顺序查询出来的数据行中 c 是无序的，最终还是需要进行排序



```sql
SELECT * FROM `table` WHERE a = 1 AND b IN (1,2,3) AND c > 3 ORDER BY c;
```

可以创建 (a,b,c) 或者 (b,a,c)，具体看 a 和 b 哪个区分度更高，而 c 能够上索引是范围查询

对于 order by c 来说，我们按照顺序查询出来的 同时满足 a = 1 和 b = 1 以及 a = 1 和 b = 2 以及 a = 1 和 b = 3 的数据行中 c 的值是无序的，最终还是需要排序





### 4、覆盖索引

覆盖索引是针对某种 select 来说的 联合索引

就是查询的字段全部在索引上，这样的话就无需回表



比如 `idx_a_b_c` (`a`,`b`,`c`) 

```java
 SELECT a,b,c from test where a = '333'; //无需回表，因为 a b c 三个列构成了一棵索引树，而查询的字段 a b c 都在这棵索引树上，因此无需再去 聚簇索引 的索引树上进行回表查询

 SELECT a,b,c,d from test where a = '333'; //需要回表，因为查询的字段 a b c d 中，只有 a b c 在索引树上，而字段 d 没有，因此需要到 聚簇索引 的索引树上获取对应的完整数据行，然后获取字段 d 的值
```



**由此可知，身为 聚簇索引一定只需要查询一遍索引树，而非聚簇索引 的可能只需要查询一遍索引树（覆盖索引），也可能需要查询两边索引树**

**因此，一般我们建立索引，查询字段尽可能满足 覆盖索引，这样可以少一遍 索引树的查询**





## 4、全文索引

原文链接：<http://www.360doc.com/content/17/1211/13/33260087_712076317.shtml>



当我们使用模糊查询的时候，一般情况下使用的是 like "%xxx%"

而当我们只记得某篇文章的某个字段，但又不确定这个字段是正确的，印象中又记得文章作者的名字中的某个字，那么 sql 语句会是这样的：

```sql
select * from t where 文章 like "%xxx%" or 作者 like "%xxx%"
```

这种 sql 语句显然就是在找死，一篇文章可能上千个字，而且使用这个 like 还不能走索引，效率低得一批，查完茶都凉了

业务中基本不可能这么用，那么是怎么实现类似这种 sql 的高效查询呢？

使用 全文索引



创建表的同时创建全文索引

```sql
             CREATE TABLE article (
                 id INT AUTO_INCREMENT NOT NULL PRIMARY KEY,
                 title VARCHAR(200),
                 content TEXT,
                 FULLTEXT(title, body)
             ) TYPE=MYISAM;
```

全文索引就是对某些指定的列创建索引，然后指定对应的关键词存在于哪些数据行中，记录对用的数据行 id



假设我们有这么一张数据库表

*![image.png](https://pic.leetcode-cn.com/1600506086-AQqybI-image.png)*



我们对 文章内容 创建了一个全文索引，记录出现对应关键词的数据行的 id

*![image.png](https://pic.leetcode-cn.com/1600506211-kxZPcJ-image.png)*

这里的关键词是内部自动进行分词的，原本默认只支持英文分词，后续更新好像支持中文了



## 5、为什么 MongoDB 使用 B 树作为索引，而 mysql 使用 B+ 树

具体看  https://zhuanlan.zhihu.com/p/107228878 



**B 树 结构：**

 ![img](https://pic3.zhimg.com/80/v2-e58725270f022db69a68d0dc727e5bf2_720w.jpg)

B 树的特点：

- 每个节点都存储数据
- 相邻节点之间没有指针连接



**B+ 树 结构** 

 ![img](https://picb.zhimg.com/80/v2-0e3ace7e4fa6cf4da345f12e98aca872_720w.jpg) 



B+ 树的特点：

- 只有叶子节点之间存储数据
- 叶子节点的相邻节点存在指针连接



由此看来：

（1）B 树每个节点都存储数据，查询的效率不固定，最好的情况是 O(1)，最坏也是 O(logn)

因此 B 树在**单一查询平均性能更好**

而 B 树中个节点之间没有相邻指针，因此**不适合做范围查询**，因为只能顺着某条路径往下，如果要遍历相邻节点，就需要从根节点开始遍历 或者 dfs 的时候回溯

（2）B+ 树在叶子节点粗出数据，因此**单一查询的时候，很稳定，时间复杂度都是 O(logn)，比起 B 树要略差**

但是叶子节点相邻节点间存在指针相连，因此**适合范围查询**



mongoDB 是 非关系型数据库，常用的是单一查询，因此使用 B 树性能会更好（但后面好像作者又修改为 B+ 树了，可能是权衡了树的高度 + IO 操作次数）
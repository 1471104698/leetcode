# 线程池



## 1、为什么使用线程池？

(关于线程 和 进程，看 进程 和 线程 的基础 中的 6 、总结)



传统的线程使用，都是需要的时候就创建一个线程，执行完任务后，将线程进行销毁

这里面有两个开销：创建线程的开销 和 销毁线程的开销，都是需要 CPU 执行的

当高并发的情况下，大多数的任务都是短时间内可以完成的，这样频繁的执行和销毁只会降低效率，说夸张点，假设一个线程的创建和销毁需要 1s，那么 高并发 情况下 1s 可能有 10W 个请求，那么创建 10W 个线程，到时候创建销毁需要 10W s，这就不得了了

这一方面没有控制线程的数量，10 W 个线程，内存哪里顶得住，一方面是频繁的创建和销毁，CPU 都浪费时间，降低效率



因此，需要线程池来解决

线程池 能够指定线程的数量，因此不会创建太多的线程，同时创建的线程不会用完即毁，而是能够复用

这样就基本解决了上面的两个问题





## 2、线程池的参数

- `corePoolSize`：核心线程数，当已经创建的线程数等于 指定的 `corePoolSize` 时，那么就不会再创建线程了，而是将任务放入到任务队列中，等其他线程执行完毕再来这个任务队列中调用任务继续执行
- `maximumPoolSize`：线程池允许创建的最大线程数，上面说了，线程数到 `corePoolSize` 个数时，就会将任务放到任务队列，当然也不是一直放，任务队列有一个指定大小的，当任务队列满了之后，就会再次创建线程，而这次的最大边界就是这里指定的 `maximumPoolSize`，当线程池中线程数到达这个数量时，之后就不会再创建线程了，除非销毁掉一些旧的线程
- `keepAliveTime`：线程空闲时间，也可以叫空闲存活时间，用来 帮助 getTask()  进行线程管理
- `unit`：时间单位，显然是跟上面那个存活时间共用的
- `workQueue`：任务队列，就是上面说的，没有线程可以调用时任务存放的队列，**都是阻塞队列**
- `threadFactory`：创建线程的工厂，里面只有一个 newThread()，可以指定线程的名字
- `handler`：拒绝策略，当线程池内的线程数达到 max 级别，并且任务队列内的元素已经满了，那么就对于后来的任务就会使用 指定的 拒绝策略，默认情况下是对于新来的任务抛出异常
  - 丢弃 ，抛异常
  - 丢弃，不抛异常
  - 由调用线程池的线程处理任务，比如 main() 线程，不抛异常
  - 丢弃队首任务，将该任务入队，不抛异常





## 3、线程池运行原理



我们需要先知道，线程池的几个主要方法：

- execute()：执行任务，无返回值，在里面会调用 addWorker() 创建线程
- submit()：执行任务，有返回值，会返回一个 Future 类，可以通过 future.get() 获取执行结果，不过会等待阻塞，可以控制等待的时间
- shutdown()：关闭线程池，不会去强制中断正在执行的线程，只是去销毁掉空闲线程，然后等待所有线程执行完毕，才会进入人 SHUTDOWN 状态
- shutdownNow()：顾名思义，立马关闭线程，不论线程是否执行完毕，都强制中断，立马进入 SHUTDOWN 状态



### 1、任务提交流程



当提交一个任务给线程池的时候，线程池执行过程如下：

1、检查线程状态，判断是否是 RUNNING，如果不是，则直接拒绝

2、如果 workCount < corePoolSize，那么创建一个新的线程去执行任务

3、如果 workCount >= corePoolSize，那么放入到 workQueue

4、如果 workCount > corePoolSize 并且 workCount < maximumPoolSize，并且 

workQueue已满，那么创建新的线程去执行任务

5、如果  workCount == maximumPoolSize，并且任务队列已满，那么启动拒绝策略

![img](https://pic1.zhimg.com/80/v2-b06a332965a66469ac512d92ff70e2db_720w.jpg)





### 2、Worker类





```java
private final class Worker
    extends AbstractQueuedSynchronizer
    implements Runnable
{

    //执行线程
    final Thread thread;
    //创建 Worker 时传进来的第一个任务
    Runnable firstTask;

    Worker(Runnable firstTask) {
        this.firstTask = firstTask;
        this.thread = getThreadFactory().newThread(this);
    }

    public void run() {
        runWorker(this);
    }

    protected boolean tryAcquire(int unused) {
        //CAS，尝试获取锁
        if (compareAndSetState(0, 1)) {
            setExclusiveOwnerThread(Thread.currentThread());
            return true;
        }
        return false;
    }

    protected boolean tryRelease(int unused) {
        setExclusiveOwnerThread(null);
        setState(0);
        return true;
    }

    public void lock()        { acquire(1); }
    public boolean tryLock()  { return tryAcquire(1); }
    public void unlock()      { release(1); }
    public boolean isLocked() { return isHeldExclusively(); }
```

Worker 类是 线程池的一个内部类，内部有 thread 和 firstTask 两个变量，其中 firstTask 是在创建 Worker 时通过构造方法传入的，表示当前需要执行的任务，而 thread 是通过 ThreadFactory 直接创建的

里面还有一个 run() ，内部调用了 runWorker() 来执行任务



**Worker 类继承了 AQS，内部定义了 lock() 等方法，跟 ReentrantLock 类似，只是这个 lock() 不是用来防止竞争的，而是当调用 shutdown() 的时候，调用 worker 的 tryLock() 尝试获取锁，以此来判断线程是否处于空闲状态，如果是，那么进行回收**



### 3、execute() 和 addWorker()

```java
public void execute(Runnable command) {
    if (command == null)
        //获取当前线程数 c
        int c = ctl.get();
    //c 小于核心线程数，那么直接调用 addWorker 并且将任务交给它执行
    if (workerCountOf(c) < corePoolSize) {
        if (addWorker(command, true))
            return;
        c = ctl.get();
    }
    /*
    isRunning(c) 判断线程池是否还在执行， workQueue.offer(command) 将任务提交到任务队列中
    这里的意思是如果 线程数小于 corePoolSize，那么直接将任务交给新创建的核心线程执行
    如果大于 corePoolSize，那么将任务放到任务队列中
    如果放入成功，那么就在队列中等待
    如果放入失败，表示任务队列满了，尝试添加一个 Worker，如果超过了 max，那么添加失败，实施拒绝策略，如果添加成功，那么执行
    */
    if (isRunning(c) && workQueue.offer(command)) {
        int wc = ctl.get();
        if (!isRunning(wc) && remove(command))
            reject(command);
        else if (workerCountOf(wc) == 0)
            addWorker(null, false);
    }
    else if (!addWorker(command, false))
        reject(command);
}

private boolean addWorker(Runnable firstTask, boolean core) {
    for (;;) {
        int c = ctl.get();
        int rs = runStateOf(c);
        for (;;) {
            //获取线程数量，如果超过了 max ，那么不能创建新线程
            int wc = workerCountOf(c);
            if (wc >= CAPACITY ||
                wc >= (core ? corePoolSize : maximumPoolSize))
                return false;
            //通过CAS自旋，增加线程数+1，增加成功跳出双层循环，继续往下执行
            if (compareAndIncrementWorkerCount(c))
                break;
        }
    }

    Worker w = null;
    try {
        //创建 Worker，并且调用 t.start() 执行任务
        w = new Worker(firstTask);
        final Thread t = w.thread;
        if (t != null) {
            //到这里开始加锁，只在将新创建的线程添加进 workers 中时加了锁，缩小了锁的粒度
            final ReentrantLock mainLock = this.mainLock;
            mainLock.lock();
            try {
                int rs = runStateOf(ctl.get());
                /*
                workers 是一个 HashSet，添加我们新增的Worker, 它是线程不安全的，因此需要加锁添加
                workers 用于调用 shutdown() 时遍历线程
                */
                workers.add(w);
                int s = workers.size();
                if (s > largestPoolSize)
                    largestPoolSize = s;
                workerAdded = true;
            }
        } finally {
            mainLock.unlock();
        }
        if (workerAdded) {
            //启动Worker
            t.start();
            workerStarted = true;
        }
    }
    return workerStarted;
}
```

当调用 execute() 提交任务的时候，会先判断线程数量 c 是否小于 corePoolSize

如果是，那么直接调用 addWorker() 创建新的 Worker 执行任务

如果不是，那么先将任务放入任务队列排队

如果放入成功，那么就这样不管

如果放入失败，表示队列已满，那么调用 addWorker() 创建新的线程

在第二次调用的  addWorker() 中，会判断线程数量是否已经超过 max，如果超过，那么不创建，直接返回。如果不超过，那么创建新的 Worker 并获取 Worker 中的 thread 调用 run() 执行任务，而 run() 中调用的是 runWorker()

即最终任务的执行是在 runWorker() 中的





### 4、任务执行 runWorker()

```java
final void runWorker(Worker w) {
    Thread wt = Thread.currentThread();
    Runnable task = w.firstTask;
    try {
        while (task != null || (task = getTask()) != null) {
            w.lock();
            try {
                task.run();
            } finally {
                task = null;
                w.unlock();
            }
        }
    } 
}
```

我们可以看出，它会使用一个 while() 循环不断从 getTask() 中获取任务执行

当 task != null，即获取到一个任务的时候，那么就会调用 lock() 加锁，前面也说了，lock() 不是为了防止别的线程进行竞争，而是为了告知线程池现在自己有任务要执行，不是处于空闲状态

当任务执行完毕后，会将 task 置 null，然后释放锁，然后再继续循环调用 getTask() 获取任务



### 5、任务获取 getTask()



```java
private Runnable getTask() {
        boolean timedOut = false; // Did the last poll() time out?
		
    	//循环判断
        for (;;) {
            int c = ctl.get();
            int rs = runStateOf(c);

            // 检查线程池状态，如果线程池是关闭状态 或者 任务队列为空，那么返回 null,表示无任务可做
            if (rs >= SHUTDOWN && (rs >= STOP || workQueue.isEmpty())) {
                decrementWorkerCount();
                return null;
            }
			//获取工作线程数
            int wc = workerCountOf(c);
			
            // 线程数量 wc 超过 corePoolSize 时为 true
            boolean timed = allowCoreThreadTimeOut || wc > corePoolSize;
			//当工作线程数超过 max，或者 (等待时间超时 并且 线程数量 wc 超过 corePoolSize)，那么返回 null
            if ((wc > maximumPoolSize || (timed && timedOut))
                && (wc > 1 || workQueue.isEmpty())) {
                if (compareAndDecrementWorkerCount(c))
                    return null;
                continue;
            }

            try {
                //workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) 是一个阻塞方法
                //表示等待一定时间，如果没有任务，就停止等待
                Runnable r = timed ?
                    //这里的等待超时时间是 创建线程池时传入的 空闲存活时间
                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :
                    workQueue.take();
                if (r != null)
                    return r;
                timedOut = true;
            } catch (InterruptedException retry) {
                timedOut = false;
            }
        }
    }
```



getTask() 的作用是空闲的线程用来获取任务执行的

而它其实还有一个重要作用：减少超过 corePoolSize 之外的线程数量，即控制线程数量



它的执行流程如下：

- 如果线程数量超过 max 或者 (线程数量超过 core 并且 timeout = true)，那么就不再循环获取任务，直接返回 null
- 如果前面没有返回 null，那么调用 任务队列的 poll() ，等待获取任务的时间为 keepAliveTime，如果这段时间获取不到任务，那么设置 timeout = true，并且进入下一轮等待
- 当获取到任务时，直接将任务返回



> ### 保证核心线程不会被销毁的原理

对于 core 数量内的线程来说，在 getTask() 中获取不到任务也会一直循环，这样就导致 core 线程不会处于空闲状态，从而不会被回收

而对于 core 外的线程来说，它会给这些线程一次获取任务的机会，如果在 poll() 等待过程中获取到了任务，那么就返回执行

如果在 keepAliveTime 时间内没有获取任务，表示这段时间用户没有提交任务了，线程资源不需要这么多了，那么就设置 timeout = true。在下一轮中返回 null，即不再获取任务，这样的话，对于 runWorker() 在 while() 中调用了 getTask()，发现返回了 null，那么 while() 也会停止循环，这样的话线程就处于空闲状态，等到达一定的空闲时间，这些线程就会被回收了，就是这样保证了线程池线程的数量



**我们可以看出，keepAliveTime 的作用就是用来 帮助 getTask()  进行线程管理的**





### 6、线程池减少锁的竞争（CAS）

使用一个 AtomicInteger ctl，将线程池的状态 和 当前的线程数量合并到一个 int 变量当中

前 3 位表示线程池的状态，后 29 位表示当前的线程数，这样就使用最少的变量来减少锁的竞争，即无论是线程池状态还是线程的数据在修改的时候都不需要加锁来修改了

```java
    //CAS，无锁并发
    private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
    //表示线程池线程数的数量，Integer.SIZE = 32，而 bitCount = 32 - 3 = 29
    private static final int COUNT_BITS = Integer.SIZE - 3;
    //最大的线程数量，1 << 29 - 1，即 00011111111111111111111111111111
    private static final int CAPACITY   = (1 << COUNT_BITS) - 1;

    // runState is stored in the high-order bits
    //1110 0000 0000 0000 0000 0000 0000 0000（很耿直的我）
    private static final int RUNNING    = -1 << COUNT_BITS;
    //0000 0000 0000 0000 0000 0000 0000 0000（很耿直的我）
    private static final int SHUTDOWN   =  0 << COUNT_BITS;
    //0010 0000 0000 0000 0000 0000 0000 0000（很耿直的我）
    private static final int STOP       =  1 << COUNT_BITS;
    //0100 0000 0000 0000 0000 0000 0000 0000（很耿直的我）
    private static final int TIDYING    =  2 << COUNT_BITS;
    //0110 0000 0000 0000 0000 0000 0000 0000（很耿直的我）
    private static final int TERMINATED =  3 << COUNT_BITS;

    // Packing and unpacking ctl
    //获取线程池的状态，c & 111000000...
    private static int runStateOf(int c)     { return c & ~CAPACITY; }
    //获取线程的数量，c & 0001111...
    private static int workerCountOf(int c)  { return c & CAPACITY; }
    //组装状态和数量，成为ctl
    private static int ctlOf(int rs, int wc) { return rs | wc; }
```





### 7、线程池 shutdown() 和 shutdownNow()



> ### shutdown()

shutdown() 是先回收空闲线程，然后等正在执行的其他线程执行完毕后才进行回收

关于空闲线程的判断，就是利用 线程在执行任务前调用的 lock()，线程池通过调用 tryLock() 尝试获取锁判断线程的执行状态

```java
private void interruptIdleWorkers(boolean onlyOne) {
        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock();
        try {
            for (Worker w : workers) {
                Thread t = w.thread;
                //调用 tryLock() 尝试获取锁，获取成功表示线程处于空闲状态
                if (!t.isInterrupted() && w.tryLock()) {
                    try {
                        t.interrupt();
                    } catch (SecurityException ignore) {
                    } finally {
                        w.unlock();
                    }
                }
                if (onlyOne)
                    break;
            }
        } finally {
            mainLock.unlock();
        }
    }
```





> ### shutdownNow()

该方法调用后会直接中断所有在执行的线程，然后进行回收





## 4、线程池的工作队列



线程池中所有的队列都是阻塞队列，都实现了 BlockingQueue 接口

具体实现有：

- ArrayBlockingQueue：基于循环数组的阻塞队列，有边界
- LinkedBlockingQueue：基于单链表的阻塞队列，有边界
- SynchronousQueue：同步队列，没有存储空间，当向线程池提交一个任务的时候，如果线程池没有空闲线程，那么重新开一个线程来允许该任务。
- PriorityBlockingQueue：基于元素优先级排序的阻塞队列，无边界

```java
public interface BlockingQueue<E> extends Queue<E> {
    // 尝试往队列尾部添加元素，添加成功则返回true，添加失败则抛出IllegalStateException异常
    boolean add(E e);

    // 尝试往队列尾部添加元素，添加成功则返回true，添加失败则返回false
    boolean offer(E e);

    // 尝试往队列尾部添加元素，如果队列满了，则阻塞当前线程，直到其能够添加成功为止
    void put(E e) throws InterruptedException;

    // 尝试往队列尾部添加元素，如果队列满了，则最多等待指定时间，
    // 如果在等待过程中还是未添加成功，则返回false，如果在等待
    // 过程中被中断，则抛出InterruptedException异常
    boolean offer(E e, long timeout, TimeUnit unit) throws InterruptedException;

    // 尝试从队列头部取出元素，如果队列为空，则一直等待队列中有元素
    E take() throws InterruptedException;

    // 尝试从队列头部拉取元素，如果队列为空，则最多等待指定时间，
    // 如果等待过程中拉取到了新元素，则返回该元素，
    // 如果等待过程被中断，则抛出InterruptedException异常
    E poll(long timeout, TimeUnit unit) throws InterruptedException;

    // 获取当前队列剩余可存储元素的数量
    int remainingCapacity();

    // 从队列中移除指定对象
    boolean remove(Object o);

    // 判断队列中是否存在指定对象
    boolean contains(Object o);

    // 将队列中的元素转移到指定的集合中
    int drainTo(Collection<? super E> c);

    // 从队列中最多转移maxElements个元素到指定集合中
    int drainTo(Collection<? super E> c, int maxElements);
}
```





### 1、ArrayBlockingQueue 实现原理

基于 数组实现的阻塞队列，跟 lc 用数组实现的队列一样，使用两个指针，循环写和读

不过不同的是，当队列 为空或者满 的时候，两个指针都重合，而 lc 是预留一个位置的，因此这里还需要一个 count 变量来记录元素个数以此来判断是否为空

阻塞 则是通过 ReentrantLock + Condition 的生产者消费者模式 实现的

```java
public class ArrayBlockingQueue<E> extends AbstractQueue<E> implements BlockingQueue<E> {
    //存储数据的 数组
    final Object[] items;
    //两个指针
    int takeIndex;
    int putIndex;
    //记录元素个数
    int count;
    //阻塞实现
    final ReentrantLock lock;
    //消费者线程，notEmpty 表示现在数据非空，可以进行消费
    private final Condition notEmpty;
    //生产者线程，notFull 表示现在数据未满，可以进行生产
    private final Condition notFull;


    //入队主逻辑
    private void enqueue(E x) {
        final Object[] items = this.items;
        items[putIndex] = x;
        if (++putIndex == items.length)
            putIndex = 0;
        count++;
        //生产了一个，可以唤醒消费者线程进行消费，即唤醒要获取任务的线程
        notEmpty.signal();
    }
    //出队主逻辑
    private E dequeue() {
        final Object[] items = this.items;
        @SuppressWarnings("unchecked")
        E x = (E) items[takeIndex];
        items[takeIndex] = null;
        if (++takeIndex == items.length)
            takeIndex = 0;
        count--;
        if (itrs != null)
            itrs.elementDequeued();
        //出队了一个，可以唤醒生产者线程进行生产，即唤醒要插入任务的线程
        notFull.signal();
        return x;
    }
	
    //对外开放插入任务的接口
    public void put(E e) throws InterruptedException {
        checkNotNull(e);
        final ReentrantLock lock = this.lock;
        lock.lockInterruptibly();
        try {
            //如果队列已满，那么当前线程进入等待状态
            while (count == items.length)
                notFull.await();
            enqueue(e);
        } finally {
            lock.unlock();
        }
    }
	//对外开放获取任务的接口
    public E poll(long timeout, TimeUnit unit) throws InterruptedException {
        long nanos = unit.toNanos(timeout);
        final ReentrantLock lock = this.lock;
        lock.lockInterruptibly();
        try {
            //队列为空，那么当前线程等待指定时间
            while (count == 0) {
                if (nanos <= 0)
                    return null;
                nanos = notEmpty.awaitNanos(nanos);
            }
            return dequeue();
        } finally {
            lock.unlock();
        }
    }
```



### 2、LinkedBlockingQueue 实现原理

使用一个单链表，有 head 和 tail 两个 dummy 节点，用于 队头和队尾的 插入 和 删除

使用两个 ReentrantLock，一个用于队头，一个用于队尾

当需要获取任务的时候，在队头加锁，然后获取任务

当需要插入任务的时候，在队尾加锁，然后插入任务



这意味着队头和队尾能够并发执行，吞吐量量高

```java
public class LinkedBlockingQueue<E> extends AbstractQueue<E> implements BlockingQueue<E> {
    //存储容量
    private int capacity;
    //元素个数，使用原子类保证线程安全
    private AtomicInteger count = new AtomicInteger();
    //链表头节点
    private Node<E> head;
    //链表尾节点
    private Node<E> last;

    //第一个 ReentrantLock，用于锁住链表头节点
    private ReentrantLock takeLock = new ReentrantLock();
    //消费者线程
    private Condition notEmpty = takeLock.newCondition();
    //第二个 ReentrantLock，用于锁住链表尾节点
    private ReentrantLock putLock = new ReentrantLock();
    //生产者线程
    private Condition notFull = putLock.newCondition();

    //单链表节点
    static class Node<E> {
        E item;	//数据
        Node<E> next;
        Node(E x) { item = x; }
    }

    public void put(E e) throws InterruptedException {
        if (e == null) throw new NullPointerException();
        int c = -1;
        Node<E> node = new Node<E>(e);
        //获取队头锁
        final ReentrantLock putLock = this.putLock;
        final AtomicInteger count = this.count;
        putLock.lockInterruptibly();
        try {
            //如果队列已满，那么进入等待状态
            while (count.get() == capacity) {
                notFull.await();
            }
            //入队
            enqueue(node);
            //元素个数 +1
            c = count.getAndIncrement();
            //当队列未满时，其他线程插入任务
            if (c + 1 < capacity)
                notFull.signal();
        } finally {
            //释放锁
            putLock.unlock();
        }
        //唤醒获取任务的线程
        signalNotEmpty();
    }

    public E poll(long timeout, TimeUnit unit) throws InterruptedException {
        E x = null;
        int c = -1;
        long nanos = unit.toNanos(timeout);
        final AtomicInteger count = this.count;
        final ReentrantLock takeLock = this.takeLock;
        takeLock.lockInterruptibly();
        try {
            while (count.get() == 0) {
                if (nanos <= 0)
                    return null;
                nanos = notEmpty.awaitNanos(nanos);
            }
            x = dequeue();
            c = count.getAndDecrement();
            if (c > 1)
                notEmpty.signal();
        } finally {
            takeLock.unlock();
        }
        //唤醒插入任务的线程
        signalNotFull();
        return x;
    }
```



注意，newFixedThreadPool() 使用的就是 LinkedBlockingQueue，但是它的默认容量为 Integer.MAX_VALUE

因此相当于无界队列，因此使用的时候注意自己指定 max 大小



> ### ArrayBlockingQueue 和 LinkedBlockingQueue  的区别

- ArrayBlockingQueue 底层是一个循环数组，LinkedBlockingQueue  底层是一个单链表

-  ArrayBlockingQueue 只使用了一个 ReentrantLock，插入和删除同步执行，一次只能操作一个线程，而 LinkedBlockingQueue  使用了两个 ReentrantLock，锁住头和锁住尾，插入和删除可以并发执行
- 由于 ArrayBlockingQueue 插入和删除是同步的，所以 int count 已经保证了原子性，而 LinkedBlockingQueue  存在并发，因此 需要使用一个 AtomicInteger 来保证元素个数的原子性
- ArrayBlockingQueue 不使用两个锁（跟 ConcurrentHashMap 那样锁住槽位）的原因是 按照作者的意思就是 设计简洁，如果想要高吞吐量就使用 LinkedBlockingQueue

具体看： <https://blog.csdn.net/qq_27007251/article/details/75207050>



### 3、SynchronousQueue 实现原理

具体看 <https://www.jianshu.com/p/af6f83c78506>



这个不具体讲了，有点难

SynchronousQueue 没有 AQS，而是使用大量的 CAS

它不存在任何的容量，而是使用阻塞线程的方式

当 插入任务的线程来时，如果没有线程等待获取任务，那么进入到链表中等待匹配

当获取任务的线程来时，如果没有线程等待插入任务，那么进入到链表中等待匹配

即线程无论是获取任务还是插入任务，如果没有相应的线程与之匹配，那么就会封装成一个节点进入对应的链表中等待匹配的线程

```java
public class SynchronousQueue<E> extends AbstractQueue<E>
    implements BlockingQueue<E>, java.io.Serializable
    
     public SynchronousQueue() {
        this(false);
    }
    /*
    抽象类，只有一个 transfer()，用来转移数据
    如果 e == null，表示是获取数据，如果 e != null，表示是插入数据
    它有两种实现，一个是 TransferStack，一个是 TransferQueue
    TransferStack 是用来实现非公平的，即如果不遵循先来后到准则，每次匹配都弹出栈顶
	TransferQueue 是用来实现公平的，每次匹配都是从队头开始匹配
    */
    abstract static class Transferer<E> {
        abstract E transfer(E e, boolean timed, long nanos);
    }
    public SynchronousQueue(boolean fair) {
        // 通过 fair 值来决定公平性和非公平性
        // 公平性使用TransferQueue，非公平性采用TransferStack
        transferer = fair ? new TransferQueue<E>() : new TransferStack<E>();
    }
```



在线程池中是 newCachedThreadPool() 使用的，它默认是没有边界的，只要有提交任务，如果没有空闲线程，那么创建一个新的线程去执行任务，默认 max = Integer.MAX_VALUE

**如果大量创建线程，会导致cpu和内存飙升，甚至服务器挂掉。**



### 4、PriorityBlockingQueue 实现原理

这个也不讲了，有点难
2.
现有n个房子排成一排，需要刷漆，分别有红绿蓝三种漆色，要求每个房子与相邻的房子不能刷相同的颜色
对于第i个房子，刷三种颜色中的其中一种，如果刷成红色/绿色/蓝色，那么需要刷漆量 r[i]/g[i]/b[i]
求满足条件 n 个房子相邻不同颜色的最少刷漆量。
例如：
100 77 73
41 74 83
9 91 93
50 16 31
输入：n = 4, r = [100,41,9,50], g = [77,74,91,16], b = [73,83,93,31]
输出：172

    /*
    动态规划：
    每个房子都有 3 种选择：当前房子选择红色，那么上一个房子只能选择蓝色或绿色，求得最少的刷漆量。
    选择红色
    dp[i][0] = Math.min(dp[i - 1][1], dp[i - 1][2]) + r[i]
    选择绿色
    dp[i][1] = Math.min(dp[i - 1][0], dp[i - 1][2]) + g[i]
    选择红色
    dp[i][2] = Math.min(dp[i - 1][0], dp[i - 1][1]) + b[i]
     */
    private int te(int n, int[] r, int[] g, int[] b) {
        int[][] dp = new int[n + 1][3];
        for(int i = 1; i <= n; i++){
            // 选择红色
            dp[i][0] = Math.min(dp[i - 1][1], dp[i - 1][2]) + r[i - 1];
            // 选择绿色
            dp[i][1] = Math.min(dp[i - 1][0], dp[i - 1][2]) + g[i - 1];
            // 选择红色
            dp[i][2] = Math.min(dp[i - 1][0], dp[i - 1][1]) + b[i - 1];
        }
        return Math.min(Math.min(dp[n][0], dp[n][1]), dp[n][2]);
    }
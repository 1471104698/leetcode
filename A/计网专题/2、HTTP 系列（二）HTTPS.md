# HTTPS



具体信息看  https://zhuanlan.zhihu.com/p/36981565 

## 1、什么是 HTTPS

由于 HTTP 是数据传输都是明文传输，所以可能在传输过程中会被劫持，然后信息被篡改，这样接收方收到的就是被篡改后的信息，极其不安全

HTTPS 就是用来解决信息安全问题的

**HTTPS 是在应用层 和 传输层 中间加了一层 SSL/TLS (安全协议) 来保证信息的安全性**

 ![img](https://pic1.zhimg.com/80/v2-5f4b161e47f7c1a1cd8c2b8081914753_720w.jpg) 



SSL/TLS 协议使用了两种加密算法：对称加密 和 非对称加密，以及 数字证书 CA



## 2、SSL 前置知识点

### 1、对称加密算法

A 和 B 进行通信，为了防止中间人 C 进行窃听和篡改，使用了加密的方式

A 和 B 会对自己的信息进行加密，A 和 B 之间共享一个密钥 X

A 在发送信息前，使用这个 密钥 X 对信息进行加密，然后发送给 B，B 收到后，使用这个 密钥 X 对信息进行解密

这个叫做对称加密算法



而 A 和 B 共享一个密钥 X，它们必须经过交流才能知道共享的密钥 X 是什么，而如果直接在网络上传输的话，那么还是可能会被 中间人 C 窃取到这个 密钥 X，这样就失去了加密的意义了，因此一个解决方法就是在私底下见一面，商量好密钥



虽然如此，但还是存在问题，网络通信越来越发达，A 可能不只跟 B 进行通信，它还需要跟 1W 个人进行通信，这样的话为了保证加密的安全就需要私底下都跟这 1W 个人见面，这显然是不现实的，为了交流可能都跨国交流，这还不如不交流

因此，一个新的加密算法被提出来了：非对称加密



### 2、非对称加密算法

​		注：非对称加密主流算法为 RSA 算法

非对称加密算法 有两个密钥，一个是 public key（公钥），一个是 private key（私钥）

通过一个特殊的数学算法，生成公钥和私钥，使用公钥加密的数据，只能使用私钥来解密，使用私钥加密的数据，只能使用公钥来解密，正是因为这个特性，所以称为非对称加密



使用了非对称加密，A 生成 public key 和 private key，这样 A 自己可以保留 private key，而可以在网络上传输 public key，这样即使 public key 被 中间人 C 劫持了，C 没有 private key 也无法解密数据，保证了安全性

因此 A 和 B 不用再私底下见面商量密钥了，直接网络传递 public key 即可



具体的加密传输过程如下：

- A 和 B 各自都有 一对 public key 和 private key，A 和 B 各自保留自己的 private key，将 public key 传输给对方
- 当 A 要给 B 发送信息的时候，使用自己的 private key 对 数据的 hash 值 进行加密，然后将数据使用 B 的 public key 进行加密，然后将 加密的 hash 值 和 加密的数据一起发送给 B
- B 收到之后，使用自己的 private key 进行解密，然后对解密后的数据进行 hash 运算算出一个 hash 值，再使用 A 的 public key 对 加密的 hash 进行解密，然后比对两个 hash 值，如果一致，表示数据完整

 ![img](https://pic2.zhimg.com/80/v2-9db43298e5c55d26fd40367ba32f40ed_720w.jpg) 



这样看来，即使 C 劫持了数据，但是没有 B 的 private key，所以无法获取加密后的数据，看起来挺美好的

但是，如果在最开始 A 和 B 交换 public key 的时候，中间人 C 就拦截了呢？假设 C 拦截了 A 和 B 的 public key，然后将自己的 public key 发送给 A 和 B，这样 A 就是使用的 C 的 public key 加密数据，那么 C 拦截信息后可以使用自己的 private key 解密数据，这样就能获取到 A 发送的原始数据了，同时，篡改完这个原始数据，使用自己的 private key 加密数据的 hash 值，再使用 B 的 public key 加密数据，发送给 B，而 B 会使用 C 的 public key 获取解密后的 hash 值，比对后发现一致！！！这样的话就意味着 B 收到了一条 C 的假消息，但是 B 并不知情，那么后续的通信都在 C 的掌握之中

这样的话，A 和 B 还是只能在私底下见一面，这样就回到最开始的问题了

因此我们需要一种新的方法，能够在传输的过程中保证 A 和 B public  key 的真实性，因此出现了 数字证书



### 3、CA 证书 - 数字证书

具体内容看： https://segmentfault.com/q/1010000020917744 

 https://blog.csdn.net/u011779724/article/details/80776776 



数字证书是 CA 机构给服务端颁发的，数字证书 是基于非对称加密算法来实现的

数字证书整体部分包含三个内容：证书内容，散列算法，数字签名

证书内容:

- **服务器自己生成的公钥（主要）**
- 域名信息
- 域名持有者
- 证书到期时间 



在此之前，我们需要搞清楚一些知识点：

- CA 机构有自己的 公钥 和 私钥，CA 的公钥是 内置在 操作系统中的，即用户买来电脑就已经有了的，因为 CA 机构就固定那几个
- 服务器向 CA 买证书的时候，会自己生成一个 公钥 和 私钥，并向 CA 机构提供自己的 公钥

总的来说，**整个过程涉及到 两对 非对称密钥，一对是 CA 机构自己的，一对是 服务器自己生成的**



CA 证书生成 流程：

- CA 机构使用 一个散列算法 对服务器提交上来的 公钥、域名信息、域名持有者 之类的信息 进行 hash 生成 签名
- CA 机构再使用 自己的 CA 私钥对 签名 进行加密
- 将 服务器的信息 + 散列算法 + 加密后的签名 做成一份 CA 证书，发送给 服务器



这种的话，黑客即使拦截了数字证书，使用它自己内置的 CA 公钥进行解密，数据修改完后，由于没有 CA 私钥，因此无法加密，就算使用自己的 private key 进行加密，在客户端也无法使用 CA 公钥解密，因此保证了真实性和安全性



**这个 CA 证书实际上就是用来解决 对称加密 在网络中传输 共享密钥 不安全的问题，通过 CA 证书的安全性来交流 共享密钥**



## 3、SSL 握手过程

 ![img](https://img-blog.csdn.net/20180622174627696?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE3Nzk3MjQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 

这里假设 服务器 已经买了 CA 证书，A 是服务器，B 是客户端

- B 发送给 A 自己支持的 SSL 版本、 hash 算法列表，还有一个随机数 C（第一个）
- A 收到后，发送自己的 CA 证书、选定的 hash 算法，还有一个随机数 S（第二个）
- B 收到后，使用 CA 公钥解密 数字签名，然后使用散列算法对 证书内容进行 hash，比对生成的和解密出来的 hash 值，然后有以下几步：
  - 生成一个随机数 Pre-master（第三个）
  - 根据 选定的 hash 算法使用三个随机数生成一个 对称加密密钥 key
  - 使用 key 加密一段信息 - 握手信息
  - 使用 A 的公钥加密 Pre-master 和 握手信息，发送给 A
- A 收到后，使用自己的私钥解密，获取 Pre-master 和 加密的握手信息，然后有以下几步：
  - 根据选定的 hash 算法 使用三个随机数生成一个对称加密密钥 key（跟客户端生成的是一样的内容）
  - 使用 key 解密 握手信息，以此来验证 对称密钥 key 的正确性
  - 然后根据握手信息生成一段数据，再使用 key 加密，发送给 B
- B 收到后，使用 key 解密成功，验证了 A 和 自己的 对称密钥是一样的，那么验证完毕，开始数据传输



通过假如 3 个 随机数来保证 共享密钥的随机性，避免被第三方随意猜到

但是 前两个随机数是明文传输的，最后一个是 加密传输的

这样的话，前两个随机数是可能被别人拦截篡改的，这也没办法了，最多共享密钥对不上，通信失败，后续继续请求，只要消息不被窃取就行了





## 4、HTTP 和 HTTPS 的区别

HTTPS 是在 HTTP 明文传输的基础上添加一层 SSL/TLS 来对数据进行加密，保证信息的真实性和安全性

而添加了这么一层协议，同样会存在缺点：

- 服务器和客户端多次协商，增加了通信次数
- SSL 进行加密处理，在服务端和客户端都需要进行加密和解密的运算，耗费 CPU 资源
- 需要向 CA 机构购买 数字证书，也需要一大笔钱



## 5、HTTPS 加密后的信息

以下是 HTTPS 连接完成后的 TCP 传输信息，基本都是乱码，都看不到了，加密了

就连 URL 什么的都被加密了

*![image.png](https://pic.leetcode-cn.com/1603262692-LXctxP-image.png)*
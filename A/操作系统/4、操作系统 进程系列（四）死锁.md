# 死锁

## 1、死锁产生的四个必要条件

死锁可以简单概括为几句话：

- 资源互斥
- 当前线程持有其他线程等待的资源
- 当前线程等待其他线程持有的资源
- 在没有执行到释放锁的逻辑的时候不会主动释放资源
- 请求和持有的流图 构成一个环路

官方点讲，四个必要条件就是

- 互斥条件：一个资源一次只能被一个 进程/线程 占有
- 永久保持：线程在遇到阻塞的时候不会去释放自己的资源，这样无限阻塞就一直不释放
- 不剥夺：线程在没有执行到释放锁的逻辑的时候是不会主动释放锁的
- 环路等待：多个线程间请求的资源和持有的资源形成一个环路，即死循环 



## 2、预防死锁 - 三个方法：

这里讲下预防死锁 和 避免死锁 的区别：

- 预防死锁表示破坏四个条件中的一个
- 避免死锁是防止进程进入资源分配的不安全状态（银行家算法）



预防死锁的三个方法：

- 统一获取锁的顺序（破坏环路等待）
- 在获取另一个锁的前如果持有一个锁，如果持有的锁是不需要的，那么在获取另一个锁前释放掉（破坏环路等待）
- 限时阻塞获取锁：tryLock()（对应破坏永久保持）



## 3、打破已经死锁的方法：

[打破死锁]( https://baijiahao.baidu.com/s?id=1598504585446895117&wfr=spider&for=pc )

- 重启系统：最简单，但是代价最大，因为在之前的进程的所有运行过程都付之东流了
- 撤销进程，剥夺资源：终止参与死锁的进程，收回它们的资源，从而解除死锁
  - 一次性全部撤销所有的进程，不过一般不会这么做
  - 一个个撤销进程，先将代价最小的进程撤销，一般是按照优先级来撤销
- 进程回退：将参与死锁的进程回退到尚未死锁的那个时间点，不过系统开销大，因为需要记录进程的每一个时间点的变化，以便后续回退，回退的话一般是将优先级低的先回退



## 4、死锁检测 (排查)

使用 jps 获取运行的进程

通过 jstack 获取对应进程的线程运行信息，判断是否发生死锁



## 5、避免死锁 - 银行家算法

有多个进程，并且存在多个资源，每个进程请求的资源数是不同的

那么我们需要经过计算，生成一个安全分配的序列，提前知道如何进行资源分配，才会保证不会产生死锁

- 安全序列可以存在多个，并且一定不会产生死锁

- 不安全序列同样存在多个，并不是一定会产生死锁，但产生死锁的必定是不安全序列

银行家算法就是用来找到安全序列的

当一个进程去申请资源的时候，银行家算法会进行模拟，假设分配给了该进程资源，判断 是否能够使得该进程完成 或者 剩下的资源是否能够满足后续的进程完成，如果可以，那么就是安全序列，不会产生死锁，如果不可以，那么表示是不安全序列，可能产生死锁，不能分配给该进程



> ### 例子讲解

存在 P0 P1 P2 P3 P4 这五个进程，以及 4 种资源

Allocation 表示对应进程已经分配到的各个资源的数量

比如 P0 的 0 0 3 2 表示第一、二个资源分配到了 0 个，第三 个资源分配到了 3 个，第四个资源分配了 2 个



Need 表示对应进程在分配了的资源的基础上还需要的各个资源的数量

Available 表示如今资源库中各个资源剩下的可分配的数量



![img](https://img-blog.csdn.net/20180508210408944)



假设 P0 申请 (0,0,1,2) 个资源，银行家算法会进行模拟，过程如下：

- 给 P0 分配 (0,0,1,2) 个资源，那么剩下的可用资源为 (1,6,1,0)，但是 P0 已经拥有了需要的全部资源，因此它可以执行完毕，将所占有的资源全部归还，那么可用资源就变成了 (1,6,5,4)
- 后续看其他的进程，这时候可以先给 P3 分配 (0,6,5,2)，让 P3 完成任务，归还资源，可用资源就变成了 (1,9,8,6)
- 再给 P4 分配 (0,6,5,6)，让 P4 完成任务，归还资源，可用资源就变成了 (1,9,9,10)
- 再给 P1 分配 (1,7,5,0)，让 P1 完成任务，归还资源，可用资源就变成了 (2,9,9,10)
- 再给 P2 分配 (2,3,5,6)，让 P2 完成任务，归还资源
- 所有进程都完成任务，完美达成

**因此，可以给 P0 分配资源，安全序列为 P0 - P3 - P4 - P1 - P2，这样不会产生死锁**



假设 P2 申请 (1,2,2,2) 个资源，银行家算法模拟过程如下：

- 给 P2 分配 (1,2,2,2) 个资源，那么剩下的可用资源为 (0,4,0,0)
- P2 还需要资源，但是可用资源不足以供给，所以 P2 无法完成任务，归还资源，而可用资源同时无法给其他进程分配所需资源，使得它们完成任务
- 这样，就陷入了死锁，因为所有进程都无法完成任务，这样就一直都不会归还资源，使得每个进程都陷入等待状态

**因此，不能给 P2 分配资源**


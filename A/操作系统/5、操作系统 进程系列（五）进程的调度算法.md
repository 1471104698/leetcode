# 进程的调度算法

## 1、先来先服务算法（FCFS，短的会等长的）

**先来先执行，长的先到的话那么短的也需要等长的执行完，平均等待时间长**

比如任务 A 需要 10s，任务 B 需要 1min，任务 B 先到达，这样 任务 A 需要等待 任务 B 执行完成

这样平均等待时间为（0 + 1min) / 2 = 30s，但如果让任务 A 先执行，那么平均等待时间为（10 + 0）/ 2 = 5s

 ![img](https://pic3.zhimg.com/80/v2-7a0a41db8d07c20ada29e37c15e412e6_720w.jpg) 







## 2、时间片轮转算法

**一个任务固定一个时间片轮转调度，较为公平**



**时间片轮转调度算法是在 FCFS 算法上的改进，维护一个 FIFO 队列，先到的进程先调度**

不过跟 FCFS 不同的是，它不会一直等到长任务执行完成，而是为调度的进程分配一个时间片

如果任务在一个时间片内完成了，那么出队，如果任务提前完成任务，那么提前出队，不需要等到时间片用完

如果任务还没完成，那么进入到队尾继续排队

当然，如果一个任务完成不需要一整个时间片，那么也会提前结束的

 ![img](https://pic2.zhimg.com/80/v2-05b95be53f47428ca6f5f8ab0b313b49_720w.jpg) 



该调度算法能够某种程度上做到公平，不会造成饥饿，Linux 中使用的就是时间片轮转（好像后面改成了 CFS 调度算法）

缺点 就是 如果队列中有 100 个任务，末尾的任务只需要 1s 就能够完成任务，但是它也需要按照顺序等待前面的 99 个任务完成，对于短作业来说 平均等待时间太长（即类似于我们平常窗口排队，有的人说能够很快完成，但是由于来得慢了，所以需要在后面慢慢排队，即使前面的人需要很久才能完成）

因此有的操作系统 要优先处理 短作业，就出现了短作业优先调度算法



## 3、短作业优先（长的会等短的，长任务会饥饿）

**不管先来后到，短作业会优先执行，如果短作业多，那么长作业会饥饿**



**按照任务完成时长的长短进行排序**，短的优先执行，这个任务的特点是**需要提前知道所有任务的耗时才能进行排序**，这里的时间长短是完成任务还需要的时间来算的，比如现在在执行一个 1 小时的任务，还剩 10s，而这时**来了一个 1min 的任务，它还是会继续执行 1 小时的任务，因为它只需要 10s 就能完成**

 ![img](https://pic2.zhimg.com/80/v2-aade0ab1b10cbdbc5722e7964fee9a29_720w.jpg) 



适用场景：几乎无适用场景



## 4、多级反馈队列

兼顾了响应时间、调度开销低、避免饥饿问题、公平，在 windows、Linux 中都有使用



分为多个 level，每个 level 对应一个队列，从上到下优先级由高到低，时间片越来越长

位于高优先级的任务可以抢占低优先级的任务

最开始新任务位于最高位置的 队列，分配给它一个时间片，如果在这个时间片内完成任务，那么直接出队，如果没有完成任务，那么**进入到下一个 level 的队列中，且分配的时间片比上一级的长一倍**

只有当第 1 级的队列为空时，才会调度第 2 级的队列。。。

**对于长任务来说，一下子解决不了，需要等待的时间变长，但是后续分配的时间片也变长了**

![img](https://pic4.zhimg.com/80/v2-8a100f3d3e2ba0d97b164b685b5ed394_720w.jpg)







## 5、CFS （完全公平调度算法，Linux 正在使用的调度算法）

[CFS 调度算法讲解](https://www.cnblogs.com/tianguiyu/articles/6091378.html)



CFS 定义了一种新的模型，它给每个进程 安排一个 虚拟运行时间 vruntime，如果一个进程得以执行，那么它的 vruntime 会随着时间的增长而增长，而没有得到调度的进程的 vruntime 不变

**调度器总是会选择 vruntime 最小的进程进行调度（所谓的完全公平）**

同时**为了兼顾高优先级的进程的优先执行，所以会设置高优先级的进程的 vruntime 增长速率 比 其他进程要慢，让高优先级的进程得到更多的调度机会**



**调度周期：**将所有进程都调度一遍所需要的时间

**实际分配给进程的运行时间：**

```java
分配给进程的时间片 = 调度周期 * 进程权重 / 所有进程权重之和
```

比如操作系统设置的调度周期为 30ms，即要在 30ms 内都将进程调度一遍，进程 A 的权重为 1，进程 B 的权重为 2

那么在一个调度周期中，进程 A 分配到的时间片为：30ms * 1 / 3 = 10ms，程 B 分配到的时间片为：30ms * 2 / 3 = 20ms

即是按照权重比来分配时间片的，进程 A 权重：进程 B 权重 = 1：2，所以时间片的分配 = 1：2 = 10ms：20ms



**vruntime 的计算公式：**

```java
vruntime = 实际运行时间 * 1024 / 进程权重 //这里是 1024 是基准值，目前不需要管它
```

**实际运行时间 理想状态下就是一个调度周期内应该分配给进程的时间片**（注解 ①），利用上面的讲解的公式进行换算，得到

```java
vruntime = (调度周期 * 进程权重 / 所有进程权重之和) * 1024 / 进程权重 
		 = 调度周期 * 1024 / 所有进程权重
```

可以看出，vruntime 的计算实际上跟某个进程所占的权重无关，即**所有进程的 vruntime 的增长速率是一致的**，所谓的完全公平

那么就可以通过这个 vruntime 来选择调度的进程，vruntime 小的，表示它受到了 “不公平” 的对待，需要让 CPU 去调度它



**为什么进程分配的时间片不同但最终得到的 vruntime 增长速率相同？**

因为 vruntime 是根据调度周期 和 所有进程的权重之和来计算的，从这个层面来说所有的进程的 vruntime 增长速率相同

在上面 换算实际运行时间的时候，注解① ，我标明了 实际运行时间 理想状态下是 一个调度周期内应该分配给进程的时间片

即我们是在确保了调度周期内该进程得到了它应得的时间片，因为只有得到了，才是 进程的实际运行时间，然后才会得出 vruntime 的值，我们得出的 vruntime 相同的 **前提** 是所有的进程都得到了**应得**的时间片

因此，如果进程没有得到它应该得到的时间片，那么它计算得到的 vruntime 的值就会比已经得到应得的时间片的值要小，那么后面 CPU 就会去调度它



**CFS 和 时间片轮转的区别 -- 例子：**

这种类似 按照每个人的体重（进程权重）分蛋糕（CPU 时间片），体重大的食量大，体重小的食量小，如果每个人分相同份量的蛋糕（时间片轮转），虽然简单看来是公平的，但是实际上对 体重大 的来说是不公平的，因为体重小的能够有更高的饱腹感和满足感，而体重大的没有体会到体重小的所到达的饱腹感和满足感，所以应该给 体重大的分配多一些蛋糕（vruntime），达到真正意义上的 公平，即**最终不是遵循资源分配的公平，而是遵循资源需求的公平**





Linux 实现 CFS 的底层数据结构是一棵 **红黑树**，以 vruntime 作为 key，红黑树 是相对平衡的排序二叉树

所以会根据 vruntime 进行升序排序，所以**每次 CPU 调度只需要 O(logn )获取最左边的节点进行调度**

调度后将节点从红黑树中移除，等到调度完成再重新计算进程的 vruntime，插入到红黑树中

 ![img](https://pic4.zhimg.com/80/v2-d5580bfcf145ba594295e22525e09933_720w.jpg)

# [452. 用最少数量的箭引爆气球](https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/)

<img src="https://pic.leetcode-cn.com/bcfce68539b3e22a7aed3370b6faacac3a9e5c6adbcf57a8797a41d118c8a04d-image.png" style="zoom:150%;" />





## **示例：**

```java
输入:
[[10,16], [2,8], [1,6], [7,12]]

输出:
2

解释:
对于该样例，我们可以在x = 6（射爆[2,8],[1,6]两个气球）和 x = 11（射爆另外两个气球）。
```





## 错误方法



### 错误思路

```java
最开始想法是直接使用 56. 合并区间 这一思路，直接将区间进行合并，然后看存在多少个不重叠区间
比如 [1,6] [2,8] [7,12] [10,16]，可合并为一个重叠区间：[1, 16]，那么只使用一只箭即可
```



### 错误代码

```java
class Solution {
    public int findMinArrowShots(int[][] points) {
        /*
            区间合并，看存在多少个不重叠区间
        */
        List<int[]> lists = new ArrayList<>();
        Arrays.sort(points, (a, b) -> a[0] == b[0] ? b[1] - a[1] : a[0] - b[0]);
        int[] pre = null;
        for(int[] p : points){
            //不重叠区间
            if(pre == null || pre[1] < p[0]){
                pre = p;
                lists.add(pre);
            }else{
                //重叠区间：[1,100] 和 [1, 10] [1, 100] 和 [2, 101]
                //此时 pre 已经在 lists 中了，这里更新 lists 里同样会更新
                pre[1] = Math.max(pre[1], p[1]);
            }
        }
        return lists.size();
    }
}
```



## 正确方法



### 实现思路

```java
上述思路错误的主要原因是：区间重叠但不一定只使用一只箭
比如 [1,3] [2,8] [7,12]
它们区间重叠了，但是 
[1, 3] 和 [2, 8] 重叠部分为 [2, 3]，只能在 [2, 3] 范围内使用一只箭才能爆掉这两个
[2, 8] 和 [7,12] 重叠部分为 [7, 8]，只能在 [7, 8] 范围内使用一只箭才能爆掉这两个
能用一只箭的前提条件是几个区间都存在共同的一个重叠区间，而这里由于三个区间不存在共同重叠区间，因此，只能使用两只箭

我们可以记录 上两个区间的重叠区间，然后判断下一个区间与这个区间存在重叠区间，如果存在，那么可以共用一只箭，否则，需要另外一只箭
比如 [1,6] [2,8] [7,12] [10,16]
初始化重叠区间 pre = null
获取 pre 和 [1,6] 的重叠区间，发现 pre == null，因此，[1,6] 使用一只箭
更新 pre = [1,6]
然后获取 pre = [1,6] 和 [2,8] 的重叠区间 [2, 6]，这里使用一只箭
更新 pre = [2,6]
然后获取 pre = [2,6] 和 [7,12] 的重叠区间，发现为 []，不能跟前面的区间共用一只箭，需要使用一只新的箭
更新 pre = [7,12]
然后获取 [7,12] 和 [10,16] 的重叠区间 [10,12]，这里可以跟前面共用一只箭
综上： [1,6] 和 [2,8] 共用一只箭， [7,12] 和 [10,16] 共用一只箭

这里做法跟 合并区间 类似，只不过进行比较的区间不是取最大，比如 [1, 6] [2, 8] 两个区间
对于合并区间来说取的是 [1, 8]
对于本题来说取的是 [2, 6]
```



### 实现代码

```java
class Solution {
    public int findMinArrowShots(int[][] points) {

        Arrays.sort(points, (a, b) -> a[0] == b[0] ? b[1] - a[1] : a[0] - b[0]);
        int c = 0;
        int[] pre = null;
        for(int[] p : points){
            //不存在重叠区间
            if(pre == null || pre[1] < p[0]){
                pre = p;
                c++;
            }else{
                /*
                这里更新重叠区间
                由于我们 start 按照升序，end 按照降序
                那么可能出现的情况为 
                [1, 100] [1, 10]
                [1, 100] [2, 10]
                [1, 100] [2, 200]
                而 pre[1] 和 p[1] 不存在特定的大小关系，因此需要进行比较
                我们完全不关心 pre[0] 和 p[0]，因为我们按照 start 进行升序，这意味着 如果 pre[1] >= p[1]，那么区间必定重叠
                而且我们上述比较也没用到 pre[0]
                */
                //pre[0] = p[0];
                pre[1] = Math.min(pre[1], p[1]);
            }
        }
        return c;
    }
}
```


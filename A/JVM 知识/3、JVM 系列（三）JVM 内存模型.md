





# JVM 内存模型

## 1、JVM 内存模型

JDK 1.8 的 JVM 内存空间如下：

![img](https://pic4.zhimg.com/80/v2-fb2f583edea32cfde008ecb5390244b9_720w.jpg?source=1940ef5c)



### 2.1、程序计数器

---

线程私有，即每个线程都有一个程序计数器，记录字节码指令的位置



这里的程序计数器跟操作系统的程序计数器不同

操作系统的程序计数器是使用 寄存器来实现的，线程的程序计数器是使用内存来实现的



当运行 native 方法时，由于不是 java 代码，因此不会使用 java 的程序计数器，对应的程序计数器值为空

一个线程方法间的切换是不需要保存程序计数器的



### 2.2、虚拟机栈

------

线程私有，即每个线程都有一个虚拟机栈，每个线程都有自己的方法调用链，虚拟机栈存储调用的方法的栈帧

> **它是 JVM 用来描述 Java 方法执行的内存模型**

每当一个方法被调用时，就会创建一个新的栈帧，当某个方法执行完毕后，那么就会将栈顶的栈帧弹出

由于是栈模型，所以表示栈顶的栈帧是最新的，即对应的是当前正在执行的方法



栈的内存空间也是有限的，即存储的栈帧是有限的，即递归调用的方法数是有限的

如果一直深入递归，那么就会栈溢出，那么抛出 StackOverflowError 异常



> ### 栈帧

具体看 <https://blog.csdn.net/qian520ao/article/details/79118474>





### 2.3、本地方法栈

---

线程私有，跟虚拟机栈差不多的，不过是存储 native 方法的栈帧

native 方法可以在 Object 中找到：getClass()、clone()、wait()、notify()



### 2.4、堆内存



堆内存 是 JVM 内存中最大的一块内存，基本上所有 的实例对象都是在这里分配内存，即基本上所有的实例对象都是存储在堆内存中

**堆内存分为：新生代（一个伊甸区、两个幸存区，比例为 8：1：1）和 老年代**

**当堆内存无法给新的实例对象进行内存分配的时候，那么就会抛出 OutOfMemoryError 的异常**



老年代 ：新生代 = 2 ：1

E区 ：S0：S1 = 8：1：1



### 2.5、方法区

---

存储着已加载的类的类型信息（类名、父类、子类、方法列表、虚方法表）



**当方法区无法满足内存分配需求时，将抛出 OutOfMemoryError 异常。**



方法区 是 JVM 一个抽象的规范，而 永久代 和 元空间 则是方法区的实现

- 在 JDK 8 之前，使用的都永久代，它位于 JVM 内存当中，受到 JVM 管理，而 **永久代 和 老年代 是进行 GC 绑定的，一旦其中一个区域占满，那么这两个区域都会同时进行 GC**，所以我们需要注意 永久代的空间大小

- JDK 8 的时候，使用元空间代替永久代，元空间不在 JVM 内存中，而是在本地内存中（即我们的计算机内存，比如我这台电脑 8G），这样理论上它能够使用的内存空间是没有限制的，也就很难出现 GC 和 OOM，而且 运行时常量池也从元空间移除了，在堆中开辟了一个内存空间存放运行时常量池



> ### 各种常量池

**字符串常量池：**

JDK 6 字符串常量池存储在永久代中，JDK 7 以后将字符串常量池放到堆中



**运行时常量池：**存储字面量 和 符号引用

JDK 7 时在永久代中， JDK 8 的时候由于永久代消失了，取而代之的是在本地内存的元空间，所以将运行时常量池放到堆中

这时候 运行时常量池 和 字符串常量池都是在堆中的



## 2、JVM 内存分配策略



JVM 内存分配 有 5 钟策略

**注：新生代划分为 伊甸区（E区） 和 两个幸存区（S区），比例为 8：1：1**



> ### 对象优先进入新生代

大多数情况下，对象都是在 E区 中分配内存，当 E区 无法给申请内存的对象分配连续的内存的时候，那么就会触发一次 minor GC（young GC）

将 E区、S区① 存活的对象放到 S区② 中，然后 S1 和 S2 互换指针，保持 S区② 指针指向的区域 是空的



> ### 大对象直接进入老年代

大对象是需要大量连续的内存空间的，比如大数组和超长字符串，由于存放在 E 区的话很容易导致内存不足而频繁产生 GC，所以直接放到 老年代

对于多大的对象才直接进入老年代，可以通过参数设置



> ### 根据对象年龄判断是否进入老年代

所谓的年龄，如果经历过一次 young GC 对象仍然存活，那么年龄 +1，如果没有存活，那么直接享年 x 岁

某个对象第一次经历 young GC 存活时，会将该对象从 E区 移动到 S区①，且对象年龄为 1，往后只要经历过 指定次 young GC 还活着，那么就将该对象移动到 老年代



> ### S区 中大于等于某个年龄的对象 超过 S区 一半，直接进入老年代

上述讲的 对象年龄到达阈值 才进入老年代的，但可能存在 S区 很多对象存活，但是都没有到达这个阈值，而是在边界

因此出现了新的策略：大于等于某个阈值年龄的对象数超过 S 区一半时，将大于等于该年龄的对象提前放入老年代



> ### 空间分配担保（这个就不太容易理解了，后续有时间再来理解吧）





## 3、OOM 内存溢出 和 内存泄漏

> ### OOM 内存溢出

程序计数器是线程私有的，是唯一一个不会出现 OOM 的区域

而 堆、虚拟机栈、方法区、本地方法区 都有可能会出现 OOM



**堆 OOM：**堆是线程共享的，当一个线程为一个对象申请分配内存的时候，如果堆内存空间不够，就会触发 GC，如果 GC 之后还是无法分配，那么就会产生 堆 OOM

**栈 OOM 和 本地方法栈 OOM：**栈是线程私有的，存储的是方法调用链中的每个栈帧，它有一定的大小，即调用的方法数是有限的，死循环调用会出现 StackOverflowError ，无限创建线程会出现 OOM（Unable to create new native thread）

**方法区 OOM：**方法区是存储类的元数据 ，它的大小也是有限的，如果加载过多的类，再加载新的类的时候无法分配空间，那么就会产生 方法区 OOM，(这时候所有的线程都会受到影响)

**运行时常量池 OOM：**运行时常量池是位于方法区的，在运行过程中的 Integer、String 常量之类的都会放入这个常量池，它也是有空间大小的，如果常量太多会导致 方法区 OOM	(**可以算作是方法区 OOM 的一种**)



> ### 内存泄漏

**JVM 对内存进行全权管理，从自动分配到垃圾回收，为什么还会发生内存泄漏？**

java 方面的内存泄漏跟 C 的内存泄漏不太一样，C 由于不存在 JVM 的自动垃圾回收，因此每次都需要手动释放对象，而如果在没有释放对象前就失去了对这个对象的引用，那么这个对象就无法被释放，会一直占用内存，这就导致内存泄漏

比如下面这段代码

```C
for(i=0; i<N; i++) {
    p = malloc(4096);
    p = malloc(4096);
    free(p);
}
```

对于第一个 malloc 的内存，没有释放就失去了引用，这就导致内存泄漏



而由于 java 存在 JVM，会对没有引用的对象进行回收，所以很难出现 C 层面的内存泄漏

所以对于 java 的内存泄漏来说，就是反过来的，已经使用完了某个对象，但是仍然留着对它的引用，导致 JVM 无法进行回收，占用着内存空间

比如下面这段代码

```java
class stack {
    Object[] data = new Object[1000];
    int top = -1;

    public void push(Object o) {
        top++;
        data[top] = o;
    }

    public Object pop(Object o) {
        top--;
        return data[top + 1];
    }
}

```

对于 push 进去的元素， pop 的时候并没有失去对它的引用，而是简单的对 top 指针进行变化

这样的话， pop 后的栈顶对象已经使用完了，但是 data 数组还留着对它的引用，导致它无法被垃圾回收

只能等到 push 到该位置时，使用一个新的元素来代替 data 对它的引用，它才能被 JVM 回收

而如果 push 了 1000 个元素，然后再 pop 1000 个元素，那么这时宏观上来看 data 中是不存在任何元素的

**但是，实际上 data 并没有放弃对那 1000 个元素 的引用，这样的话这 1000 个元素不会被 JVM 回收，也不会被再次使用，相当于是垃圾堆放在了内存空间中，这样就导致了内存泄漏，进一步可能会导致 内存溢出**



同时，内存泄漏还有各种情况，都是使用完了没有放弃引用而导致无法被 JVM 回收的：

- 流 stream 使用完没有调用 close()，这样内部还在运行，就不会被垃圾回收
- 未关闭连接，比如数据库连接，connection 后，使用完了没有调用 close()，跟上面的 stream 类似



> ### 一个线程 OOM 会对同进程的其他线程的运行产生影响吗？

执行代码：

```java
public class A{
    public static void main(String[] args) {
        A a = new A();
        new Thread(a::h1).start();
        new Thread(a::h2).start();
    }

    public void h1() {
        while(true){
            int[] a = new int[1000000000];
        }
    }
    public void h2()  {
        System.out.println(1);
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(2);
    }
}
```



输出结果：

```java
1
Exception in thread "Thread-0" java.lang.OutOfMemoryError: Java heap space
	at cur.A.h1(A.java:19)
	at cur.A$$Lambda$1/2003749087.run(Unknown Source)
	at java.lang.Thread.run(Thread.java:745)
2
```



我们可以发现，一个线程 OOM，不会对其他线程的运行产生影响，因为一个线程 OOM，一般是因为堆栈内存不足，OOM 发生后产生 GC 回收掉该线程可回收的资源

如果是栈 OOM，由于栈是线程私有的，所以对其他线程不产生影响

如果是堆 OOM，如果在 GC 前，其他线程没有进行对象分配，或者 对象分配时内存空间足够， 那么就不会产生任何影响

如果其他线程进行内存分配而空间又不足时，就会导致该线程也 OOM 





## 4、静态变量、全局变量、局部变量、 和 常量存储位置

静态变量： JDK 1.7 后从方法区中移除，放入到 Class 对象中，而 Class 对象存储在 堆中

全局变量：某个类实例化时进行初始化，是属于某个类实例的，因此跟类实例一样存储在堆中

局部变量：属于某个方法的，方法的具象化是用栈帧来表示的，局部变量存储在局部变量表中，基础类型的局部变量（int）存储的是值，非基础类型的局部变量（User）存储的是引用，而局部变量表是栈帧的一部分



常量：

假设定义了这些常量

```java
final int i = 10;
final String s = "abc";
final double d = 123.00987d;
final float f = 10.001f;
```

解析字节码如下：

```text
Code:
stack=2, locals=8, args_size=1
0: iconst_1
1: istore_1
2: bipush        10			//int i = 10
4: istore_2
5: ldc           #2         // String abc	常量池中的位置
7: astore_3
8: ldc2_w        #3			// double 123.00987d	常量池中的位置
11: dstore        4
13: ldc           #5 		// float 10.001f	常量池中的位置
15: fstore        6
16: return
```

可以看出，final 修饰的变量在编译时期产生的字节码 与普通的变量没有区别，意味着是在编译阶段就保证了 final 的不变性，即通过各个代码判断是否被发生改变，如果发生了改变，那么编译就不通过，而在后续编译完成的 字节码就是当作普通的变量来对待

所以，被 final 修饰的变量，该存哪还是存哪





## 5、JVM 编译（包含 JIT 和 逃逸分析）

**JVM 有两种编译：前端编译 和 后端编译**

- 前端编译就是 `.java` 变成 `.class` 的过程，这个过程会进行语法分析、语义分析等，通常叫做 **类加载**

- 后端编译就是 **即时编译 JIT**，也可以叫做运行时编译



因为前端编译出来的 `.class` 它是字节码的形式，CPU 是看不懂的，所以需要转换为 机器码

即时编译 是使用 JVM 的 解释器（**Interpreter**）来实现的，当程序调用到某条指令的时候，将这个字节码翻译为机器码，让 CPU 去调用，从字节码翻译为机器码的过程叫做 **解释执行**，是由 JVM 的 解释器 完成的，显然这个过程比直接执行 二进制机制码要慢

因此，JIT 发现某个方法或者代码块运行的次数到达某个阈值（**热点检测**），那么就会将这个方法或代码块翻译成 机器码，然后存储到内存中，后续程序再调用的时候直接将 保存的机器码 给它，这样就省去了 解释执行的过程，这个叫做 **编译执行**

![img](https://picb.zhimg.com/80/v2-b6f9389c136957504a5c1ae563aba5f3_720w.jpg)



> ### JVM 的对象一定都是存储在堆中吗

由于存在 JIT 技术，所以这句话就是不对的

JIT 会进行 **逃逸分析**



**逃逸：**一个变量或者对象在一个线程的方法中被分配的时候，变量指针可能逃逸到别的线程中去，这样的变量和对象被访问的地方是无法确定的，这样的指针就是 逃逸



**逃逸分析：**JIT 会在执行代码前分析某个指针可以存储的所有地方，以及确定这个指针的生命周期是否只存在于当前线程中

如果可以确定指针指向的对象只会被当前线程访问，那么就会将这个对象在栈中进行分配，这样随着方法的销毁而销毁，优化 GC

比如

```java
class Main {   
  public static void main(String[] args) {     
    example();   
  }   
  public static void example() {     
    Foo foo = new Foo(); //alloc     
    Bar bar = new Bar(); //alloc     
    bar.setFoo(foo);   
  }
}  
class Foo {
}  
class Bar {   
  private Foo foo;   
  public void setFoo(Foo foo) {     
    this.foo = foo;   
  }
}
```

在 example() 中，创建了两个对象 Bar 和 Foo, 并且通过 setFoo() 使 Bar 保存 Foo 对象的引用。

如果 Bar 存储在堆中，那么 Foo 对象将逃逸，因为 Bar 可以被任何线程访问，无法确定它的生命周期，但是通过 JIT 可以分析出  Bar 只会在 example() 中访问，属于局部变量，因此 Foo 也不会发生逃逸，这样就可以放心的在栈中分配这两个对象了，而不是在堆中分配



**同时，多加一个知识点：锁消除 和 锁粗化、自动装箱拆箱 、泛型擦除 也是在 JIT 时期进行的优化**
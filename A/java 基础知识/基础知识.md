# 基础知识



## 1、面向对象语言的特点

**像 java 这种面向对象的语言有三大特点：封装、继承、多态**



对于继承，需要注意的是，**子类只会继承父类的非静态方法和成员变量，而静态方法和成员变量是无法继承的**

```java
class A{
    int a = 1;
    static int b = 3;
}
class B extends A{
    int a = 2;
    public static void main(String[] args) {
        A b = new B();
        System.out.println(b.a);//输出父类 A 的 a 值 1
        System.out.println(b.b);//编译时报错，因为 B 不能继承 A 的静态变量 b
    }
}
```



封装就不说了，主要说说什么是多态，以及多态的两种类型（编译时和运行时）



> 多态的概念

多态，如字面意思，同种行为具有不同的表现形态

现实中，比如我们按下 F1 键这个动作：

- 如果当前在 Flash 界面下弹出的就是 AS 3 的帮助文档；
- 如果当前在 Word 下弹出的就是 Word 帮助；
- 在 Windows 下弹出的就是 Windows 帮助和支持。

同一个事件发生在不同的对象上会产生不同的结果。



> 多态产生的必要条件

**多态存在的三个必要条件**

- 继承
- 重写
- 父类引用指向子类对象

多态是父子之间的关系，父可以是 类 和 接口，子需要 继承类 或者 实现接口

比如：

```java
Parent p = new Child();
```

**函数执行结果的多态：**

一条语句必须同时出现父类和子类，不过是父类的引用和子类的对象

并且要出现一个行为有多种表现形态的话，那么子类就必须重写父类的方法，让方法调用的效果与父类不同



**函数调用传参的多态：**

当我们调用方法传输参数的时候，方法参数设置为父类，那么我们可以传入它的各个子类，方法执行效果如同上面的多态



> 重载是不是多态呢？

多态产生的 3 个必要条件中，第二个条件说的是重写，那么重载是不是多态呢？

有的说是多态，因为相同的一个函数名存在多种不同的执行结果

有的说不是，因为重载是发生在一个类中的，不是发生在继承类之间的，即它们认为必须是父子之间的多态行为

当然，这只是一种工具，差不多知道就好，也没有具体的界定



> 两种多态类型：编译时多态 和 运行时多态

**编译时多态：编译期间就确定的**，主要是方法重载、 静态方法成员和变量、非静态成员变量

我们写的代码都是静态文件，需要编译成二进制文件才能运行，而编译成的二进制文件其实是一条条指令，CPU 根据按照顺序运行这些指令就是在运行我们的代码，当我们一个类中存在多个同名的方法（重载）的时候，编译时就需要通过我们调用方法传入的参数来确定调用的是哪个方法（这是方法重载，静态方法变量和非静态变量的引用也是这个时候确定的）



**运行时多态：运行时候才确定的** ，主要是方法重写，同个方法（父类和子类之间的角度）调用时出现的不同执行效果

比如 

```java
Parent p = new Child();
p.run();
```

上面这个 p 执行的就是子类的 run() 方法，这是在运行时候才确定调用的是哪个方法

主要是使用虚函数来实现，它指向 我们调用的 run() 方法调用的是谁的方法

如果子类中重写了 run() 方法，虚函数指向的是 子类的 run()，如果没有，那么虚函数指向的是 父类的 run()





## 2、为什么浮点数类型 float 和 double 不能使用 == 进行比较

我们首先需要知道，float 是 4 个字节，32 位， double 是 6 个字节，64 位（类比 int 和 long）

整型默认情况下是 int ，浮点型默认情况下是 double ，两者相反



在 Java 中运行一下代码
`System.out.println(2.00 - 1.10);`
**输出的结果是：0.8999999999999999**

为什么会产生这样的结果？

我们从底层浮点数的存储来看



> 浮点数在计算机中的存储

|        | 符号位 | 指数   | 尾数   |
| ------ | ------ | ------ | ------ |
| float  | 1 bit  | 8 bit  | 23 bit |
| double | 1 bit  | 11 bit | 52 bit |



浮点数是有一定存储范围的，我们将一个十进制数存储进计算机的时候，实际上是转换为二进制数

上面的 1.10，整数部分 1 二进制就是 1 ，而小数 0.10 的转换如下：

0.1 * 2 = 0.2，取整数部分 0，余数为 0.2

0.2 * 2 = 0.4，取整数部分 0，余数为 0.4

0.4 * 2 = 0.8，取整数部分 0，余数为 0.8

0.8 * 2 = 1.6，取整数部分 1，余数为 0.6

。。。

。。。

我们可以看出，无论如何 0.1 都无法取到尽头，但是由于 double 类型的尾数部分只能存储 52 bit，因此导致超出的部分被舍去了

导致了精度丢失

而上面输出 0.8999 同样是精度丢失的问题，因为 0.1 无法精确转化为二进制数，只能无限接近，导致转换的值比 0.9 大，因此才出现了 0.0000000...1 的差距



> 将上面的运算替换为 float 后是什么结果？

我们也说了，浮点数默认是 double 类型，如果我们转换成 

`System.out.println(2.00f - 1.10f);`

**输出的结果是：0.9**

这是因为 float 的精度没有 double 高，因此将多出的比 0.9 大的精度给舍弃了，所以才得到正确的 0.9



> float 和 double 比较

```java
float f1 = 0.5f;
double d1 = 0.5;

float f2 = 0.1f;
double d2 = 0.1;

System.out.println(f1 == d1); // true
System.out.println(f2 == d2); // false
```

上面代码出现不同情况的原因同样是因为精度丢失

由于 0.5 能够准确转换为 二进制数，因此 float 和 double 结果是一样的

但是 0.1 无法准确转换为 二进制数，而 float 的尾数位数 比 double 少，因此精度比 double 小，即转换结果为 f2 < d2





## 3、String str = new String(`"abc"`) 创建了多少个对象

```java
String s1 = new String("abc");
String s2 = "abc";
System.out.println(s1 == s2); //false
```

当常量池中不存在 `abc` 这个字符串时，那么 `new String("abc")` 创建了两个对象，一个存放在常量池中，一个存放在 堆内存中

然后 s1 指向了堆中的对象，s2 指向常量池中的对象



```java
String s1 = "abc";
String s2 = "abc";
System.out.println(s1 == s2); //true
```

只创建了一个对象，存放在常量池中，s1 和 s2 指向的都是常量池中的对象



```java
String s1 = "a" + "bc";
String s2 = "abc";
System.out.println(s1 == s2); //true
```

如果常量池中不存在 `a` `bc` `abc` 这3 个字符串时，那么创建了 3 个对象，都在常量池中

然后 s1 和 s2 都指向了常量池中的对象





## 4、hashmap 相关知识



### 4.1、hashmap 和 hashtable 的区别

---



> 相同点

hashmap 和 hashtable 都实现了 Map 接口



> 区别

hashmap 是线程不安全的，所有方法都没有锁机制

hashtable 是线程安全的，所有方法都加了重量级锁 synchronized



hashmap 的 key 和 value 都允许空值

hashtable 的 key 和 value 都不允许空值



hashmap 的默认容量是 16，后续扩容直接 * 2，即 cap << 1，这样就能保证是 2 的指数

hashtable 的默认容量是 11，后续扩容是 2 * old + 1



hashmap 的遍历方式是 iterator

hashtable 的遍历方式是 xxx（不知道什么东西）



一般在单线程下，我们使用的是 hashmap，效率比 hashtable 高

一般在多线程下，我们不使用 hashtable，也肯定不能使用 hashmap，而是使用一个效率更高的用来代替 hashtable 的 ConcurrentHashMap



### 4.2、hashmap 求 2 的指数的算法

---



该算法能够得到比 cap 大的最接近 cap 的 2 的指数

```java
static final int tableSizeFor(int cap) {
    int n = cap - 1;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
}
```



假设 n 的二进制数为 01xxxxxxxxxx

n |= n >>> 1； 对 n 右移 1 位，然后进行或操作，那么 n 变成  011xxxxxxxxx

n |= n >>> 2； 对 n 右移 2 位，然后进行或操作，那么 n 变成  01111xxxxxxx

n |= n >>> 4； 对 n 右移 4 位，然后进行或操作，那么 n 变成  011111111xxx

n |= n >>> 8； 对 n 右移 8 位，然后进行或操作，那么 n 变成  011111111111.。。。

。。。

可以看出，最终所有操作执行完毕，得到的是将最高位的 1 后面的数全部变成 1，比如 0100101，那么就变成 0111111

然后最后对它进行 n + 1，就变成 1000000，刚好是 2 的指数次

上面是 1 + 2 + 4 + 8 + 16 = 31，因为 int 型是 32 位，这样能够覆盖所有二进制数



最开始是 n = cap - 1 是为了防止最开始的 cap 就是 2 的指数的问题

比如 cap = 0100，最接近 cap 的 2 的指数就是它本身，那么 cap - 1 后 n = 0011，那么经过计算 n = 0100

而如果 cap 不减 1，那么 n = 0100，经过计算后会变成 n = 1000



### 4.3、hashmap 的扩容机制 resize()

---

> 什么时候会触发扩容？



当元素数量超过阈值的时候，那么就会触发扩容

阈值 = 容量 * 加载因子（加载因子一般是 0.75）



扩容是 容量变为原来的 2 倍，cap << 1，而阈值也同样变为原来的 2 倍



需要注意的是，一般是在 put() 完元素的时候，才判断是否需要进行扩容，即添加完元素再进行扩容的



> JDK 7 和 JDK 8 的扩容后进行的元素迁移机制

**JDK 7：**所有的元素都是链表的保存形式，开辟一个新的 Entry[] 数组后，开始将旧数组上的 Entry 插入到新的数组上去

**注意点：**

- 使用的是头插法，即旧数组按序遍历的节点，每次都是插入到新数组对应链表的头部，那么就会造成原本的节点顺序发生翻转
- 多线程下，元素迁移的过程中会发生死循环



**JDK 8：**由于 JDK 8 的容量始终是 2 的指数次幂，因此大大提高了迁移的效率，每个 Entry 无需重新 hash 来决定它在新数组中的存放位置，新的位置不是在 **原位置**，就是在 **原位置 + 原长度**

为什么？原因如下：

 ![img](https://pic2.zhimg.com/80/v2-da2df9ad67181daa328bb09515c1e1c8_720w.png) 

我们可以知道，JDK 8 扩容就是将 容量 左移一位，即 n << 1

当原容量为  1 0000 的时候，那么就是使用 n - 1 = 1111 来对 Entry  hash，那么只有尾四位进行计算，始终落在 0 - 15 的位置

而当扩容后，变成 10 0000 的时候，那么就是使用 n - 1 = 1 1111 来对 Entry hash，那么就多了高位一个 1，就是尾 五位 进行计算，这个 高位 1 就是原数组的长度，因此如果 hash 后该位置不为 0，只需要在原位置 加上原数组长度就是新的位置了

**注意点：**

- 正序插入，不会出现链表倒置
- 超过 8 个元素就将链表转换为红黑树，加快查询效率



> JDK 7 元素迁移 在 多线程 下死循环是如何产生的？

我们需要先看 JDK 7 元素迁移的代码：

```java

//newTable：新的数组，rehash：是否重新计算哈希
void transfer(Entry[] newTable, boolean rehash) {
    //获取新数组的长度
    int newCapacity = newTable.length;
    
    //遍历旧数组，需要注意的是，这里的 e 是一个链表头，而不是单单一个元素，通过 next 获取下一个节点
    for (Entry<K,V> e : table) {
        while(null != e) {
            //先记录下一个节点
            Entry<K,V> next = e.next;
            if (rehash) {
                e.hash = null == e.key ? 0 : hash(e.key);
            }
            int i = indexFor(e.hash, newCapacity);
            /*
            将节点 e 插入到 新的位置的头部，作为头节点，这就是头插法
            比如 
            e = 4
            newTable[i] = 3 -> 2 -> 1
            经过头插法
            那么就变成了 newTable[i] = 4 -> 3 -> 2 -> 1
            */
            e.next = newTable[i];
            newTable[i] = e;
            e = next;
        }
    }
```



**单线程下的元素迁移：**

 ![img](https://img-blog.csdnimg.cn/20190331174623768.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIyMTU4NzQz,size_16,color_FFFFFF,t_70) 



**多线程下的元素迁移：**

我们需要知道，多线程不是并行执行的，而是并发执行的，某个线程执行的过程中可能 CPU 会切换到其他线程

因此，某段代码 线程安不安全需要看 CPU 切换后执行别的线程是否对当前线程的这段代码的结果产生影响

很显然，这里就会

**过程：**

- 线程 1 和 线程 2 同时扩容，CPU 先执行线程 1

- 当线程 1 执行完 `Entry<K,V> next = e.next;` ，CPU 切换到 线程 2 ，注意，这里线程 1 的 e 指向的是 节点 3，而 next 指向 节点 7
- 当线程 2 执行完成后，由于是头插法，那么意味着最终的数组从 3 -> 7 就变成了 7 -> 3，注意，这里 7.next = 3，然后切换到线程 1
- 线程 1 将节点 3 插入到新的数组上，3.next = null，然后再处理 next = 7，一次新循环将 e 指向 7，由于 7.next = 3，所以 next = 3**（循环的初步建立）**
- 当使用头插法插入到新位置时，由于 3 和 7 是同个位置，因此 7 作为头节点时，7.next = 3，再然后处理 next = 3，一次新循环将 e 指向 3，再将 3 插入到新位置头节点，这时 3.next = 7，**死循环构成**

  

**这里需要注意的是：**Entry 节点对象至始至终都没有发生改变，改变的是新旧数组这个容器 和 Entry 对象存储的位置，并没有创建新的 Entry 对象去代替旧的 Entry 对象，它们存储在堆中，是所有线程共享的

因此线程 1 和 线程 2 操作的一直是同样的几个 Entry 对象，所以才造成了死循环





## 5、java 如何实现连续的内存分配

使用 new byte[size]





## 6、子类继承和不继承父类什么东西

子类可以继承父类的 非 private 修饰的 非静态方法和变量

如果非静态方法和变量是 private 修饰的，那么子类不能继承，即对子类不可见



```java
public class A extends B{
    public A(){
    }

    private void printA(){
        System.out.println("A printA");
    }
    public void printB(){
        System.out.println("A printB");
    }
}
class B{
    public B(){
    }
    //private 只能在类内部的方法调用
    private void printA(){
        System.out.println("B printA");
    }
    public void printB(){
        System.out.println("B printB");
    }
    public void printAB(){
        printA();
        printB();
    }
}
class C{
    public static void main(String[] args) throws ClassNotFoundException {
        Class<?> aClass = Class.forName("cn.oy.B");
        A a = new A();
        a.printAB();
    }
}
```



在父类 B 中有 private 修饰的 `printA()`，public 修饰的 `printB()` 和 public 修饰的 `printAB()`, 在`printAB()` 中调用了 `printA()` 和 `printB()`

然后子类 A 中也有一个 private 修饰的 `printA()`，public 修饰的 `printB()`

我们创建一个子类对象 `A a = new A();`，由于继承，所以 子类 A 继承了 父类 B 的 `printAB()`，调用它

而打印出来的结果是

```
B printA
A printB
```

我们可以看出， public 修饰的 `printB()` 就是打印的子类重写的方法，而 private 修饰的 `printA()`则是打印的父类的方法

这是因为子类并没有继承父类的 private 方法，子类里面的 `printA()` 只是自己定义的一个方法而已，并不是重写

所以对于在父类中的 `printAB()`，由于子类可见父类的`printB()`，并且重写了它，所以调用这个重写的方法

由于子类不可见父类的 `printA()`，所以只能是调用自己内部的 `printA()`





## 7、红黑树的基础

**二叉搜索树：**根节点大于左子节点，小于右子节点，方便查找，但是不平衡，可能退化成链表

像下面这种我们可以看作是顶端优势

![img](https://pic4.zhimg.com/80/v2-062c92b21fc992704bf281530c7d9f97_720w.jpg)



**AVL 树**：平衡，但是旋转到平衡会开销太大



**红黑树** 解决二叉搜索树的【顶端优势】，但又不会跟 AVL 树一样绝对平衡



> 红黑树的基本性质

- 节点有红黑两色
- 根节点必定是黑色的
- 没有两个相邻的红色节点（即父子节点不可能同时是红色的）
- NULL 节点是黑色的（我们认为叶子节点下面还有两个 NULL 节点，这肯定是为了方便某种东西的计算）
- 从任意一个节点到达 NULL 节点的路径上都有相同的 黑色节点数（不包括 NULL 节点到 NULL 节点）
# JVM 类加载

## 1、类加载过程

两个类是同个类的认定标准：

​	只有在 两个类 的 类名（包名 + class 类名）相同 并且 由同一个类加载器加载的时候，才算作是同一个类

父类加载器加载的类子类可以看到，子类加载器加载的类父类看不到



**类加载涉及到的只有 静态变量 和 静态方法**

因为 类加载并不是创建类实例，普通成员变量是类实例才有的，而 静态变量和静态方法是所有类实例共享的，是属于整个类的，因此类加载是将类的信息准备好，所以不会去碰有关类实例的东西

并且，静态变量 和 静态方法是存储在运行时常量池中的，而不是存储在堆中的，所以**类加载不会涉及到堆**



**加载：**加载 class 文件到 JVM 内存，这时候方法区里面的数据代码段和常量池之类的都准备好了

**验证：**校验 class 文件中的字节流信息符合虚拟机的规范，防止恶意代码

**准备：**静态变量赋 jvm 设置的初值，比如 int 设置为 0

**解析：**将方法、字段、类或接口 的符号引用转换为直接引用

**初始化**：只有主动引用会引起初始化，被动引用不会

​	以上就是类加载的过程，当类加载完成后，才会真正执行 new 的语义，在堆内存中分配内存然后实例化对象

**卸载：**1、该类没有任何实例   2、该类的 Class 对象没有在任何地方引用，即无法同个反射获取 Class 对象





> ### 主动引用

- new 
- 反射
- 调用静态方法（可以是 main()） 或 静态变量



首先，如果是 new 这种的话，那么执行的顺序为：

- 先是父类，静态变量赋值，执行静态代码块
- 然后是子类，静态变量赋值，执行静态代码块
- 然后再是父类，非静态变量赋值，执行构造代码块，调用构造方法
- 然后再是子类，非静态变量赋值，执行构造代码块，调用构造方法

new 的话因为是创建一个实例，每个实例都会涉及到普通的成员变量和方法，所以会使得 静态和非静态 都进行初始化

其他的只会初始化 静态方法和静态变量

**注意：**如果是在 子类使用 main()，那么父子都会静态初始化，如果是在 父类使用 main()，那么只有父类会静态初始化





> ### 符号引用 和 直接引用

```java
public class A{
	B b = new B();
	public void h(){
    }	
}
class B{
}
```

比如上面的代码，在编译的时候，A 引用了一个 B 对象，但是在编译成 class 的时候，并不知道这个 B 对象在堆内存中的位置，因为还没有 new 出来，指令还没有执行，所以使用一个 字符串 作为符号引用 指代这个 B 类，表示引用了一个 B 类

等到类加载的时候，在解析阶段看到这个符号引用就会去找 B 是否已经加载了，如果没有则进行加载，如果加载了则实例化一个对象，并且将这个符号引用转换为 堆中 B 对象的地址，即直接引用





## 2、双亲委派模型

### 1、什么是双亲委派模型？



当某个类加载器要加载类的时候，会将这个类一层层传递给父类加载器加载

如果父类加载器有这个类，加载成功，那么返回成功，否则就自己加载，这就是双亲委派模型



### 2、双亲委派的过程

ClassLoader 中有两个主要方法：loadClass() 和 findClass()

**其中 加载类的方法主要是 loadClass()，而 findClass() 是一个空方法，它需要子类去实现**

**loadClass() 是双亲委派机制的逻辑体现，而 findClass() 是类加载器对类进行加载的逻辑**

双亲委派模型加载过程：

- findLoadedClass() 判断该类是否已经被加载过了
- 如果没有，则判断当前加载器的父加载器是否为空，不为空那么交给父加载器去加载
- 如果为空，那么表示父加载器是 根加载器，那么交给根加载器去加载
- 如果都加载不成功，那么调用 findClass() 方法，进行加载（这里我们可以看出，我们自定义类加载器主要实现加载逻辑就是将 parent 设置为 null，这样根加载器肯定加载不了，然后再重写这个 findClass() 方法）

```java
    protected Class<?> loadClass(String name, boolean resolve)
        throws ClassNotFoundException
    {
        synchronized (getClassLoadingLock(name)) {
            //查看这个类是否自己已经加载过了
            Class<?> c = findLoadedClass(name);
            
            if (c == null) {
                long t0 = System.nanoTime();
                try {
                    //父类加载器不为空
                    if (parent != null) {
                        c = parent.loadClass(name, false);
                    } else {
                        //父类加载器为空，调用根类加载器加载
                        c = findBootstrapClassOrNull(name);
                    }
                } catch (ClassNotFoundException e) {
                }

                if (c == null) {
                    //调用自己的加载逻辑
                    c = findClass(name);
                }
            }
            return c;
        }
    }
```



### 3、双亲委派模型的好处



最开始也说了，JVM 认定类的原理，如果我们不使用双亲委派模型，自己写了一个 `java.lang.Object` 类，那么将会由 `AppClassLoader` 去加载

由于官方的 Object 类 和 我们自定义的 Object 类的类加载器不同

那么内存中就存在两个 Object 类，那么当我们使用 Object 类的时候，导入的` java.lang.Obejct`，也不知道是哪一个类

编译不会出错，但是运行会出错

```java
package java.lang;
//自定义 java.lang.Object 类
public class Object {
    public static void main(String[] args) {
        Object object = new Object();//编译不报错，运行报错
    }
}

```

  

双亲委派机制的好处：

- 用户写的类覆盖核心类
- 避免类重复加载（如果不是双亲委派，那么多个类加载器加载同个类，内存中就存在重复对象，并且算作是不同的对象，因为我们上面说了，只有被同个类加载器加载的类才是相同的类）



### 4、如何打破双亲委派机制

双亲委派模型的体现主要就是 ClassLoader 中的 loadClass() 方法

它在 loadClass() 中调用父加载器进行加载，当 loadClass() 失败后才调用当前类加载器的 findClass() 

因此，我们自定义一个类加载器，有两种选择：

- **重写 loadClass() 方法：**自定义类加载的模型，这样就**破坏了双亲委派机制**
- **重写 findClass() 方法：** 将自定义类加载器的父类加载器设置为 null，这样就默认父加载器是根类加载器，它必定不能加载我们自己写的类，因此会交给我们自定义类加载器进行加载，因此我们重写 findClass() 方法，自定义类加载逻辑，但这实际上**并没有打破类加载机制**，因为它还是存在委托给 根类加载器的情况，虽然没起什么作用就是了



### 5、为什么要破坏双亲委派模型

**看起来双亲委派机制好像挺好的，那么为什么还需要打破呢？**

对于一般情况下，用户类使用的是基础类，但是有的情况下，基础类也需要使用到用户类

在基础类的代码中使用用户类，该用户类需要加载，那么怎么进行加载？看调用方法，比如 Class.forName()，它的方法逻辑是使用调用类的类加载器进行加载的，如果是 基础类内部调用了 Class.forName()，并且加载的是一个用户类，显然，根类加载器是无法加载这个用户类的，因为 根类加载器只能加载特定的类，那么需要调用 AppClassLoader 来加载这个类，这样，从父类加载器调用子类加载器加载类，就破坏了双亲委派机制



**什么时候基础类会去使用用户写的类呢？**

SPI 机制：service provider interface（服务提供商接口）

比如 jdbc，jdk 提供的是一个规范接口 Driver，并不提供实现，提供实现的是数据提供商，它们的所有实现都需要根据这个 接口规范，而在第三方的类总不能放在 jdk 目录里作为基础类被 根加载器加载吧。。。

为什么这里会说 第三方实现类是由 根类加载器加载的，我们需要从没有 SPI 的时候说起

在没有 SPI 的时候，jdbc 我们不能使用接口编程，即不能：

```java
Class clz = Class.forName("java.sql.Driver"); Driver d = (Driver)clz.newInstance();
```

通过反射 Driver 类，因为 Driver 只是一个接口，没有具体的实现类，这样会报错

我们可以在  classpath 中引入一个  mysql-connector-java.jar ，里面有 Driver 的一个实现类，因此我们可以写成

```java
Class clz = Class.forName("com.mysql.jdbc.Driver"); Driver d = (Driver) clz.newInstance();
```

具体反射这个实现类，这就是我们自己硬编码指定加载某个类

这样的硬编码显然不合适，这种做法无法面向接口编程

因此，引入了 SPI 后，代码就变成：

```java
Connection connection = DriverManager.getConnection("jdbc:mysql://xxxxxx/xxx", "xxxx", "xxxxx");
```

DriverManager 自动根据 jdbc:mysql 去找实现，而 DriverManager 是根类加载器加载的，这样的话，它找到实现类，这个实现类是第三方类，使用默认的双亲委派机制的话，它没有父类，而自己(根类加载器)也无法加载，因此，就引入了线程上下文类加载器，可以通过线程上下文类加载器获取 AppClassLoader，来加载这个第三方类




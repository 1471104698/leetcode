# 进程间的通信方式



## 进程预知识

操作系统中的进程 就如同 进程中的线程一样，它们的空间地址是相互独立的，即一般是不能相互访问的

但如果进程对于线程来说是共享资源的平台一样，操作系统的 **内核空间** 对于进程来说也是共享资源的平台

它们如果要进行交流，那么必须通过内核空间

![img](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZckxn1SzJ697nE1m1wJzmPQ0htwayMPsS42OhdjA1MOZnsPvUuOqB25UDUkeYpWvKQ7FGqtUhZjaw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)





## 1、管道

管道有两种：匿名管道 和 命名管道(FIFO)



#### 匿名管道

---



如果学过 Linux 命令，那你肯定很熟悉 「`|`」 这个竖线。

```
$ ps auxf | grep mysql
```

上面这个命令行中，「`|`」就是一个管道，它的功能是将前一个命令（`ps auxf`）的 输出 发送给后一个命令（`grep mysql`），这里我们可以看出 **管道的传输方向是单向的**，即默认是从前一个指定的进程传输到后一个指定的进程

上面这种管道是没有名字，所以「`|`」表示的管道称为**匿名管道**，用完了就销毁。



#### 命名管道

---

使用 `mkfifo` 命令创建管道文件

```
$ mkfifo myPipe
```

上面的 `myPipe` 就是管道名字，它是文件是形式存在的

通过 ls -l 可以查看这个文件

```
$ ls -l
prw-r--r--. 1 root    root         0 Jul 17 02:45 myPipe
```

接下来，可以往 `myPipe` 中写入数据

```
$echo "hello" > myPipe //往 myPipe 管道文件中写入 "hello"
//。。。阻塞
```

但是我们可以看出，写入数据后进入阻塞状态，这是因为需要另一个进程去读取数据

执行另一个命令来读取数据

```
$ cat < myPipe  // 读取管道里的数据
hello
```

这时候之前的命令就不会阻塞了



我们可以看出：

管道实现简单，适合用户进行操作，比如用户自己执行` ps xxx | xxx`

但是不适合进程间自己的通信，因为发数据后需要等待对方接收数据，不然就会阻塞，干不了其他的事，**管道这种通信方式效率低，不适合进程间频繁地交换数据**。

同时也我们很容易得知管道里的数据已经被另一个进程读取了，因为如果没有被读取，那么就会阻塞



#### 管道实现原理

---

我们可以看出，**匿名管道** 实际上就是内核空间中的一段缓存空间，它不是文件的形式

由于内核空间是进程共享的，因此进程可以直接通过这段缓存进行通信



匿名管道的创建实际上内部是调用下面这个函数

```
int pipe(int fd[2])
```

我们可以看出，有一个大小为  2 的 int 型数组，`fd[0] `是读取描述符，`fd[1] `是写入描述符

由于管道是单向的，并且匿名管道只是一段缓存，它不是文件形式存在的，

因此创建 匿名管道 后，需要同时指定通信的进程，哪个是写入，哪个是读取，用完就销毁

![img](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZckxn1SzJ697nE1m1wJzmPQmsrxa4AwDelPGglhe3DMPTKEpmGW7icSDnozDo7plETZlTWQJmcDVug/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



注意：匿名管道只能用于父子进程间的通信，当父进程调用 pipe() 函数后，那么这个文件描述符是位于父进程的，怎么进行进程间的通信？

实际上需要通过 fork() 函数创建子进程，然后子进程也复制了父进程的文件描述符，因此就可以一个使用 `fd[0]`，一个使用` fd[1]`

![img](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZckxn1SzJ697nE1m1wJzmPQgD8dzOZUnAfmVVndTmtGgZRNZsBFEYghLPBjicziam2E1iapicANMYRXbg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



>  为什么匿名管道只能用于父子进程？而命名管道可以用于任何进程间的通信，这是怎么个说法呢？

匿名管道是存在于内存当中的，相当于我们创建了一个类的实体对象，这个类没有设置 set() ，也将变量设置为 private，不能更改，所以一旦定义，那么只能用于固定的两个进程

而命名管道是文件形式存在的，是存在于磁盘中的静态文件，相当于我们自己写的代码，类的模板，一旦我们要进行进程间的通信，那么就创建一个实体类对象，然后可以任意指定两个进程，用完后销毁这个实体类对象，但是类模板还在

这里再说一句：**管道这种通信方式由于进程会阻塞，所以效率低，不适合进程间频繁地交换数据**。



## 2、消息队列 

管道不适合进程间的频繁通信，因为进程会阻塞，效率低

而消息队列就能够解决这个问题

消息对队列是保存在内核中的消息链表，进程间的通信数据结构就是 数据块（类似链表的 Node 节点）

当进程 A 要给进程 B 发消息时，将数据封装在数据块中，然后放入消息队列，然后就可以返回做其他事了

而进程 B 需要的时候再去读取数据就可以了

类似我们平时发的电子邮件，你一封我一封，可以频繁交流

但是这种邮件形式的方式也有缺点：

- 一是信息不具有即时性，由于邮件什么的什么时候都可以看，因此可能今天看的这封邮件是几天前发的

- 二是邮件大小也有限制

我们上面说了，数据是封装在 数据块的，它也是一种数据结构，那么内部肯定是使用数组实现的，那么就有对应的大小限制

**消息队列不适合大数据的传输**

消息队列，存在用户态与内核态之间的数据拷贝开销。因为进程写入数据到内核中的消息队列时，会发生从用户态拷贝数据到内核态的过程，同理另一进程读取内核中的消息数据时，会发生从内核态拷贝数据到用户态的过程。


## **[312. 戳气球（经典动规，难度同鸡蛋掉落）](https://leetcode-cn.com/problems/burst-balloons/)**



```java

有 n 个气球，编号为0 到 n-1，每个气球上都标有一个数字，这些数字存在数组 nums 中。

现在要求你戳破所有的气球。每当你戳破一个气球 i 时，你可以获得 nums[left] * nums[i] * nums[right] 个硬币。 这里的 left 和 right 代表和 i 相邻的两个气球的序号。注意当你戳破了气球 i 后，气球 left 和气球 right 就变成了相邻的气球。

求所能获得硬币的最大数量。

说明:

你可以假设 nums[-1] = nums[n] = 1，但注意它们不是真实存在的所以并不能被戳破。
0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100
```



## **示例:**

```java
输入: [3,1,5,8]
输出: 167 
解释: nums = [3,1,5,8] --> [3,5,8] -->   [3,8]   -->  [8]  --> []
     coins =  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   = 167
```



## **方法①、回溯（暴力枚举）**

### **实现思路**

```java
要求的是最值问题，求 最值 就是需要枚举所有的情况，获取其中的最大值

对于第一个戳破的气球，选择不同的气球会有不同的分数，对后续戳破的气球也存在影响
因此我们需要枚举 每一种戳破不同气球的 分数，得到其中的最大值

比如第一个戳破的是 1 号气球，那么第二个可以选择 [2, n] 中的任意一个气球，后面又在继续选择，这就 类似全排列

因此，我们使用全排列的回溯方法来 dfs

//某个气球戳破后，将分数设置为 -1
```



### **实现代码**

```java
class Solution {
    public int maxCoins(int[] nums) {
        /*
            dfs：暴力枚举所有情况
        */
        len = nums.length;
        dfs(nums, 0, 0);
        return maxCount;
    }
    int len;
    int maxCount = 0;
    private void dfs(int[] nums, int count, int idx){
        if(idx == len){
            maxCount = Math.max(maxCount, count);
            return;
        }
        for(int i = 0; i < len; i++){
            int c = 0;
            if(nums[i] != -1){
                int[] lr = find(nums, i);
                c = count + lr[0] * nums[i] * lr[1];
                int temp = nums[i];
                nums[i] = -1;
                dfs(nums, c, idx + 1);
                nums[i] = temp;
            }
        }
    }
    //获取某个气球左右两边相邻的气球
    private int[] find(int[] nums, int i){
        int left = i - 1;
        int right = i + 1;

        while(left >= 0 && nums[left] == -1){
            left--;
        }
        while(right < len && nums[right] == -1){
            right++;
        }

        return new int[]{left < 0 ? 1 : nums[left], right == len ? 1 : nums[right]};
    }
}
```





## **方法②、动态规划**



### 实现思路①

```java
动态规划最难的就是 怎么想到状态转移方程，需要将问题划分为多个独立的子问题，即各个子问题之间不会互相影响

            动态规划：
            假设有 n 个气球，题目规定 nums[0] = nums[n + 1] = 1
            那么我们可以将原来数据进行扩展，将 0 号位置和 n + 1 号位置作为边界，分数为 1， 
                num = new int[n + 2]；
                nums[0] = nums[n + 1] = 1
            
            那么我们可以将问题重新看作：
                在一排气球中，戳破 0 号 和 n + 1 号 气球之间的所有气球，最终剩下 0 号 和 n + 1 号气球，能够得到的最大分数？
            
            定义状态转移方程:
                dp[i][j] 表示 (i, j) 戳破 i 和 j 气球（不包括 i j）之间的所有气球能够得到的最大分数
                这就是子问题，那么原来问题的 最终解为 dp[0][n + 1]，划分出子问题 区间 (i, j) 

                (i, j) 之间气球的戳破顺序是有讲究的，因为最终肯定有一个顺序能够得到最大值
                我们关注的点有两个：第一个戳破的气球 和 最后一个戳破的气球
                如果关注 第一个戳破的气球，那么相当于正向思想，实际上就是回溯
                	如果按动态规划来看，dp[i][j] = dp[i][k] + dp[k][j] + nums[k - 1] * nums[k] * nums[k + 1]
                	但是当我们划分出 (i, k) 和 (k, j) 两部分时，
                	对于 k - 1 气球来说，它的右相邻气球在 右半部分，对于 k + 1 气球来说，它的左相邻气球在左半部分，因此无法进行划分
                	
                这里我们只能关注最后一个戳破的气球，假设为 k，那么当剩下最后一个气球 k 时，它的相邻气球就是 i 和 j
                那么状态转移方程为:
                    dp[i][j] = dp[i][k] + dp[k][j] + nums[i] * nums[k] * nums[j]
                
            初始条件：当 (i, j) 之间没有气球时，即 i + 1 == j，比如 (2, 3)，那么 dp[i][j] 的分数为 0
            
            当我们计算 dp[i][j] 的时候，需要用到 dp[i][k] 和 dp[k][j]，即这些值必须在更早之前计算好
                那么 i 和 j 的遍历顺序应该是怎样的？
                1、需要用到 (i, k)，而 k < j
                那么就是遍历过 k 后再继续遍历 k + 1, k + 2... j, 正序遍历
                2、需要用到 (k, j)，而 k > i
                那么就是遍历过 k 后再继续遍历 k - 1, k - 2... i, 反序遍历

                即：
                外层循环的 i 是正序遍历，即从 0 -> n 
                内层循环的 j 是反序遍历，即从 i-1 -> 0
```





### 实现思路②

```java
            分治划分，我们正向看，从第一个戳破的气球开始，逐个进行戳破的话，
            当我们搓破第 i - 1 个的时候，然后再戳破第 i + 1 个，那么我们对于第 i  个来说，我们每次都需要向左边和右边找到没被戳破的气球作为左右边界
            这样时间复杂度最差是 O(n^2)，这还只是对于一次 递归来说，我们需要递归多次，必定超时

            气球索引为 [1, n]，而 0 和 n + 1 是不存在的虚拟气球，不能戳破的，只能作为边界，其值为 1
            因此，我们换种思路，我们从最后一个戳破的气球开始看，对每个气球都进行假设，假设某个气球是最后一个戳破的
            假设第 i 个气球是最后戳破的，那么 0 和 n + 1 就是 气球 i 的左边边界
            那么对于倒数第二个戳破的气球，肯定是属于 [1, i - 1] 或者 [i + 1, len]
            我们继续对剩下的气球进行假设
            假设倒数第二个戳破的气球是 j ∈ [1, i - 1]
            因为 j 是倒数第二个戳破的，那么它还没戳破时，剩下的气球为 0, j, i, n + 1
            那么它的左边界为 0，右边界为 i，因为 i 是在 j 之后戳破
            假设倒数第二个戳破的气球是 j ∈ [i + 1, n]
            因为 j 是倒数第二个戳破的，那么它还没戳破时，剩下的气球为 0, i, j, n + 1
            那么它的左边界为 i，右边界为 n + 1

            就一直这样下去，对于倒数第 k 次戳破 第 i 个气球，我们可以分治为 [0, i - 1] 和 [i, n + 1] 两部分
            将 i 作为 倒数第 k + 1 次戳破的气球的边界
            （注意，这里的 k 是倒数，比如 k = 1，那么 i 是最后戳破，然后将 i 作为倒数第二次戳破的气球的边界）

            dp[i][j] 表示 (i, j) 这些气球能够获得的硬币的最大数量，注意：不包括 i 和 j，这两个只是作为边界
            i, i+1, i+2, ... k, k+1, k+2, ... j
            假设最后一次戳破的是 k，对于最后的 k 气球来说, i 和 j 就是它的边界，而它会变成 [i, k] 之间 和 [k, j] 之间气球的边界
            dp[i][j] = Math.max(dp[i][j], dp[i][k] + dp[k][j] + nums[i] * nums[k] * nums[j]);
```



### 实现方法

```java
class Solution {
    public int maxCoins(int[] nums) {
        
        int n = nums.length;
        int[] points = new int[n + 2];
        System.arraycopy(nums, 0, points, 1, n);
        points[0] = points[n + 1] = 1;

        //初始条件已经默认为 0
        int[][] dp = new int[n + 2][n + 2];
		
        //这里跟上面讲的有点不一样，上面是 i < j，这里是 i > j
        //戳破(j, i) 范围内的所有气球，遍历 (j, i) 范围内的气球，将气球 k 作为最后一个戳破的气球
        for(int i = 2; i < n + 2; i++){
            for(int j = i - 2; j >= 0; j--){
                for(int k = i - 1; k > j; k--){
                    dp[j][i] = Math.max(dp[j][i], dp[j][k] + dp[k][i] + points[k] * points[i] * points[j]);
                }
            }
        }
        return dp[0][n + 1];
    }
}
```


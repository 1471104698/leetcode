# JVM 知识点



**我们需要先知道，Java 有两种对象：实例对象 和 Class 对象**

## 1、类编译 到 类加载 过程 及 产物

---



> 类编译

当我们写完代码后，生成的是一个 .java 的静态文件，这个文件在磁盘中

当我们点击运行 .java 文件的时候，它会先开始编译，将代码转变成二进制数据，其中是一条条的指令，变成 .class 文件（字节码文件）



> 类加载

JVM 将某个 .class 文件中的二进制数据加载进内存中，创建出对应的一个 `java.lang.Class` 对象，类加载的最终产物就是 JVM 中的 Class 对象



### 1.1、什么是 Class 类（类加载的最终产物）

---



> `java.lang.Class` 类 和 我们自己写的类的关系

除了 int 等基本数据类型之外**（基本数据类型不是类）**，**Java 的其他类型（包括 interface）都是 Class 类的实例**

其他类（接口）是 Class 类的实例？ 那么 Class 类是谁写的？

Class 类是 `jvm` 动态加载进内存的，它是 private 类型的，用户无法自己创建

```java
public final class Class {
    private Class() {}
}
```



Class 类里包含了 某个 class 类的所有方法变量信息，当 JVM 加载一种新的 class 类的时候，比如 String 类，那么就会**获取 String 的信息，为这个 String 类创建一个 Class 类实例，然后关联起来**

```java
Class cls = new Class(String);
```



也就是说，**除了 Class 外的其他所有 class 类，每个 class 类对应一个 Class 类实例，在 JVM 中的类都是 Class 实例**

```ascii
┌───────────────────────────┐
│      Class Instance       │──────> String
├───────────────────────────┤
│name = "java.lang.String"  │
└───────────────────────────┘
┌───────────────────────────┐
│      Class Instance       │──────> Random
├───────────────────────────┤
│name = "java.util.Random"  │
└───────────────────────────┘
┌───────────────────────────┐
│      Class Instance       │──────> Runnable
├───────────────────────────┤
│name = "java.lang.Runnable"│
└───────────────────────────┘
```



**注意：是一个 class 类对应一个 Class 实例，而不是一个 class 对象对应一个 Class 实例，即相当于我们平常的内存中的 Cat 类，它是一个 Class 实例，不过这个 Class 实例的名字对外暴露的是 Cat，它具有我们自己写的对应的变量，然后使用这个 Class 对象创建出更多的我们自定义的 所谓的 Cat 实例对象**





> 反射的概念



换言之，所有 class 类的信息都存储在对应的 Class 类实例中，那么我们只需要获取对应的 Class 类实例，就意味着获取了这个 class 类的所有信息，**通过`Class`实例获取`class`信息的方法，就是反射**



### 1.2、双亲委派模型（类加载的操作者）

---



我们需要知道，**JVM 只有在 两个类 的 类名（包名 + class 类名）相同 并且 由同一个类加载器加载的时候，才算作是同一个类**



> 什么是双亲委派模型？



当某个类加载器要加载类的时候，会将这个类一层层传递给父类加载器加载，如果父类加载器有这个类，加载成功，那么返回成功，否则就自己加载，这就是双亲委派模型



> 双亲委派模型的好处



最开始也说了，JVM 认定类的原理，如果我们不使用双亲委派模型，自己写了一个 `java.lang.Object` 类，那么将会由 `AppClassLoader` 去加载

由于官方的 Object 类 和 我们自定义的 Object 类的类加载器不同

那么内存中就存在两个 Object 类，那么当我们使用 Object 类的时候，导入的` java.lang.Obejct`，也不知道是哪一个类

编译不会出错，但是运行会出错

```java
package java.lang;
//自定义 java.lang.Object 类
public class Object {
    public static void main(String[] args) {
        Object object = new Object();//编译不报错，运行报错
    }
}

```

  

## 2、JVM 内存模型



**JVM 内存结构有三大块：方法区、堆内存 和 栈**

其中，堆内存是最大的一块

**堆内存 和 方法区 是线程共享的，栈 是线程私有的**



### 2.1、堆内存

---

堆内存 是 JVM 内存中最大的一块内存，基本上所有 的实例对象都是在这里分配内存，即基本上所有的实例对象都是存储在堆内存中

堆内存分为：新生代和老年代

当堆内存无法给新的实例对象进行内存分配的时候，那么就会抛出 OutOfMemoryError 的异常



### 2.2、方法区

---

存储 JVM 加载的类的信息、常量、静态变量、代码段等



**当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。**



### 2.3、虚拟机栈

---

虚拟机栈 跟 上面两个内存模型不同，它是线程私有的

**是 JVM 用来描述 Java 方法执行的内存模型**

每当一个方法被调用时，就会创建一个新的栈帧，当某个方法执行完毕后，那么就会将栈顶的栈帧弹出

由于是栈模型，所以表示栈顶的栈帧是最新的，即对应的是当前正在执行的方法

并且由于每个线程都有自己的调用链，所以栈只能是自己私有的，各个线程的方法调用必须是独立



栈的内存空间也是有限的，即存储的栈帧是有限的，即递归调用的方法数是有限的

如果一直深入递归，那么就会栈溢出，那么抛出 StackOverflowError 异常

```java
package cn.oy;

public class Fuxk {
    public static void main(String[] args) {
        dfs();
    }
    public static void dfs(){
        dfs();
    }
}
```



## 3、GC 回收算法



### 3.1、回收对象的判断方法

---

**引用计数**：每个对象都有一个引用计数的属性，每当一个有一个指针变量引用它时，那么它的引用次数 +1，反之，引用次数 -1，当次数为 0 时，表示可以进行回收

缺点：当两个对象循环引用时，那么就无法回收，因为它们的引用计数都不为 1

比如下面的这种，循环引用，然后对他们自身的引用置空

```java
class A{
    A instance;
    public void static main(String[] args){
        A a1 = new A();
        A a2 = new A();
        a1.instance = a2;
        a2.instance = a1;
        a1 = null;
        a2 = null;
    }
}
```



**可达性分析**：从 GC roots 出发，如果某个对象无法到达，那么该对象没有被引用，那么可以回收



### 3.2、垃圾回收算法

---

**共有 4 种回收算法，如：标记-清除、复制算法、标记-整理、分代收集算法**



> 标记-清除



**过程：**

如字面意思，分为 标记 和 清除 两个阶段，首先一趟遍历，标记需要回收的对象，然后再一趟遍历，清除标记过的对象



**优点：**

。。。



**缺点：**

一个是效率问题，需要两趟遍历，效率不高

第二个是会产生内存碎片，零零散散的内存空间，如果遇到需要分配连续大内存的对象，那么如果全都是内存碎片而拿不出连续的大内存的话，就又会触发一次效率不高的 GC



这个算法是所有算法中的基础算法，后续的所有算法都是根据这个算法来进行优化的



> 复制算法



**过程：**

它将原本可用的内存空间划分为大小相等的两大块，每次只使用其中一块来进行内存分配，当需要触发 GC 时，就将这一块的不需要回收的对象 复制到另一块中去，然后再将这块使用过的内存空间全部清理掉



**优点：**

对象复制的过程中只需要按照内存顺序进行复制，只需要移动指针即可，不会产生内存碎片，简单高效





**缺点：**

将可用的堆内存分为了两半，即可用的相当于原来的一半了，内存减少，那么就可能会更多的 GC，某些长时间存活的对象每次都需要进行复制，效率会降低

![img](http://mmbiz.qpic.cn/mmbiz_png/PgqYrEEtEnqLYgY6g5DgUKYUPgXXTjorcDwjZkYkrJ4fpgTibYjMEDGVK81YIQWDpW0k1S9ibjxLvRz3848v91qg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



> 标记-整理



**过程：**

为了不想 像 复制算法那样浪费一半的内存空间，并且经常进行复制操作，那么就出现了 标记-整理 算法

标记还是更 标记-清除一样，一趟进行标记，然后后续不是对回收对象进行处理，而是将存活对象一个个按照顺序进行移动，紧靠着



**优点：**

不会产生内存碎片，并且相比 复制算法，一些长时间存活的对象如果靠着边界的话，是不会需要移动的，后续无需管它



**缺点：**

整理相比 清除 会花费更多的时间，但其实从长远来看，这是必要的，短时间的低效率是为了以后的高效率



![img](http://mmbiz.qpic.cn/mmbiz_png/PgqYrEEtEnqLYgY6g5DgUKYUPgXXTjorH0wLYIx1oZ7fGo2uNUgB6dwGLYV3h7pJtMgficMpicMOhUENpStgSCog/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



> 分代收集算法

GC 分代的假设：绝大多数的对象的生命周期都很短

因此将 Java 堆分为 新生代 和 老年代

对于新生代，由于每次 GC 都会存在大量的对象死去，因此使用复制算法，每次只需要复制少量存活的对象即可，效率

对于老年代，每次 GC 很少对象死去，因此使用 标记-清除 或 标记-整理算法



## 4、JVM 内存分配策略



JVM 内存分配 有 5 钟策略

**注：新生代划分为 伊甸区 和 两个幸存区**



> 对象优先进入新生代

大多数情况下，对象都是在 伊甸区 中分配内存，如果不存在连续内存进行分配的话，那么就会触发一次 GC



> 大对象直接进入老年代

大对象是需要大量连续的内存空间的，比如大数组和超长字符串，因此我们需要尽量避免这种短命大对象，避免占据了大量的空间导致触发 GC

对于多大的对象才直接进入老年代，可以通过参数设置



> 根据对象年龄判断是否进入老年代

所谓的年龄，如果经历过一次 GC 对象仍然存活，那么年龄 +1，如果没有存活，那么直接享年 x 岁

某个对象第一次经历 GC 存活时，会将该对象从 伊甸区 移动到幸存区，且对象年龄为 1，往后只要经历过 指定次 GC 还活着，那么就将该对象移动到 老年代



> 幸存区中相同年龄对象超过幸存区空间一半的，直接进入老年代

上述讲的 对象年龄到达阈值 才进入老年代的，其实并不是一定的，因为幸存区可能很多个对象都存活，并且都存活了很多次，那么我们可以根据这个判断条件，将相同年龄的对象数超过幸存区空间一半的时候，将大于等于该年龄的对象提前放入老年代



> 空间分配担保（这个就不太容易理解了，后续有时间再来理解吧）
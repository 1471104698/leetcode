# 钱老板加班（打印 N 个字符）

![1596450693636](C:\Users\蒜头王八\AppData\Roaming\Typora\typora-user-images\1596450693636.png)

## 题意描述

给定一个 N，通过 多个操作 得到 N 个字符，要求输出得到 N 个字符所需的最少按键数

有以下 5 个操作：

1. X : 如果当前选择了任何字符，那么将选中的字符替换为一个 X ,并取消选择； 否则打印一个 X。
2. CTRL + A : 选中当前已经打印的所有字符，如果已经选中则什么也不发生。
3. CTRL + C : 将当前选中的内容复制到剪贴板，如果没有选中，那就清空剪贴板。
4. CTRL + V : 将当前选中的内容替换为剪贴板中的内容，如果没有选中，则直接粘贴一份剪贴板内容。
5. ESC : 对当前选择的内容取消选中，如果没有选中的内容，什么也不发生。

**1、5 需要按键一次， 2、3、4 需要按键两次**



## 方法①、dp

### 实现思路

得到 N 个字符所需的最少按键数，可以划分为多个子问题，比如得到 1 个字符的最少按键数，2 个字符的最少案件数。。。当我们通过递推，得到 [1, N - 1] 个字符的最少按键数的时候，自然可以得到 N 个字符的最少按键数

存在一个最优解，使用 dp



#### **定义状态转移方程：**

##### 1、初步分析

我们需要从 1 个字符递推到 N 个字符，因此需要一个维度

复制粘贴需要知道对应的剪贴板的字符个数，因此需要一个维度

`dp[i][j]`表示当前需要得到 i 个字符，以及剪贴板存在 j 个字符 的 最少操作次数 

##### 2、5 种操作

我们不需要对操作定义一个维度，这道题我们可以看作类似 [72. 编辑距离](https://leetcode-cn.com/problems/edit-distance/)，对 `dp[i][j] `的进行各个操作取然后最小值即可

虽然看着有 5 种操作，但实际上只有 3 种

1. X 操作：添加一个字符
2. CTRL + V 操作：粘贴剪贴板内容
3. CTRL + A、CTRL + C、ESC 操作，这个应该是一套连贯的，即全选字符，然后复制，然后取消选中**（这个算是是一个难点，最开始我是拆分出来的，然后觉得这个 ESC 就没什么用。。。）**

##### 3、状态转移方程

**X**

X 操作不会改变剪贴板内容，因此保持不变，不过原有字符数 +1

```java
dp[i][j] = d[i - 1][j] + 1
```



**CTRL + V**

CTRL + V 操作不会改变剪贴板内容，不过会增加剪贴板的 j 个字符，
因此我们还需要获取在 剪贴板有 j 个字符的情况下 再获取 i - j 个字符的最少按键数 dp[i - j][j]

```java
dp[i][j] = dp[i - j][j] + 2
```



**CTRL + A、CTRL + C、ESC**

CTRL + A、CTRL + C、ESC 操作不会改变原有字符数，但是会改变剪贴板的字符数
需要注意的是，这一连贯的操作是获取当前所有的字符，然后放入剪贴板
这意味着只有在 i 个字符并且 剪贴板字符个数为 i 的情况下才能产生
即 dp[i][i] 才能进行该操作
因为如果 `dp[i][j] (i != j)`，如果进行该操作，那么你复制了 i 个字符到剪贴板，怎么可能剪贴板会存在 j 个字符，这是不存在的情况
因此，我们需要另外判断，只对` dp[i][i]` 进行该操作

```java
//j 表示剪贴板的字符个数，我们在存在 i 个字符，遍历剪贴板各个字符数的情况下的最小按键数下进行该操作
for(int j = 0; j < i; j++){
    dp[i][i] = Math.min(dp[i][i], dp[i][j] + 5);
}
```



### 实现代码

```java
class Solution {
    public int maxSum(int N) {
        
        int[][] dp = new int[N + 1][N + 1];
        //对于一些不能到达或者尚未处理的状态，我们设置为 大值
        final int MAX = (int) 1e9;
        for (int i = 0; i <= N; i++) {
            Arrays.fill(dp[i], MAX);
        }
        //需要 0 个字符，并且剪贴板字符为 0
        dp[0][0] = 0;
        
        //i：当前需要的字符数
        for (int i = 1; i <= N; i++) {
            //j：当前剪贴板的字符数，剪贴板的字符数不超过 i
            for (int j = 0; j < i; j++) {
                //执行 X 操作
                dp[i][j] = dp[i - 1][j] + 1;
                //执行 CTRL + V 操作
                dp[i][j] = Math.min(dp[i][j], dp[i - j][j] + 2);
            }
            for(int k = 0; k < i; k++){
                dp[i][i] = Math.min(dp[i][i], dp[i][k] + 5);
            }
        }
        int minStep = MAX;
        for (int i = 0; i <= N; i++) {
            minStep = Math.min(minStep, dp[N][i]);
        }
        return minStep;
    }
}
```


# 进程的调度算法

## 1、先进先出算法（FIFO）

最先来的先执行，在没有执行完成前，不会切换 CPU 



优点：

- 减少切换的开销
- 公平

缺点：

- 一个只需要 10ms 完成的 任务在 需要 1000ms 完成的任务后面到来，这样这个任务明明只需要 10ms 的时间这时候却需要 1010ms，而如果调换过来让这个 短任务先执行，长任务最多也只需要等待 10ms 而已

适用场景：队列中的任务耗时都差不多的场景



## 2、短作业优先

按照任务完成时长的长短进行排序，短的优先执行，这个任务的特点是需要提前知道所有任务的耗时才能进行排序，这里的时间长短是完成任务还需要的时间来算的，比如现在在执行一个 1 小时的任务，还剩 10s，而这时来了一个 1min 的任务，它还是会继续执行 1 小时的任务，因为它只需要 10s 就能完成



优点；

- 平均等待时间短，因为跟上面的 FIFO 算法比，把能够先完成的任务先完成了，这样就不会出现上面的 10ms 的任务需要等待 1000ms 的情况了

缺点：

- 耗时短的任务可能源源不断，而耗时长的任务得不到调度，**造成饥饿**
- 频繁的任务切换，需要多次切换进程上下文，开销大

适用场景：几乎无适用场景



## 3、时间片轮转算法

确定一个固定的时间片，每个任务调度的时间片是相同的，当时间片用完时，如果任务完成了，那么出队，如果任务还没完成，那么进入到队尾继续排队，当然，如果一个任务完成不需要一整个时间片，那么也会提前结束的、



优点：

- 每个任务都能得到公平的调度，不会出现上面的短任务等待时间长 以及 长任务饥饿 现象

缺点：

- 频繁的切换 任务，需要多次切换进程上下文，开销大
- 时间片不好设置（设置短了，频繁切换，设置长了，可能退还成 FIFO）

适用场景：队列中任务耗时差不多





## 4、多级反馈队列

兼顾了响应时间、调度开销低、避免饥饿问题、公平，在 windows、Linux 中都有使用



分为多个 level，每个 level 对应一个队列，从上到下优先级由高到低，时间片越来越长

位于高优先级的任务可以抢占低优先级的任务

最开始新任务位于最高位置的 队列，分配给它一个时间片，如果在这个时间片内完成任务，那么直接出队，如果没有完成任务，那么进入到下一个 level 的队列中，且分配的时间片比上一级的长一倍

只有当第 1 级的队列为空时，才会调度第 2 级的队列。。。

虽然对于长任务来说，一下子解决不了，需要等待的时间变长，但是分配的时间片也变成了

![img](https://pic4.zhimg.com/80/v2-8a100f3d3e2ba0d97b164b685b5ed394_720w.jpg)
# 锁

## 1、乐观锁和悲观锁



> ### 乐观锁 和 悲观锁 的概念



**悲观锁：**

将事物都想得很悲观，每个线程拿数据的时候都认为自己使用这个数据的期间别的线程都会进行修改，因此对这个数据加上锁，对别的线程进行排斥，比如 mysql 的写锁、表锁、行锁， 以及 java 中的  synchronized 和 ReentrantLock 等独占锁都是悲观锁的实现

悲观锁适用于多写的环境，因为这样才保证每次只有一个线程在修改，确保了数据的准确性



**乐观锁：**

将事物都想得很乐观，每个线程获取数据的时候都认为别人不会修改，因此不会对数据加锁，只会在写数据的时候判断数据是否被修改过，像 数据库中的 加个字段的版本控制 和 另一种 CAS 算法 都是乐观锁的实现，而 java 中 `AtomicIntger` 等原子类就是 volatile 修饰的 int 变量 + CAS

乐观锁不会对数据加锁，因此可以存在多个线程同时修改的情况，如果一直存在冲突，比如存在 n 个线程同时修改同个数据，那么最终只有一个线程会修改成功，其他的线程都需要进行自旋，获取最新的版本号进行重试，每次只有一个线程成功，效率过低

因此乐观锁适用于多读的情况



> ### 乐观锁的两种实现



这里需要说下，乐观锁在冲突的情况下，都需要进行自旋重试（重新获取版本号之类的，然后重新提交自己更新的数据）



**版本号控制：**

像 mysql 中同个给表添加一个 `version` 字段来代替 行锁 之类的悲观锁

当事务 A 和 事务 B 同时修改某个数据，而这个数据的初始版本号是 1 ，当事务 A 修改完率先提交，将版本号修改为 2，那么当事务 B 提交的时候，发现该数据的版本号跟自己持有的数据版本号不一样，那么就意味着被其他事务修改过了，那么就需要重新获取版本号来进行修改



**CAS 算法：**

CAS 即 compare And Swap（比较和交换）

它需要 3 个值：内存值 V，线程保存的旧值 A，需要写入的新值 B

其实跟 版本号控制差不多，感觉版本号控制就是 CAS 的一种实现，不过别人分出来了就不管了

**过程：**

假设存在一个变量 x，当线程 1 获取这个 x 的值保存为 A ，然后经过一系列的处理，需要将这个 变量 x 该为 值 B

这时候不能直接写入内存，而是需要比较 内存中 变量 x 的值 V 与之前获取它的时候的值 A 是否一致，如果一致，表示没有被其他线程修改过（其实不一定，这是 ABA 问题），可以直接将 x 更新为 B，如果不一致，那么就表示被其他线程修改过了，那么通过自旋不断重试



**CAS 的缺点：**

- 存在 ABA 问题
- 在存在冲突的情况下会自旋重试，而自旋的时候是不会主动放弃 CPU 的，那么当存在多个线程冲突的时候，CPU 效率低得一批



> ### 什么是 ABA 问题？

比如 线程 1  和 线程 2 同时要修改某个变量 x，当然，这是并发的，有先后顺序的，线程1 先被 CPU 调用，将 x 的值从 A 变成了 B，然后这时插进来 线程 3，CPU 没去调用线程 2，而是调用了 线程 3，而线程 3 将 x 的值 重新修改为 A，这时候 CPU 调用线程 2，线程 2 发现 x 在内存中的值 V 跟自己保存的旧值一样都是 A，那么感觉没人修改过，那么直接将 自己的新值 C 写入内存中

但实际上，在 线程 2 修改之前，就已经存在两个线程对变量 x 进行了修改，只是最终改回了原来的值，让线程 2 无法感知到它的变化

这就是 ABA 问题，表示从 A 修改为了 B，再从 B 修改回 A，这个中间过程不被感知



举个生活例子：

桌上有一杯水，它是满的，杯子的主人不在，当 人类 A 路过时，实在渴得不得了了，过来把它喝光了，然后就把空杯子放下走了

然后过来一个人类 B，发现杯子空了，很不爽，就把自己随身携带的水给杯子满上，然后就走了

当杯子的主人来的时候，看见杯子是满的，那么他不会想到有人喝了它的水再将它满上了，所以他放心地喝了

当然，他在他不知情的情况下，喝下了别人炙热的口水



> ### 如何 解决 ABA 问题？

通过添加一个版本号，（这就更像版本号控制那个了），之后的比较就不再是比较什么数据的内存值和旧值了，而是比较版本号了

上面的例子中，线程 1 修改了变量 x，将版本号 +1，之后线程  2 发现版本号不对，自然就感知到了 x 被修改过了，那么自旋重新修改



> ### ABA 问题有什么危害？

我们这么看老来，线程 1 修改了 x 值 从 A 变成 B，线程 3 又将 x 值从 B 变成 A，对于线程 2 来说，是需要将 x 值从 A 变成 C 的，那么这个 x 值最终是要变成 C 的，好像也没什么多大问题啊

这么看来是的，但是有的时候，这个中间态就可能产生不一样的影响，然而没有具体的例子，，，啧啧，这个 ABA 问题难点就在于没有一个实际的业务场景上的问题，有点理想化了



## 2、ReentrantLock（CAS + AQS）

ReentrantLock 使用了 CAS，我们上面说了 CAS  是乐观锁的一种实现，但这不意味着 ReentrantLock 就是乐观锁

因为i我们具体要看 ReentrantLock 到底是哪个地方用到了 CAS，并非用到了 CAS 就是乐观锁



**ReentrantLock 是一把悲观锁 和 可重入锁**，**同时也是 公平锁 和 非公平锁 的 实现**



### 2.1、ReentrantLock 的实现

------



**ReentrantLock 是一个可重入的悲观锁**

**ReentrantLock 通过 CAS + AQS 队列来实现**（AQS 队列 叫做 同步队列）



ReentrantLock 的实现可以简单描述为：

- ReentrantLock  内部维护了一个 volatile 修饰的 int 型变量 state
- 当 state == 0 时，表示还没有任何线程占有锁**（注意，这里的锁不是一个具象化的事物，而是根据 state 来判断的，只要 state 为 0 就当作是没有线程获得锁）**
- 当 state != 0 时，表示已经有线程获得锁
- 某个线程 使用 CAS 尝试获得锁时，如果 state 为 0，那么可以获得锁，并将 state +1，将锁的拥有者线程设置为自己
- 其他线程来尝试获取锁的时候，发现 state 不为 0，那么就会进入 AQS 队列进行等待，处于 挂起状态，CPU 不会在它们身上浪费时间

根据执行流程我们就可以看出，ReentrantLock 是一把悲观锁，它会阻塞其他的线程，即它对某个共享资源加锁的时候，其他的线程无法去修改这个资源，而是需要阻塞等待获取锁，而它使用的 CAS 就是用来判断是否有线程获得锁而已

而我们最上面讲的 乐观锁的 CAS ，是多个线程可以获取 共享资源 ，并对共享资源进行修改，不过每次修改的只有一个会成功，因此会进行自旋



**ReentrantLock 是在获取锁的时候使用 CAS，会阻塞线程，线程会挂起，CPU 不会在它们身上浪费时间**

**而 乐观锁的 CAS 是在修改的时候发挥作用，线程会进行自旋，CPU 会它们身上直到它们调用成功**



### 2.2、AQS 实现

---



**AQS 内部维护了一个 同步双向队列**

调用 lock() 获取锁然后失败的都会进去 同步队列中

而当线程释放锁的时候，如果没有线程插入，那么就会是队列的第一个线程获取锁，然后出队



> ### AQS 的默认 lock() 实现原理



```java
final void lock() {
    
    if (compareAndSetState(0, 1)) //直接 CAS
        setExclusiveOwnerThread(Thread.currentThread());
    else
        //上面直接 CAS 失败
        acquire(1);
}

public final void acquire(int arg) {
    if (!tryAcquire(arg) &&
        //前面获取锁失败，这里将线程放入 AQS 队列，addWaiter方法里调用 enq() 方法
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}

final boolean tryAcquire(int acquires) {
    //获取当前线程
    final Thread current = Thread.currentThread();
    //获取state变量值
    int c = getState();
    if (c == 0) { //没有线程占用锁
        if (compareAndSetState(0, acquires)) {
            //占用锁成功,设置独占线程为当前线程
            setExclusiveOwnerThread(current);
            return true;
        }
    } else if (current == getExclusiveOwnerThread()) { //当前线程已经占用该锁
        int nextc = c + acquires;
        if (nextc < 0) // overflow
            throw new Error("Maximum lock count exceeded");
        // 更新state值为新的重入次数
        setState(nextc);
        return true;
    }
    //获取锁失败
    return false;
}
```



当 某个线程调用 lock() 尝试获取锁，会先直接 CAS 一次，失败了就调用`tryAcquire()` ，里面 获取 state 变量

如果 state == 0, 那么再次进行 CAS 一次，如果失败直接返回 false

如果 state != 0，那么判断占有锁的线程是否是当前请求的线程，如果是，那么 state +1，**这就是可重入锁的原理**



**非公平的原因：**

只要有线程尝试获取锁，那么直接进行 CAS 尝试获取锁

这就是非公平锁的体现，当线程 A 释放锁的时候，lock() 它没有去判断 AQS 队列中是否有线程等待，如果这时候中途插入的线程尝试获取锁调用 lock()，并且获取成功了，那么对于早在队列中等待的线程来说就不公平了，甚至如果高并发的情况下，可能出现饥渴现象



> ### Node 入队 enq 代码



```java
/**
 * 初始化队列并且入队新节点
 */
private Node enq(final Node node) {
    //开始自旋
    for (;;) {
        Node t = tail;
        if (t == null) { // Must initialize
            // 如果tail为空,则新建一个head节点,并且tail指向head
            if (compareAndSetHead(new Node()))
                tail = head;
        } else {
            node.prev = t;
            // tail不为空,将新节点入队
            if (compareAndSetTail(t, node)) {
                t.next = node;
                return t;
            }
        }
    }
}
```



线程会在 addWaiter() 里被封装成一个 Node 节点，然后 调用 enq() 入队

```java
Node node = new Node(Thread.currentThread(), mode);
```



当线程 B 和 线程 C 都要入队时，由于是排在队尾，一次只能有一个线程入队成功，即每当一个线程入队成功， AQS 队尾元素就会更新入队成功的线程，所以需要进行 CAS + 自旋，直到所有线程入队成功

这里的 CAS 就是判断我们要入队的时候，队尾节点（内存值 V） 和 自己之前保存的队尾节点（旧值 A）是否一致，如果一致表示还没有被更新过，那么直接入队



> ### Node 出队 acquireQueued 代码



```java
final boolean acquireQueued(final Node node, int arg) {
    boolean failed = true;
    try {
        boolean interrupted = false;
        for (;;) {
            final Node p = node.predecessor();
            if (p == head && tryAcquire(arg)) {
                setHead(node);
                p.next = null; // help GC
                failed = false;
                return interrupted;
            }
            if (shouldParkAfterFailedAcquire(p, node) &&
                parkAndCheckInterrupt())
                interrupted = true;
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}
```



AQS 有一个头节点 head，它单纯的作为一个 dummy 指针，不存储任何数据

在队列中的节点通过 自旋来尝试获取锁，自旋过程如下：

- 判断自己的前驱节点是否是 head，如果是，表示轮到自己获取锁了，那么调用 tryAcquire() 获取锁
- 这里为什么 node 节点是对首节点却不能保证获取锁呢？因为这是一个非公平锁，可能线程插队先获取了锁，所以需要使用 CAS 来尝试获取锁
- 当获取锁成功后，将该节点的对应的线程设置为 锁拥有者，然后调用 `setHead(node)` 方法，将 node 作为一个新的 头节点 / dummy 节点



```java
private void setHead(Node node) {
    //将 node 设置为节点
    head = node;
    //对应的线程信息清空
    node.thread = null;
    //前驱节点情况
    node.prev = null;
}
```

因为我们说了，head 节点只是一个 dummy 节点，不在乎谁来当，所以对于使用过的 node 节点，我们情况它的内部数据后，它仍然跟后继节点相连，刚好可以直接作为 头节点



> ### AQS 的默认 unlock() 实现原理

```java
public void unlock() {
    sync.release(1);
}
  
public final boolean release(int arg) {
    if (tryRelease(arg)) {
        Node h = head;
        if (h != null && h.waitStatus != 0)
            unparkSuccessor(h);
        return true;
    }
    return false;
}

/**
 * 释放当前线程占用的锁
 * @param releases
 * @return 是否释放成功
 */
protected final boolean tryRelease(int releases) {
    // 计算释放后state值
    int c = getState() - releases;
    // 如果不是当前线程占用锁,那么抛出异常
    if (Thread.currentThread() != getExclusiveOwnerThread())
        throw new IllegalMonitorStateException();
    boolean free = false;
    if (c == 0) {
        // 锁被重入次数为0,表示释放成功
        free = true;
        // 清空独占线程
        setExclusiveOwnerThread(null);
    }
    // 更新state值
    setState(c);
    return free;
}
```



代码不难，当线程调用 unlock() 方法的时候，不会直接释放锁

由于 ReentrantLock 是一个可重入锁，因此当前线程的当前方法不一定是最后一个拥有锁的

当该线程的某个方法调用 unlock() 的时候，需要判断 state 减 1 后是否为 0

如果是，表示自己是最后一个拥有锁的，可以释放锁，同时将锁的拥有者线程设置为 null

如果不是，表示还有其他线程需要锁，所以不能释放锁



> ### 公平锁 lock() 实现原理

其实大部分代码公平锁和非公平锁的实现都是一样的

只是在 lock() 方法上做了一点修改

非公平锁是因为在 lock() 方法内直接判断 state 是否为 0，而不去管 AQS 队列内等待的线程，导致线程可以插队出现不公平

而公平锁的 lock() 并不是直接根据 state 状态来判断的，而是先获取 state，如果 state 为 0，那么再判断 AQS 队列是否为空，如果为空，那么再尝试进行 CAS 获取锁，如果 AQS 队列不为空，那么当前线程是不会获得锁的



```java
final void lock() {
    acquire(1);
}

public final void acquire(int arg) {
    if (!tryAcquire(arg) &&
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}

protected final boolean tryAcquire(int acquires) {
    final Thread current = Thread.currentThread();
    int c = getState();
    if (c == 0) {
        if (!hasQueuedPredecessors() &&
            compareAndSetState(0, acquires)) {
            setExclusiveOwnerThread(current);
            return true;
        }
    }
    else if (current == getExclusiveOwnerThread()) {
        int nextc = c + acquires;
        if (nextc < 0)
            throw new Error("Maximum lock count exceeded");
        setState(nextc);
        return true;
    }
    return false;
}
```



### 2.3、ReentrantLock 使用 CAS 的地方

---

最开始我犯了一个错误，我以为 ReentrantLock 在 获取锁、释放锁、线程入 AQS 队列的时候都用到了 CAS

但是实际上只有 获取锁、线程入 AQS 队列 的时候才需要用到 CAS，而释放锁不需要

释放锁 和 锁的可重入 都是一样的操作，直接 调用 `setState(nextc)`; 修改 state 即可, 而没有执行 CAS 操作

```java
protected final void setState(int newState) {
    state = newState;
}
```

这是因为释放锁的时候，锁必定是当前线程的，其他线程必定无法对 state 进行修改，那么可以直接对 state -1

而锁重入也是同样的道理，无需再去 CAS 了，因为锁都是自己的了，直接 对 state +1 就行了









## 3、synchronized 

关于 synchronized  的几个问题

- synchronized 原理
- synchronized 锁升级过程
- synchronized 是重量级锁，那有哪些轻量级锁



> ### synchronized 原理



**synchronized 最开始保证 线程安全 / 原子性 是因为它是一把重量级锁，会阻塞其他的线程**

**保证可见性就是因为线程在获取锁时会将工作内存清空，然后从内存中读取新的数据，释放锁前会将工作内存中的数据写回主存**



**synchronized 重量级锁的实现实际上是靠 Java 对象头**

Java 对象都是 存储在堆中的，而对象实例不仅仅只有用户写的代码，JVM 会自动添加一些额外的信息，来帮助一些事情，这些信息就构成了对象头

对象头包括：Mark Word、Klass Word、数组长度

- Mark Word 64 位，内部分割为多个部分，用来标记锁的状态、是否可 GC 回收、以及 `hashCode`
- Klass Word 标记了该对象在方法区中的 元数据，通过该指针确定是哪个类的实例
- 数组长度 是只有该对象为数组时才有的

 ![img](https://img-blog.csdnimg.cn/20190115141050902.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NDRE5fQ1A=,size_16,color_FFFFFF,t_70) 

 

而 synchronized 就是用到了 对象头中的 Mark Word  信息

最开始的 synchronized  是重量级锁，在 Mark Word 中只有 无锁 和 有锁（重量级锁） 两种状态

锁 的底层是 JVM 基于 monitor 对象来实现的，当某个代码块添加了 synchronized  关键字，那么在编译的时候，就是在代码块前面添加一条 `monitorenter` 指令表示加锁，在方法结束处 和 异常处 添加一条 `monitorexit` 指令表示释放锁

它内部还有一个计数器，当持有锁的线程再次需要获得锁的时候，可以直接获取，然后计数器 +1，当计数器为 0 的时候，那么释放锁（原理跟上面的 ReentrantLock 的可重入实现差不多）



> ### 锁升级过程

后续版本的 JDK 对 synchronized  进行了优化，使得 synchronized  的性能跟 ReentrantLock 差不多，差别主要是 ReentrantLock 用户能够自行释放锁

原本的 synchronized  只有两个状态：无锁，重量级锁；

后续再添加了两种状态，变成了 四种状态：**无锁、偏向锁、轻量级锁、重量级锁**

**偏向锁、轻量级锁 都是 乐观锁， 重量级锁 是 悲观锁**



偏向锁是 认为大多数的锁都不会存在竞争，一般都是由一个线程持有

轻量级锁是 认为两个线程使用锁的时间是错开的，即基本不会同时使用，最多也就通过 CAS 等待一会而已

重量级锁是 锁竞争激烈的情况下，为了不让 其他线程 CAS 浪费 CPU 空转，直接阻塞线程，同时它重量级的原因就是，阻塞了线程后需要去唤醒线程，然后再去切换线程，线程切换是用户态和内核态的切换，时间花费大

```java
这里说下什么是用户态，什么是内核态

用户态：把每个线程/进程当作一个用户，它们有自己独立的内存空间，即各个 进程/线程 的可访问空间是相互独立的，  CPU 只能受限的访问内存 

内核态：顾名思义，内核，是所有进程/线程 共享的，内核态是  CPU可以访问内存所有数据 

当某个线程 被 CPU 调度的时候，就是将线程从 用户态转换为内核态，即将数据复制到内核态当中，而执行完毕的线程又需要将数据从内核态复制到用户态当中

因此，频繁的线程上下文切换 会频繁的进行 用户态 和 内核态 之间的复制，时间花费太大
```



- 对象初始化的时候，没有被其他线程占有，那么这时**这个对象是 可偏向 状态**，也就是它只认为只有一个线程会来访问它，当**第一个线程来访问它的时候，它会通过 CAS 将自己的线程 ID 设置为该线程**，**该对象 从 可偏向状态 转换为 偏向 状态**，以后，改线程再来访问该对象时，只需要对比 ID 即可，如果一样则可以直接获取，无需 CAS
- 可能过了很久很久，当第二个线程来访问对象时，发现 该对象 是 偏向状态，表示在以前有线程访问这个对象了，导致它变成了 偏向状态，那么检查下该对象的 线程 ID 对应的线程 是否还存活（因为即使线程消亡了，对象的偏向状态也不会主动改变，需要别的线程来这样帮它改变），如果存活，那么检查下该线程是否仍然持有这个偏向锁，如果持有，那么该锁会升级为轻量级锁，此时锁仍由原来的线程持有，而第二个线程会 CAS 自旋，等待获取锁；；； 如果没有存活 或者 不持有，那么不会升级为轻量级锁，表示该对象可以重新偏向，将锁的 线程 ID 设置为 自己
- 当升级为轻量级锁后，如果 CAS 一段时间 第一个线程还没有释放锁，或者 有第三个线程来访问 了，那么就会升级为重量级锁，阻塞线程，避免不持有锁的其他线程 无意义的 CAS 自旋，浪费 CPU





## 4、JMM



> ### 背景介绍

早期的 CPU 的 速度 和 内存是差不多的， CPU 处理完 能很快写入内存

但是如今，CPU 的指令执行速度快得一批，内存的速度跟不上了，比如 1s CPU 需要写入 100 个数据，而 内存 1s 只能写入 1 个数据，这样的话，如果 CPU 就相当于降低速度去写数据，效率降低

为了解决这个问题，在 CPU 和 内存 中间引入了 cache，即高速缓存，它的速度跟 CPU 差不多，CPU 只需要将数据复制到 cache 中，然后去干自己的事，让 cache 慢慢将数据写入到内存中

需要注意的是：现在每台计算机不再是单核 CPU ，而是多核 CPU，每个 CPU 多对应一个自己的 cache

这样的话，就涉及到 **缓存一致性**

 ![img](https://pic2.zhimg.com/80/v2-3caf591483d67ccfd6ca01ef054a146f_720w.jpg) 

> ### JMM 是什么？

JMM 又叫 Java 内存模型，它跟 `jvm` 不一样啊。别搞错了啊。。。

它规定了 多线程对于 共享变量 的访问规则，以及将 共享变量 存储到内存，从内存中读取 共享变量 的底层细节



它会规定了 每个线程都有自己的工作内存，这个工作内存就跟上面的 CPU 对应的 cache 一样

每个线程对变量的操作都是在工作内存中，并且操作的是 内存中变量的副本，它不能直接操作内存中的变量，因为是共享的

操作完成，再将工作内存中的值写入到内存中

 ![img](https://picb.zhimg.com/80/v2-f0364f6f863d5730e2b962ac6b3387e2_720w.jpg) 





## 5、volatile



我们上面说了，JMM 规定了每个线程都有各自的工作内存，并且操作的都是在工作内存中的变量副本

正是因为这种模型，所以才存在数据可见性的问题

> ### 数据可见性问题

上面说了，线程操作的都是自己工作内存中的变量副本，而各个线程的工作内存又都是独立的，无法互相访问

并且它们从主存获取副本后，操作过程中基本不会再去访问主存

这样的话，当 线程 A 修改变量 x 后，写入到内存中，但是 线程 B 由于没有访问内存，它仍然使用的是在 自己工作内存中的旧值，这就导致了数据不可见



> ### 可见性问题的解决方案



**1、加锁**

因为当某个线程 获取  synchronized  锁后，会清空自己的工作内存，然后从主存中读取新的变量到工作内存中

然后再执行完代码后，将工作内存中的值重新写回主存，然后再释放锁

而获取不到锁的线程会阻塞，不会提前去读取主存，等到获取锁后再读取主存

这样的话就能保证数据是最新的

这个相当于是  synchronized 的底层原理



**2、volatile修饰共享变量**

当线程操作完某个变量 x 后，将 变量 x 从工作内存中写回 主存，当它发现这个变量是 volatile 修饰时，那么就会让其他线程的工作内存中的 缓存行失效（**注意，不只是 volatile 变量失效，而是缓存行里的所有数据**）

上面我们说了，线程在从主存中读取完内存后，基本不会再去访问主存，但是有一种情况除外，当它们发现自己工作内存的缓存失效，就会去访问主存，获取最新值

这就是 volatile 起到的作用



需要说明的是，之前一直以为失效的是 volatile 修饰的变量，没想到是缓存行失效，缓存行是很多数据，基本我们就认为是所有缓存都失效了（虽然没那么多，不过为了了解方便）



**那么是怎么发现数据失效的？**

通过总线嗅探，CPU 会通过嗅探在总线上传播的数据，发现过期了，那么就重新到主存中读取



volatile 保证了修饰变量的可见性，并且它还能 **禁止 指令重排序**

> ### 指令重排序

JVM 会将代码编译成一条条的指令，指令重排序就是 修改指令的执行顺序 来提高性能



**volatile 是怎么 禁止 指令重排序的呢？**

通过 happens-before 原则



> ### happens-before 规则

happens-before：翻译过来就是  发生在。。。之前

happens-before 规则 有很多条，其中有一条是：**一个线程对一个 volatile 的写必须先于其他线程对一个 volatile  的读**



在 JDK 1.5 的时候，对 volatile 变量是禁用缓存的，即线程无法缓存 volatile 变量，每次使用只能去主存里读，这样就保证了 volatile 变量一定都是最新值，但是这样明显效率很低

之后的 volatile 是通过禁止 volatile 变量与 普通变量的重排序，然后制定对应的规则来保证可见性

如下面的案例

```java
int a; //线程间共享变量
int b;
// 此变量必须定义为volatile
volatile boolean flag = false;

// 假设以下代码在线程A中执行
// 模拟读取配置信息，当读取完成后将initialized设置为true以通知其他线程配置可用configOptions = new HashMap();
a = 2;
b = 3;
flag = true;

// 假设以下代码在线程B中执行
// 等待 flag 为true，代表线程 A 已经把配置信息初始化完成
while (!flag) {    
    wait();
}
print(a);
print(b);
```

上面有两个线程，线程 A 中 flag 是 volatile 变量，因此会禁止 a = 2, b = 3 这两行代码 和 flag = true 这行代码重排序

即 flag = true 的执行必定是在 这两行代码之前，而 a = 2, b = 3 之间可以进行重排序

当 flag 执行完毕后，会将它前面代码的执行结果一并写入主存中，这样 线程 B 读取 flag 变量会清空自己的工作内存，然后去读取内存新值，这样 线程 A 修改的 a 和 b 的新值就能够被 线程 B 看见了

volatile 产生的作用就是

- 通过禁止 volatile 变量 和 普通变量的重排序，防止了 flag = true 在 a = 2，b = 3 代码之前执行
- 上述的禁止重排序就是因为 volatile 写入内存会将之前代码的执行结果一并写入主存，这样读取 volatile 变量的其他线程就能够看到之前修改的新值了，所以禁止重排序是为了修改的新值能够跟着 volatile 一起写入内存，一起被 其他线程 可见

这里需要说一点的是，上面线程 B 是在等待线程 A，但是如果对于高并发情况下，不会有这种 while(flag) 的情况，因此 volatile 是为了方便写完之后的其他线程能够直接读到新值，以及 已经读旧值的线程缓存过期，在需要使用的时候重新去主存读取新值



## 6、volatile、synchronized 和 lock 的区别和使用场景



> ### 单例模式中 volatile 和 synchronized  共同作用



在 8 种单例模式写法中，有这么一种写法：

```java
class Singleton{
    //volatile 修饰，保证可见性和禁止指令重排
    private volatile static Singleton instance = null;
    
    //构造方法私有化
    private Singleton(){}
    
    public static Singleton getInstance(){
		//双重检查
        if(instance == null){
            //锁住 Class 对象，类锁（同时还有对象锁，注意，对象有多个，Class 类只有一个）
            synchronized(Singleton.class){
                if(instance == null){
                    //赋值方法非原子性
                    instance = new Singleton();
                }
            }
        }
    }
}
```



**上面 volatile 有什么作用？**

很容易看出的是保证可见性，但是这个 禁止指令重排有什么作用呢？

我们需要先知道，上面那个赋值语句的执行 跟 i++ 一样不是原子性的，它分为如下操作：

- 分配内存空间
- 调用构造方法，创建实例对象
- 将对象所在地址返回给引用

如果发生指令重排的话，那么将 2 3 步调换，先分配内存空间，然后再直接将地址返回给引用，最后再创建实例对象

假设在将地址返回给引用，这时候 instance 引用指向了一个地址，不再为空

地址上的实例对象还没有创建的时候，这里也不说什么多线程和单线程，假设是单线程，那么到这一步前 CPU 调用其他的线程，发现 instance 不为空，那么直接拿去用了， 那么就自然存在空指针异常了，多线程同样问题

**注意：其他线程在判断的时候是在第一个判断 if(instance == null) 的时候发现不为空的，还没有到 synchronized，这时候跟 synchronized 保证的原子性无关**



**上面 synchronized 有什么作用？**

保证赋值语句的原子性，上面也说了赋值语句 本身是非原子性的

因此需要赋值语句来保证原子性，这个不用讲



简单讲，volatile 主要是禁止指令重排序，防止 其他线程在第一个 if 判断处获取一个空对象

synchronized 是保证赋值语句的原子性，不会多个线程创建多个对象，这就不是真正意义上的单例





> ### 三者的区别

我们上面都说了关于 volatile、synchronized 和 lock 的情况

volatile 保证可见性、禁止指令重排，但不能保证原子性，并且只能修饰 共享变量，在只需要保证可见性 或者 禁止指令重排的时候可以使用，比如 CAS 中的 state 和 单例模式 进行 赋值语句指令重排



synchronized 保证可见性（**线程获取锁前会清空工作内存，读取主存新值**） 和 原子性，可重入，并且有 偏向锁、轻量级锁、重量级锁 三种，会根据竞争情况进行锁升级，如果仅仅需要同步线程，而不需要什么其他操作，使用 synchronized  就行了

阻塞和唤醒方法为：wait() 和 notify()



lock 具有灵活性，同时也能够保证可见性（**由于 state 是 volatile 的，所以释放锁，即修改 state 的时候，会将前面的操作一并刷新入内存，这样其他线程就看得到了**）具体实现如 ReentrantLock，可重入，并且对应的可以配套使用 `lock.newCondition()` 来指定不同类型的锁对象，可以方便唤醒某种类型的线程，用于生产者消费者模式，而且**灵活性在于可以手动上锁和释放锁，并且可以指定等待锁的时间，不会死等**，里面的 tryLock() 方法在线程池中也用于判断线程是否是空闲状态

阻塞和唤醒方法为：await() 和 signal()



## 7、Condition 机制

> ### Condition 的介绍

Condition 是一个接口， AQS 里面的一个内部类 ConditionObject 实现了 Condition 接口，`lock.newCondition()` 实际上是创建了一个 ConditionObject 对象。

ConditionObject 类内部复用了 AQS 的 Node 类，即实际上是一个链表，或者说一个同步队列，又叫等待队列



我们需要知道：Condition 作为 AQS 的一个内部，那么自然就能够访问 AQS 的全局资源，这么说的理由是为了知道 Condition 能够访问到 AQS 的同步队列，这是一个重点，当 线程调用 await() 后，由于能够访问 同步队列，所以才能释放锁后，去唤醒同步队列中的线程去抢锁

await()：将线程封装成 Node 添加到等待队列中

signal()：将线程从等待队列中移除，放到同步队列中，等待获取锁



> ### await() 和 signal

await() 的主要逻辑就是：

- 将线程封装成 Node 节点，然后添加到条件队列的尾部（因为已经持有锁了，所以无需加锁）
- 释放锁，即将 减少 state 的值
- while 判断是否加入到 AQS 的同步队列中，如果不是，那么调用 park() 挂起，等待唤醒

```java
public final void await() throws InterruptedException {
    if (Thread.interrupted())
        throw new InterruptedException();
    
    //添加到队尾，里面是无锁方法，因为当前线程已经获取锁了，不存在竞争了，所以可以直接添加到队尾
    Node node = addConditionWaiter();
    //释放锁，锁就是 state，直接减 1
    int savedState = fullyRelease(node);
    
    int interruptMode = 0;
    
    //判断节点是否在 AQS 的同步队列中，如果不在，那么就挂起，等待 signal() 方法
    while (!isOnSyncQueue(node)) {
        LockSupport.park(this);
        if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
            break;
    }
    if (acquireQueued(node, savedState) && interruptMode != THROW_IE)
        interruptMode = REINTERRUPT;
    if (node.nextWaiter != null) // clean up if cancelled
        unlinkCancelledWaiters();
    if (interruptMode != 0)
        reportInterruptAfterWait(interruptMode);
}
```



signal() 也差不多，就是从等待队列中出队队首节点，然后放入到同步队列中，使用  CAS 尝试获取锁，如果同步队列中只有这一个节点，那么就是它获取锁了，其余没有获取锁的一段时间后应该就是重新回到等待队列了，等待下次的唤醒



> ### Condition 的 await() 、signal() 和 Object 的 wait()、notify() 的区别

Object 的 wait() 和 notify() 配合 synchronized  使用，只维护一个同步队列，无论是什么线程，如果竞争的是同一把 synchronized  锁，调用 wait() 后进入的就是同一个队列，它没有将队列分类，如果调用 signal() ，那么就是随机唤醒一个线程

在生产者消费者模式中，生产者线程 和 消费者线程 位于同一个队列，当消费者消费完后，调用 notify() 打算唤醒生产者线程，但是由于 notify() 是随机唤醒，所以唤醒的可能是消费者线程，而唤醒的消费者线程发生没有东西可消费，又会进入阻塞状态，这样效率过低



使用 Condition 主要就是能够将线程分类，每一个 condition 对象都维护一个同步队列

我们定义一个 consumer 和 一个 producer 类型的 condition，就相当于存在两个同步队列，生产者线程 调用 producer.await() 进入生产者同步队列进行阻塞等待，消费者线程调用 consumer.await() 进入消费者同步队列进行阻塞等待

当消费者消费完数据后，可以直接使用 producer.signal() 唤醒生产者线程，由于两个同步队列是独立的，因此唤醒的必定就是生产者线程了，在这种线程分类的环境下 效率更高
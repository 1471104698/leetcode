# mysql 基础语法



## **1、四个基本语句**

**select * from table** where xxx

**update table** set id = 1 where xxx

**delete from table** where xxx

**insert table** (x,xx,xxx) values (x,xx,xxx);

需要 from 的有 select 和 delete



## 2、清空表：

- truncate table_name
- delete from table_name
- drop table table_name

truncate table_name 是按照数据页删除数据的，不会记录 redo log 和 undo log 和 bin log，并且会重置自增 id，重新从 1 开始自增，但是 **truncate 不能清空有被其他表进行外键引用的表。**

delete from table_name 是由于不存在 where 条件，所以删除的是整个表的数据，实际上就是使用执行 用户 sql 的形式执行的，只不过没有指定 where 条件，它会开启事务，然后一条数据一条数据删除，会记录 redo log、undo log、bin log，自增值 id 也不会改变

drop table table_name 是删除表，整个表都删除了



总结：

- drop 是删除表，不会保存表结构
- truncate 是清空表，删除的单位是数据页，因此速度比 delete 快，但是会保留表结构，重置自增 id
- delete 是按照事务的方式一条一条删除数据行，速度慢，会记录 日志，不会重置自增 id



## 3、Sql 语句执行过程

具体看  https://zhuanlan.zhihu.com/p/95082274 

 https://zhuanlan.zhihu.com/p/70295845 



以下是 select 语句的执行流程：

 ![img](https://pic1.zhimg.com/80/v2-28ed550e0fcf925829ea167508e01d78_720w.jpg) 

流程包括以下几个步骤：

- 连接
- 查询缓存
- 语法解析器和预处理
- 查询优化器
- 执行计划



> ### 1、连接

当服务器发送请求时，数据库和服务器之间会建立 TCP 连接

数据库和服务器之间的连接是 **半双工** 的，这意味着同一时间只能有一方发送数据，一方接收数据，不能同时进行

由于是 TCP 连接，所以为了防止无限制的建立连接并且频繁的创建和销毁连接，使得数据库崩溃或者降低效率，所以需要使用数据库连接池管理和复用连接（参考线程池），因此数据库并发度是看数据库连接池的连接数量的



> ### 2、查询缓存

数据库内部维护了一个缓冲区，先从缓冲区中查询是否存在数据 （一个大小写敏感的哈希表实现的） ，如果存在则直接返回，如果不存在则执行 sql 解析



> ### 3、语法解析器和预处理

语法解析器是解析 mysql 关键字，查看是否存在错误的关键字、关键字顺序是否正确

要是 sql 语句存在错误，那么就会收到如下提示：

```
You have an error in your SQL syntax
```



当语法解析器通过后，就会将 sql 语句传送给 预处理器

预处理是根据 mysql 的规则检查 sql 语句是否合法，比如 表 和 字段是否存在

如果存在字段错误之类的，那么就会收到如下提示：

```
Unknown column xxx in ‘where clause’
```



总的来说，**语法解析器解析的是下面的 绿色字段，预处理器解析的是下面的灰色字段**

 ![img](https://pic3.zhimg.com/v2-9d878461f3c58523bfdea526d6ac3966_b.jpg)

> ### 4、查询优化器

查询优化器收到的是 预处理器发送过来的 **语法树**，因此也是在 语法树的基础上进行优化

查询优化器的作用就是将 sql 语句转换为执行计划，一条 sql 语句存在不同的查询方式，比如使用哪个索引之类的，最终返回的结果都是相同的，但是执行的效率不同

查询优化器的作用就是找到执行效率最高，成本最低的执行计划



> ### 5、执行计划

执行器收到从 查询优化器 发送过来的执行计划，此时就会按照执行计划一步步执行

最后，mysql 会将查询结果返回







## 4、Mysql 查询优化

1、给频繁查询的列 加索引

2、使用 %abc% 之类的查询，可以考虑使用全文索引

3、避免 where a + 1 = 2 这种 = 左边的 函数 或者 表达式操作，它会导致索引失效

4、建立联合索引的时候，**区分度 高的在前，这样能够过滤掉更多的数据**（对于慢 sql，就是很难在短时间内过滤掉不需要的数据，其中一个原因就是联合索引建立的区分度不对）

5、避免给经常修改的列加索引

6、对于定长字段使用 char 而不是 varchar，因为 char 定长的检索会更快，而 varchar 的话需要先读取字符串长度偏移量，再根据偏移量获取数据

7、只含数字的列就使用 int 型，因为如果使用 char 的话会比较的时候是一个字符一个字符进行比较的，而 int 这种只需要比较一次

8、查询的时候如果知道具体需要的字段，并且加上了索引，避免使用 select *，用具体的字段代替 *，最好满足覆盖索引
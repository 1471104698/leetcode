# 进程间的通信方式



## 进程预知识

> ### 用户态和内核态的区别？用户态切内核态有哪些情况？

从 Linux 的角度看，物理内存分为两块：用户态 和 内核态

比如物理内存有 4G，那么 1G 作为用户态，3G 作为内核态

1. 内核态，由操作系统内核操作，读写磁盘，读写网络都是由这负责
2. 用户态，用户程序能访问到的部分，只能访问受限资源，不能访问内存等硬件设备，需要通过系统调用内核，才能访问



用户态和内核态主要是权限不同，用户态的权限最低，它能访问的资源很少，内核态权限最高，可以直接访问所有资源



**系统调用：就是只能由操作系统调用的指令，跟普通的用户程序调用不一样，比如用户程序读写磁盘，就是需要内核中的系统带哦用来执行。**用户程序只在用户态下运行，有时需要访问系统核心功能，这时通过系统调用接口使用系统调用。



当需要读写磁盘等操作时，CPU 寄存器存储着用户态指令执行的位置，因为需要读写操作需要切换到内核态，所以需要先保存用户态指令位置，然后将内核态的指令位置更新到寄存器中，然后切换到内核态执行读写操作，然后 寄存器恢复 用户态的指令位置，切换到用户态，将内核态的数据拷贝到用户态，对于 java 来说，此时数据还不是在堆中，所以需要再执行一次拷贝到堆中的操作



**用户态切内核态的情况有：系统调用、异常、中断**



> ### 进程上下文切换

进程的上下文包括了虚拟内存、栈、全局变量、指令寄存器等，每个进程的上下文都是独立的，所以切换的时候需要先保存当前进程的上下文，然后将下一个进程的上下文刷新进来



> ### 线程上下文切换

对于同一个进程中的多个线程，虚拟内存 和 全局变量等资源是共享的，所以无需进行切换，但是每个线程都有自己独立的 工作内存（栈 和 指令寄存器），所以这些需要进行保存和更新

对于不同进程中的线程切换，那么所有东西都是不共享的，那么切换就跟进程上下文切换一样了



## 1、管道

管道有两种：匿名管道 和 命名管道(FIFO)



#### 匿名管道

---



如果学过 Linux 命令，那你肯定很熟悉 「`|`」 这个竖线。

```
$ ps auxf | grep mysql
```

上面这个命令行中，「`|`」就是一个管道，它的功能是将前一个命令（`ps auxf`）的 输出 发送给后一个命令（`grep mysql`），这里我们可以看出 **管道的传输方向是单向的**，即默认是从前一个指定的进程传输到后一个指定的进程

上面这种管道是没有名字，所以「`|`」表示的管道称为**匿名管道**，用完了就销毁。



#### 命名管道

---

使用 `mkfifo` 命令创建管道文件

```
$ mkfifo myPipe
```

上面的 `myPipe` 就是管道名字，它是文件是形式存在的

通过 ls -l 可以查看这个文件

```
$ ls -l
prw-r--r--. 1 root    root         0 Jul 17 02:45 myPipe
```

接下来，可以往 `myPipe` 中写入数据

```
$echo "hello" > myPipe //往 myPipe 管道文件中写入 "hello"
//。。。阻塞
```

但是我们可以看出，写入数据后进入阻塞状态，这是因为需要另一个进程去读取数据

执行另一个命令来读取数据

```
$ cat < myPipe  // 读取管道里的数据
hello
```

这时候之前的命令就不会阻塞了



我们可以看出：

管道实现简单，适合用户进行操作，比如用户自己执行` ps xxx | xxx`

但是不适合进程间自己的通信，因为发数据后需要等待对方接收数据，不然就会阻塞，干不了其他的事，**管道这种通信方式效率低，不适合进程间频繁地交换数据**。

同时也我们很容易得知管道里的数据已经被另一个进程读取了，因为如果没有被读取，那么就会阻塞



#### 管道实现原理

---

我们可以看出，**匿名管道** 实际上就是内核空间中的一段缓存空间，它不是文件的形式

由于内核空间是进程共享的，因此进程可以直接通过这段缓存进行通信



匿名管道的创建实际上内部是调用下面这个函数

```
int pipe(int fd[2])
```

我们可以看出，有一个大小为  2 的 int 型数组，`fd[0] `是读取描述符，`fd[1] `是写入描述符

由于管道是单向的，并且匿名管道只是一段缓存，它不是文件形式存在的，

因此创建 匿名管道 后，需要同时指定通信的进程，哪个是写入，哪个是读取，用完就销毁

![img](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZckxn1SzJ697nE1m1wJzmPQmsrxa4AwDelPGglhe3DMPTKEpmGW7icSDnozDo7plETZlTWQJmcDVug/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



注意：匿名管道只能用于父子进程间的通信，当父进程调用 pipe() 函数后，那么这个文件描述符是位于父进程的，怎么进行进程间的通信？

实际上需要通过 fork() 函数创建子进程，然后子进程也复制了父进程的文件描述符，因此就可以一个使用 `fd[0]`，一个使用` fd[1]`

![img](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZckxn1SzJ697nE1m1wJzmPQgD8dzOZUnAfmVVndTmtGgZRNZsBFEYghLPBjicziam2E1iapicANMYRXbg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



>  为什么匿名管道只能用于父子进程？而命名管道可以用于任何进程间的通信，这是怎么个说法呢？

匿名管道是存在于内存当中的，相当于我们创建了一个类的实体对象，这个类没有设置 set() ，也将变量设置为 private，不能更改，所以一旦定义，那么只能用于固定的两个进程

而命名管道是文件形式存在的，是存在于磁盘中的静态文件，相当于我们自己写的代码，类的模板，一旦我们要进行进程间的通信，那么就创建一个实体类对象，然后可以任意指定两个进程，用完后销毁这个实体类对象，但是类模板还在

这里再说一句：**管道这种通信方式由于进程会阻塞，所以效率低，不适合进程间频繁地交换数据**。



**管道的缺点：**

- 使用管道进程会阻塞，不适合频繁的交换数据

- 只能单向传输，如果要双向通信，那么需要创建两个管道

- 匿名管道只能使用在父子进程，命名管道

  

## 2、消息队列 

管道不适合进程间的频繁通信，因为进程会阻塞，效率低

而消息队列就能够解决这个问题

消息对队列是保存在内核中的消息链表，进程间的通信数据结构就是 数据块（类似链表的 Node 节点）

当进程 A 要给进程 B 发消息时，将数据封装在数据块中，然后放入消息队列，然后就可以返回做其他事了

而进程 B 需要的时候再去读取数据就可以了

类似我们平时发的电子邮件，你一封我一封，可以频繁交流

但是这种邮件形式的方式也有缺点：

- 一是信息不具有即时性，由于邮件什么的什么时候都可以看，因此可能今天看的这封邮件是几天前发的

- 二是邮件大小也有限制

我们上面说了，数据是封装在 数据块的，它也是一种数据结构，那么内部肯定是使用数组实现的，那么就有对应的大小限制

**消息队列不适合大数据的传输**



 **消息队列通信过程中，存在用户态与内核态之间的数据拷贝开销**，因为消息队列是在内核中的，因此进程 A 将数据写入内核中的消息队列，那么就是将数据复制一份到内核中，即存在用户态拷贝内核态的过程（可能这个过程不是我们写代码简单的复制，需要切换之类的，比较麻烦），然后进程 B 从内核中的消息队列再读取数据，又发生从内核态到用户态的数据拷贝



**消息队列的缺点：**

- 由于内部是封装数据块的，是使用数据来传输数组的，那么存在大小限制，不适合大数据的传输
- 读取和写入都存在用户态和内核态的数据拷贝开销

## 3、共享内存

消息队列 的读取和写入 需要 用户态和内核态的  数据拷贝的花销，而 **共享内存很好的解决了这个问题**



现在的操作系统都是使用虚拟内存的技术，即对于进程来说，每个进程都有自己独立的虚拟空间，它们映射到不用的物理地址

即使 进程 A 和 进程 B 的虚拟地址是一样的，对应的物理空间也不一样



而共享内存的机制，就是 从 进程 A 和 进程 B 中都 拿出一块虚拟地址空间，映射到同一块物理地址

这样的话，进程 A 写入数据，进程 B 里面就能看到了，也无需拷贝来拷贝去，直接就可以获取

 ![img](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZckxn1SzJ697nE1m1wJzmPQicu3anA4icCr5sY8I4CWsXBUSsGQQGlWuWgNSNJThhyNrpaourrwITQQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1) 





**共享内存的缺点：**

- 会导致数据错乱，当多个进程同时修改一个共享内存，那么比如两个进程同时写一个地址，那么先写的那一个进行会发现被后面的覆盖了



## 4、信号量（PV）

共享内存存在进程不安全的问题，即会发生数据错乱，因此需要保护机制，**保证共享内存一次只能由一个进程访问**

**而这就是 信号量**

信号量涉及两个操作：P 和 V

P 操作是将可用资源数 -1，V 操作是将可用资源数 + 1

**过程：**

- 信号量初始化为 1
- 当 进程  A 先到达时，执行 P 操作，发现信号量为 0，那么可以访问数据

- 当 进程 B 到达的时候，执行 P 操作，发现信号量为 -1，那么陷入阻塞状态

- 等到 进程 A 访问完数据，执行 V 操作，信号量 +1，变成 0，唤醒 进程 B
- 进程 B 访问完数据，执行 V 操作，信号量 +1，变成 1

这样做就很好的保护了共享内存



上面这个是信号量用来互斥的，但有时我们就需要实现 生产者-消费者模式，同样可以使用 PV 来实现

比如 进程 A 是生产者，进程 B 是消费者

 ![img](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZckxn1SzJ697nE1m1wJzmPQlO6zu8K0xlLpDBbew0jVibibhVm59TQy4ibJSZKxqKsWOrcLIibZE6RAVg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1) 

**过程：**

- 信号量初始化为 0，表示当前无数据 可消费
- 如果 进程 B 先执行 P 操作，发现信号量为 -1，那么进入阻塞状态
- 之后 进程 A 执行，生产数据，然后执行 V 操作，信号量 +1，变成 0，唤醒 进程 B 进行消费



## 5、信号（异常情况下的通信- kill、中断信号）

**上面的几种通信方式，都是正常情况下的通信方式，而在异常情况下的通信方式，就只能使用 信号**

比如我们使用的 kill 命令，就是使用的信号，给要终止的进程发送一个信号，告诉它进程要终止运行了



## 6、Socket（不同主机通信）

上面的几种通信方式，都是在同一台主机上面的进程间的通信方式

如果要跨网络或者主机，就要使用 socket 通信



根据 通信类型可以分为：一个是基于 TCP 协议的通信方式，一个是基于 UDP 协议的通信方式，一个是本地进程间通信方式。



## 总结

由于每个进程的用户空间都是独立的，不能相互访问，这时就需要借助内核空间来实现进程间通信，原因很简单，每个进程都是共享一个内核空间。

Linux 内核提供了不少进程间通信的方式，其中最简单的方式就是管道，管道分为「匿名管道」和「命名管道」。

**匿名管道**顾名思义，它没有名字标识，匿名管道是特殊文件只存在于内存，没有存在于文件系统中，shell 命令中的「`|`」竖线就是匿名管道，通信的数据是**无格式的流并且大小受限**，通信的方式是**单向**的，数据只能在一个方向上流动，如果要双向通信，需要创建两个管道，再来**匿名管道是只能用于存在父子关系的进程间通信**，匿名管道的生命周期随着进程创建而建立，随着进程终止而消失。

**命名管道**突破了匿名管道只能在亲缘关系进程间的通信限制，因为使用命名管道的前提，需要在文件系统创建一个类型为 p 的设备文件，那么毫无关系的进程就可以通过这个设备文件进行通信。另外，不管是匿名管道还是命名管道，进程写入的数据都是**缓存在内核**中，另一个进程读取数据时候自然也是从内核中获取，同时通信数据都遵循**先进先出**原则，不支持 lseek 之类的文件定位操作。

**消息队列**克服了管道通信的数据是无格式的字节流的问题，消息队列实际上是保存在内核的「消息链表」，消息队列的消息体是可以用户自定义的数据类型，发送数据时，会被分成一个一个独立的消息体，当然接收数据时，也要与发送方发送的消息体的数据类型保持一致，这样才能保证读取的数据是正确的。消息队列通信的速度不是最及时的，毕竟**每次数据的写入和读取都需要经过用户态与内核态之间的拷贝过程。**

**共享内存**可以解决消息队列通信中用户态与内核态之间数据拷贝过程带来的开销，**它直接分配一个共享空间，每个进程都可以直接访问**，就像访问进程自己的空间一样快捷方便，不需要陷入内核态或者系统调用，大大提高了通信的速度，享有**最快**的进程间通信方式之名。但是便捷高效的共享内存通信，**带来新的问题，多进程竞争同个共享资源会造成数据的错乱。**

那么，就需要**信号量**来保护共享资源，以确保任何时刻只能有一个进程访问共享资源，这种方式就是互斥访问。**信号量不仅可以实现访问的互斥性，还可以实现进程间的同步**，信号量其实是一个计数器，表示的是资源个数，其值可以通过两个原子操作来控制，分别是 **P 操作和 V 操作**。

与信号量名字很相似的叫**信号**，它俩名字虽然相似，但功能一点儿都不一样。信号是进程间通信机制中**唯一的异步通信机制**，信号可以在应用进程和内核之间直接交互，内核也可以利用信号来通知用户空间的进程发生了哪些系统事件，信号事件的来源主要有硬件来源（如键盘 Cltr+C ）和软件来源（如 kill 命令），一旦有信号发生，**进程有三种方式响应信号 1. 执行默认操作、2. 捕捉信号、3. 忽略信号**。有两个信号是应用进程无法捕捉和忽略的，即 `SIGKILL` 和 `SEGSTOP`，这是为了方便我们能在任何时候结束或停止某个进程。

前面说到的通信机制，都是工作于同一台主机，如果**要与不同主机的进程间通信，那么就需要 Socket 通信了**。Socket 实际上不仅用于不同的主机进程间通信，还可以用于本地主机进程间通信，可根据创建 Socket 的类型不同，分为三种常见的通信方式，一个是基于 TCP 协议的通信方式，一个是基于 UDP 协议的通信方式，一个是本地进程间通信方式。

以上，就是进程间通信的主要机制了。你可能会问了，那线程通信间的方式呢？

同个进程下的线程之间都是共享进程的资源，只要是共享变量都可以做到线程间通信，比如全局变量，所以对于线程间关注的不是通信方式，而是关注多线程竞争共享资源的问题，信号量也同样可以在线程间实现互斥与同步：

- 互斥的方式，可保证任意时刻只有一个线程访问共享资源；
- 同步的方式，可保证线程 A 应在线程 B 之前执行；
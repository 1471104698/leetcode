# TCP 的可靠性实现



## TCP 可靠性 靠什么实现？

这里的可靠性不是说三次握手、四次挥手，而是连接完成后，中间的数据传输

**TCP 的可靠性是通过 确认应答机制、超时重传机制、滑动窗口、流量控制、拥塞控制 实现的**



## 1、确认应答机制

TCP 是面向字节流的传输，对每个字节都进行了编号

比如 客户端 这次传输了 [1,100]，那么序列号就是 1，然后服务端接收后发送一个 ACK = 101 ，表示下次期望收到 101 的序列号数据报

 ![img](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeuicRMlA8rKvl5AVLibhibDhg7rhicME5YSPXZCicwvDpdicChuibpe3AbuavGsDNz5ibPIicibF6wiaJHlKlFQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1) 



## 2、超时重传

我们前面也说了，每次接收到数据都需要发送一个 ACK ，如果客户端发送数据给服务端后，在一定时间内没有收到服务端的 ACK，那么就会认为重新发送数据

有两种情况：

- 客户端发送的数据包丢失，服务端没有接受到，所以没有发送 ACK
- 服务端发送的 确认应答 ACK 丢失

这两种情况都会导致客户端重新发送数据

 ![img](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeuicRMlA8rKvl5AVLibhibDhgObdlvOJianvD0oj586rMc8wVs4hlzUtgRibWfD0WBpAJhRtHxOPd9ibibQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1) 



## 3、滑动窗口

#### 1、使用窗口前的数据发送方式

TCP 是每发送一次数据，都要进行一次应答确认，即得到 上一个数据包的 应答，才发送下一个数据包

这也是 TCP 的可靠性之一

如果每次数据发送的大小都是一个 TCP 段的话，那么就有点像你我两个人聊天，你一句我一句的，你说我回，我回了你才能继续说

如果你说了一句话，而我在干别的事，那么你需要等待我干完，你还必须重新说那句话，这样效率低下

*![image.png](https://pic.leetcode-cn.com/1597982380-WwqbeW-image.png)*



#### 2、滑窗窗口

> 为什么需要滑动窗口

因为 TCP 使用了确认应答机制，每发送一次数据都需要接收到 ACK 后再发送下一部分数据，效率过低

因此，引入了滑动窗口，根据接收端（注意，不一定是服务端）的接收处理能力，来发送多部分数据



当使用窗口的时候，无需等待收到确认应答，只要在窗口大小内还有可发送数据，那么可以直接发送

窗口的实现实际上是操作系统内部的一个缓存空间，当你发送出数据后，直到收到确认应答，才可以删除对应的数据缓存，否则，那么需要根据缓存的数据进行重发

比如下面的，发送了 【100， 700】，如果 服务端处理完 【500，599】 后发送的 ACK 丢失了，即客户端没有收到确认应答，但是，后面收到了 700 的 ACK，那么表示 700 前面的数据都处理完毕了，无需等待 600 的 ACK

但是，如果这里只发送了 【100，599】，却没有收到 600 的 ACK，但是收到了 500 的 ACK，那么就需要从缓存中获取 【500，599】 的数据重新发送

**这种叫做累计确认**



*![image.png](https://pic.leetcode-cn.com/1597993414-gESvQl-image.png)*



#### 3、窗口大小由哪一方决定？

TCP 中有 窗口大小  这个字段，是接收方告诉发送方自己现在还能接收多少数据，

那么发送端就可以根据服务端的接收能力来发送对应大小的数据，而不会一股脑的发送数据，超出服务端的处理能力

因此窗口大小由接收端决定



#### 4、发送方的滑动窗口

发送方的窗口分为四个部分：

- 已发送并且已经收到 ACK（处理完毕， #1： 1 - 31 字节）

- 已发送但未收到 ACK（服务端尚未处理完毕，或者 ACK 还在路上，#2：32 - 45 字节）

- 未发送但是可以发送（服务端还能接收数据，这些数据现在可以发送给服务端，但是现在还没有发送，

  #3 ：46 - 51 字节）

- 未发现并且现在不能发送（后面的这些数据不能发送，因为超出了服务端的接收能力，#4 ：52 - 56 字节）



*![image.png](https://pic.leetcode-cn.com/1597993856-goRUji-image.png)*



如果 32 - 36 字节收到 ACK 后，那么缓存空间中会删除掉这些数据，并且窗口会往右边移动，到达 56

*![image.png](https://pic.leetcode-cn.com/1597994071-LvuLnd-image.png)*



滑动窗口 4 个部分的表示是使用 3 个指针来区分的，即相当于我们使用 write 和 read 指针来压缩字符串一样

SND.WND：窗口大小变量

SND.UNA：第一个指针，位于窗口的第一个字节，表示窗口的起始位置

SND.NXT：已发送数据的末尾位置，同时也是可发送数据的起始位置，SND.NXT - SND.UNA 即为 #2 的大小

*![image.png](https://pic.leetcode-cn.com/1597994129-NGveQS-image.png)*



#### 5、接收方的滑动窗口

没啥好说的，比较简单

*![image.png](https://pic.leetcode-cn.com/1597994365-FJXXeT-image.png)*





## 4、流量控制

流量控制是基于滑动窗口的， 发送方不能无脑的发数据给接收方，要考虑接收方处理能力。 

如果一直无脑的发数据给对方，但对方处理不过来，那么就会导致触发重发机制，从而导致网络流量的无端的浪费。

为了解决这种现象发生，**TCP 提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量，这就是所谓的流量控制。**



就是我们上面说的，接收方每次接收到发送方的数据后，会告知发送方现在的可接受窗口大小，发送方根据这个窗口大小来发送对应大小的数据



## 5、拥塞控制

前面的流量控制是避免发送方一股脑的发送数据，导致接收方处理不过来

但是流量控制并不会去在意网络中的环境，它只考虑接收方的问题



**计算机网络都处在一个共享的环境。因此也有可能会因为其他主机之间的通信使得网络拥堵。** 

**如果网络拥堵的话，发送方继续发送大数据，那么很可能会导致数据包延迟、丢失等问题，这时候发送方会超时重传，继续发送大数据，但是一旦重传，又会加重网络拥堵，导致更多数据丢包，然后又重传，恶性循环不断加大**



因此，出现了拥塞控制

> 慢启动

TCP 在最开始建立好连接后，不会立马发送大数据，而是会一点一点提高数据量

比如最开始发送大小为 1 的数据报，收到 ACK 后发送 大小为 2 的数据报。。。

然后发送 大小为 4、8、16 的数据报。。。

就是一点一点增大

增大到某个设定的值后就进入拥塞避免算法
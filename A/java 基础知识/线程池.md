# 线程池



## 1、为什么使用线程池？

(关于线程 和 进程，看 进程 和 线程 的基础 中的 6 、总结)



传统的线程使用，都是需要的时候就创建一个线程，执行完任务后，将线程进行销毁

这里面有两个开销：创建线程的开销 和 销毁线程的开销，都是需要 CPU 执行的

当高并发的情况下，大多数的任务都是短时间内可以完成的，这样频繁的执行和销毁只会降低效率，说夸张点，假设一个线程的创建和销毁需要 1s，那么 高并发 情况下 1s 可能有 10W 个请求，那么创建 10W 个线程，到时候创建销毁需要 10W s，这就不得了了

这一方面没有控制线程的数量，10 W 个线程，内存哪里顶得住，一方面是频繁的创建和销毁，CPU 都浪费时间，降低效率



因此，需要线程池来解决

线程池 能够指定线程的数量，因此不会创建太多的线程，同时创建的线程不会用完即毁，而是能够复用

这样就基本解决了上面的两个问题





## 2、线程池的参数

- `corePoolSize`：核心线程数，创建了线程池后，内部是没有线程的，当然可以调用 `prestartAllCoreThreads() `或者 `prestartCoreThread() ` 来预创建线程，这样任务到达就可以直接执行了，如果没有这么做，那么只有在任务到达的时候，查看是否有空余线程，如果没有，那么创建一个线程来让这个任务执行，当已经创建的线程数等于 指定的 `corePoolSize` 时，那么就不会再创建线程了，而是将任务放入到任务队列中，等其他线程执行完毕再来这个任务队列中调用任务继续执行
- `maximumPoolSize`：线程池允许创建的最大线程数，上面说了，线程数到 `corePoolSize` 个数时，就会将任务放到任务队列，当然也不是一直放，任务队列有一个指定大小的，当任务队列满了之后，就会再次创建线程，而这次的最大边界就是这里指定的 `maximumPoolSize`，当线程池中线程数到达这个数量时，之后就不会再创建线程了，除非销毁掉一些旧的线程
- `keepAliveTime`：线程空闲时间，也可以叫空闲存活时间，当线程没事干呆在线程池的时候，超过这个时间就会销毁了，一般这个销毁的是超过 `corePoolSize` 个数的线程，`corePoolSize`个数内的线程是不会销毁的
- `unit`：时间单位，显然是跟上面那个存活时间共用的
- `workQueue`：任务队列，就是上面说的，没有线程可以调用时任务存放的队列，**都是阻塞队列**
  - `ArrayBlockingQueue`：基于数组结构的阻塞队列，空间大小有限，阻塞就是线程来拿任务，发现没有任务就是处于阻塞状态，进入空闲时间
  - `LinkedBlockingQueue`：基于链表结构的阻塞队列，空间大小有限。`newFixedThreadPool()` 就是使用该队列
  - `SynchronousQueue`：同步队列，没有存储空间，当向线程池提交一个任务的时候，如果线程池没有空闲线程，那么重新开一个线程来允许该任务。`newCachedThreadPool()` 就是使用该队列
  - `PriorityBlockingQueue`：基于元素优先级排序的阻塞队列，空间大小无限
- `threadFactory`：创建线程的工厂，可以通过线程工厂在创建线程时赋予线程更有意义的名字
- `handler`：拒绝策略，当线程池内的线程数达到 max 级别，并且任务队列内的元素已经满了，那么就对于后来的任务就会使用 指定的 拒绝策略，默认情况下是对于新来的任务抛出异常
  - 丢弃 ，抛异常
  - 丢弃，不抛异常
  - 由调用线程池的线程处理任务，比如 main() 线程，不抛异常
  - 丢弃队首任务，将该任务入队，不抛异常



## 3、线程池运行原理



我们需要先知道，线程池的几个主要方法：

- execute()：执行任务，无返回值
- submit()：执行任务，有返回值，会返回一个 Future 类，可以通过 future.get() 获取执行结果，不过会等待阻塞，可以控制等待的时间
- shutdown()：关闭线程池，不会去强制中断正在执行的线程，只是去销毁掉空闲线程，然后等待所有线程执行完毕，才会进入人 SHUTDOWN 状态
- shutdownNow()：顾名思义，立马关闭线程，不论线程是否执行完毕，都强制中断，立马进入 SHUTDOWN 状态



> ### 任务调度

workCount：工作线程，即已经创建的线程数

corePoolSize：核心线程数

maximumPoolSize：最大线程数

workQueue：任务队列



当提交一个任务给线程池的时候，线程池执行过程如下：

1、检查线程状态，判断是否是 RUNNING，如果不是，则直接拒绝

2、如果 workCount < corePoolSize，那么创建一个新的线程去执行任务

3、如果 workCount >= corePoolSize，那么放入到 workQueue

4、如果 workCount > corePoolSize 并且 workCount < maximumPoolSize，并且 

workQueue已满，那么创建新的线程去执行任务

5、如果  workCount == maximumPoolSize，并且任务队列已满，那么启动拒绝策略

![img](https://pic1.zhimg.com/80/v2-b06a332965a66469ac512d92ff70e2db_720w.jpg)



> ### 任务申请 getTask()

getTask() 是线程池的一个重要方法，就跟字面意思一样，就是获取任务

主要是帮助空闲线程获取任务执行，以及控制线程的数量

线程空闲时，会去调用 getTask() 方法获取任务区执行

方法执行流程如下：

1、检查线程池状态，如果线程池为关闭状态 或者 任务队列为空，即没有任务，那么返回 null

2、判断 workCount 是否超过 max，如果超过了，那么直接返回 null，即不给当前线程分发任务，让它处于空闲状态，直到消亡，这样可以减少线程数

3、使用 阻塞任务队列的 poll() 方法获取任务，如果队列中没有任务，那么就会等待一段时间，如果等不到，那么停止等待，设置 `timeOut = ture`



```java
private Runnable getTask() {
        boolean timedOut = false; // Did the last poll() time out?
		
    	//循环判断
        for (;;) {
            int c = ctl.get();
            int rs = runStateOf(c);

            // 检查线程池状态，如果线程池是关闭状态 或者 任务队列为空，那么返回 null,表示无任务可做
            if (rs >= SHUTDOWN && (rs >= STOP || workQueue.isEmpty())) {
                decrementWorkerCount();
                return null;
            }
			//获取工作线程数
            int wc = workerCountOf(c);
			
            // Are workers subject to culling?
            boolean timed = allowCoreThreadTimeOut || wc > corePoolSize;
			//当工作线程数超过 max，或者 等待时间超时，那么返回 null
            if ((wc > maximumPoolSize || (timed && timedOut))
                && (wc > 1 || workQueue.isEmpty())) {
                if (compareAndDecrementWorkerCount(c))
                    return null;
                continue;
            }

            try {
                //workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) 是一个阻塞方法
                //表示等待一定时间，如果没有任务，就停止等待
                Runnable r = timed ?
                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :
                    workQueue.take();
                if (r != null)
                    return r;
                timedOut = true;
            } catch (InterruptedException retry) {
                timedOut = false;
            }
        }
    }
```





> ### Worker 线程

线程池内部定义了一个 Worker 类，任务的执行就是通过这个 Worker 线程执行的，通过 addWorker() 方法来创建工作线程



Worker 是线程池的一个内部类，它继承了 AQS 队列，实现了 Runnable 接口

并且内部定义了一个 Thread 类

Thread 是通过 Worker 的构造方法传进来的，即创建 Worker 的时候就给它一个 Thread，用来执行任务



**简单来说，Worker 组成为 Thread + AQS + CAS**，CAS 是用来获取锁的，跟 ReentrantLock 一样，不过没有可重入功能



任务的执行过程：

- 调用 runWorker()，通过一个 while 来调用 getTask() 获取任务，一旦 task 不为空，那么就调用 lock() 加锁，并且使用 thread 来执行任务

- lock() 加锁是表示该线程正在执行任务，不是空闲线程，这样做的目的是为了线程池可以通过 tryLock() 这个限时获取锁的方法来判断线程是否处于空闲状态，一旦获取不到锁，那么表示线程正在执行任务，反之，则是处于空闲状态

```java
private final class Worker extends AbstractQueuedSynchronizer implements Runnable {
    
    final Thread thread;

    Runnable firstTask;

    Worker(Runnable firstTask) {
            setState(-1); 
            this.firstTask = firstTask;
            this.thread = getThreadFactory().newThread(this);
        }

    public void run() {
        runWorker(this);
    }

    protected boolean tryAcquire(int unused) {
        //CAS
        if (compareAndSetState(0, 1)) {
            setExclusiveOwnerThread(Thread.currentThread());
            return true;
        }
        return false;
    }

    protected boolean tryRelease(int unused) {
        setExclusiveOwnerThread(null);
        setState(0);
        return true;
    }

    public void lock()        { acquire(1); }
    public boolean tryLock()  { return tryAcquire(1); }
    public void unlock()      { release(1); }
    public boolean isLocked() { return isHeldExclusively(); }

    final void runWorker(Worker w) {
        Thread wt = Thread.currentThread();
        Runnable task = w.firstTask;
        w.firstTask = null;
        w.unlock(); // allow interrupts
        try {
            while (task != null || (task = getTask()) != null) {
                w.lock();
                task.run();
                } finally {
                    w.unlock();
                }
            }
        }
    }
```
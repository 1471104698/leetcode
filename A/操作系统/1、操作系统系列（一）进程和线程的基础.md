# 进程和线程的基础



## 1、进程的结构（PCB）

CPU 的主要功能就是执行 进程的指令

由于 CPU 可以同时执行多个进程，从 CPU 角度看，CPU 只是在执行指令，这个指令是通过 程序计数器 中存储的值来实现的，CPU 在同一时刻只能执行一条指令，所以在物理层面上所有的进程共用一个程序计数器，并且一次只能有一个进程的指令放在程序计数器中

从逻辑上看，CPU 并发执行多个进程，因此涉及进程的切换，这样看来，每个进程都需要有一个属于自己的 指令计数器来记录自己指令的执行位置，但需要记录的不仅仅是 指令执行位置这么简单，还需要保存进程的变量、进程的状态（阻塞还是就绪），以及 CPU 正在计算的中间结果 等

对于 进程的信息，需要一种能够描述和控制进程运行的数据结果，这种就是 PCB



PCB 的内容：

- 进程标识符，每个进程的标识符是唯一的，跟文件描述符一样
- 进程的当前状态：标明进程是就绪还是阻塞状态，如果是就绪，那么就是等待 CPU 调度，如果是阻塞，那么需要在 PCB 中记录阻塞的原因
- 进程资源：所有的文件描述符、持有的 IO 设备等
- 进程优先级
- 进程的信号量
- CPU 保护现场：程序计数器的内容、通用寄存器内容等



## 2、用户态 和 内核态

> ### 用户态 和 内核态的关系

**内存假设为 4G，那么内核态和用户态共用瓜分这 4G 内存，即将一部分作为内核态，一部分作为用户态**



内核态中的程序可以访问的资源最多，权限最大，安全性要求最高

用户态中的程序可以访问的资源有限，但安全性要求低



涉及到计算机资源的操作，比如读写文件，都需要在内核态中，因为文件不可能直接放在用户态啊；

跟用户数据相关的，比如 JVM 内存这种，Java 自己定义的变量对象之类的，则在用户态运行



用户态的程序只能持有文件的文件描述符 fd，具体的操作通过传输 fd 给内核态，让 CPU 进入内核态中进行操作



> ### 什么时候用户态会切换到内核态？

- 系统调用：比如 read()、write() 等
- 异常：当前i进程在用户态时，发生了异常事件，就会发生切换，比如 缺页异常
- 设备中断：外设完成用户请求时，会向 CPU 发送中断信号





## 3、线程



> ### 为什么使用线程？

我们举个例子，假设你要编写一个视频播放器软件，那么该软件功能的核心模块有三个：

- 从视频文件当中读取数据；
- 对读取的数据进行解压缩；
- 把解压缩后的视频数据播放出来；

对于单进程的实现方式，我想大家都会是以下这个方式：

![img](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcvw4t9kicec370n3cvX2JS929V7rcLXiaaB16boR9VraolG9Fgc9NpnxOSlHx7No6t0zSPrscaeuaA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

（这里需要说明一下，java 中，我们运行一个类 main() 方法的时候，它就是一个独立的进程，当我们运行两个类的 main() 方法的时候，它们就是两个独立的进程，互不干扰）

因此上面的这种方式是运行在一个类中的，是一个进程

单进程是按顺序执行的，即必须先 Read() 执行完毕后再 解压缩数据，再进行播放

由于需要边读取边播放，因此我们每读取 1 个字节就进行解压缩再播放，这样就可以边读取压缩边播放

对于单进程的这种方式，存在以下问题：

- 可能由于 CPU 的原因，我们在 Read() 方法这里卡住了，那么就会导致半天才能数据解压和播放，体验不友好
- 单进程的方式，各个函数之间不是并发执行的，而是顺序执行的影响效率

那改成多进程的方式：

![img](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcvw4t9kicec370n3cvX2JS9CInoGdDVyYvtTfju7gVeKLjDNOMmul4kPzicTbczNiaBSzGiaEzDXtYTA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

这就又产生一个问题了，多进程，其实就是多个类，一个类执行一个函数，那么这几个类怎么进行共享数据？比如你多个类同时执行 main() 方法，数据能共享吗？

不能吧！！！！

那到底如何解决呢？需要有一种新的实体，满足以下特性：

- 实体之间可以并发运行；
- 实体之间共享相同的地址空间；

这个新的实体，就是**线程( Thread )**，线程之间可以并发运行且共享相同的地址空间。



> #### 线程与进程的比较

**进程是资源分配的基本单位， 线程是调度的基本单位**。

这里我们可以看出来，最开始讲的进程是调度的基本单位，等到线程出来后，进程单单就变成了资源分配的基本单位了，即是提供一个资源共享的平台给它内部的线程使用，单单只是作为一个交流平台而已，所有的线程都可以来这里拿数据资源

所以，由于资源是共享的，所有线程都能拿到，才存在线程安全的问题，即到底是谁先拿到，以及谁做的改变才有效等问题



## 4、进程 和 线程的上下文切换

线程占有的：栈（存储局部变量等）、程序计数器

线程共享的：堆、全局变量、静态变量

进程占有的：地址空间、全局变量、文件描述符、子进程、信号量 





> ### 进程上下文切换

进程上下文切换的过程：

- 保存 CPU 信息
- 对被中断进程进行 PCB 更新（因为 PCB 内容是旧的）
- 将被中断进行的 PCB 移入到队列中（如果是时间片到了那么移到就绪队列，如果是 IO 阻塞那么移入到 阻塞队列）
- 进程调度选择一个新进程，将它的 PCB 刷新进来，同时获取 PCB 中的 页表、段表等 刷新地址空间
- 恢复新进程的 CPU 现场信息（CPU 指令寄存器、程序计数器 等）



> ### 线程上下文切换

对于同一个进程中的多个线程，每个线程都有自己独立的 工作内存（栈 和 程序计数器），所以这些需要进行保存和更新

**对于不同进程中的线程切换，那么所有东西都是不共享的，那么切换就跟进程上下文切换一样了**



> ### 为什么说上下文切换导致 CPU 效率降低

 一个CPU主频是 2.6GHz，这意味着每秒可以执行：2.6*10^9 个指令，那么每个指令的时间大概是0.38ns！

而一次上下文切换，将近需要耗时2000ns！而这个时间内，CPU什么都干不了，只是做了保存上下文都动作！





## 5、多进程 和 多线程

> ### 多 CPU 和 多核 CPU 与 进程 和 线程 的关系

首先我们需要知道，进程作为 操作系统资源分配的基本单位，线程是 CPU 调度的基本单位

多 CPU 表示有多个 CPU，多核 CPU 表示一个 CPU 有多个核

我们需要知道，一个 CPU 对应一个进程，而 CPU 的核对应进程中的线程

即如果有多个 CPU，那么多个进程是并行执行的，如果 CPU 有多个核，那么多个线程是并行执行的

如果只有一个 CPU，那么多个进程是并发执行的，如果 CPU 只有一个核，那么多个线程是并发执行的



CPU 是看不到进程的，CPU 一旦进入了进程内部，只能调用线程

而一个 CPU 对应一个进程的原因就是一个 CPU 在同一时刻只能进入到一个进程内部，调用里面的线程

一个 CPU 的多核 是能够在同一时间调用同一个进程的多个线程



> ### CPU 密集型 和 IO 密集型

CPU 密集型表示任务需要大量的计算，需要大量占用 CPU 的资源

IO 密集型表示任务 99%情况下进行的是 IO 操作，IO 操作中 线程 会挂起，所以不会占用太大的 CPU 资源



- CPU 密集型由于需要大量的 CPU 资源，或者 需要重复的计算，因此多个 CPU 情况下可以开多个 (相同) 进程进行计算，高效使用了 CPU 资源

- IO 密集型由于大多数情况下需要 IO，不怎么需要 CPU 资源，而 IO 操作的时候线程会挂起，CPU 会没事干，所以可以开多个线程来运行，这样 一个线程挂起了，CPU 可以去处理另外一个线程
  - 由于 IO 操作时，基本很大的时间都耗费在寻道上，而这个时间 CPU 不知道可以执行多少条命令了，如果 CPU 在 IO 时空闲着不动，那这效率，，，因此 CPU 可以在 IO 的时候去执行其他的线程





## 6、僵尸进程 和 孤儿进程

每个进程都有自己的唯一一个 ID 号（PID），并且都附带一个它的父进程的 ID 号（PPID），进程死亡时，ID 号会被回收

### 1、孤儿进程

子进程还没有结束，而父进程自己先执行完退出了，那么这个子进程就是一个孤儿进程，它会被交给 init 进程进行管理

相比僵尸进程，孤儿进程不会占用资源，因为它最终还是会被回收的



### 2、僵尸进程



**产生的原因：**子进程死亡后，父进程没有去调用 wait() 或者 waitpid() 处理子进程的 PCB，导致子进程的文件描述符之类的无法被回收

**危害：**它会一直占据着一个 fd，而 fd 是有限的，如果僵尸进程过多，那么可能导致系统瘫痪

**查找僵尸进程：**通过 ps 可以查看 进程 stat，查找处于 Z 状态的进程

```shell
ps -a -o stat,ppid,pid,cmd | grep '^[Zz]'

-a：查看满足条件的所有进程
-o：自定义输出参数
将查询出来的数据使用 匿名管道 发送给 grep '^[Zz]'
后面的 '^[Zz]' 是正则表达式匹配
```



**处理方法：**

- 改写父进程，让父进程为子进程收尸，子进程死后会给父进程发送  SIGCHLD 信号，默认情况下父进程会忽略这个信号，因此需要改写父进程去处理这个信号，调用 waitpid() 给子进程收尸
- 杀死父进程，这样僵尸进程就变成了孤儿进程，留给 init 进程处理
- 两次 fork()，父进程 fork 一代子进程，一代子进程再 fork 二代子进程，真正的操作在 二代子进程中，然后将 一代子进程杀死，这样二代子进程就是孤儿进程，死后自己靠 init 处理



## 7、为什么记事本打开纯文本大文件会卡顿？

**读取文件最消耗时间的是 IO**

比如现在在桌面搞一个 1G 的 txt，打开就需要一段假死时间，但是在  devc（C++）之类的软件上面打开就会快很多

这是因为计算机自带的文本编辑器是将读取全部的文件数据，然后再加载出来的

**优化的点：**用户不需要一次看到所有的数据，我们只需要加载一部分，然后等到需要的时候等用户需要的时候再去加载

但是如果这样的话可能会给用户卡顿的感觉， 因此使用多线程，当一个线程读取一部分数据然后在处理的过程中，使用另一个线程去读取其他的数据 或者 一个线程读取数据，另外一个线程去处理这些数据

可以使用多进程，不过多线程相比多进程来说，多线程由于进程间数据共享所以一个线程获取其他线程的数据更加简单，并且线程上下文切换比进程来说更快（一个上下文切换对 CPU 来说足够执行几千几万条指令了，所以越快越好）



不过需要注意的是，最好不要使用多个线程去读取同个文件，因为磁头只有一个，一个线程读取这里的数据，然后另一个线程读取这里的数据，**磁头寻道时间对于 CPU 来说足够执行几百万条指令了**，因此最好保证顺序读，即上面最好选择一个线程处理数据，一个线程读取数据
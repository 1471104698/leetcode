# [201. 数字范围按位与（没那么简单）](https://leetcode-cn.com/problems/bitwise-and-of-numbers-range/)

```java
给定范围 [m, n]，其中 0 <= m <= n <= 2147483647，返回此范围内所有数字的按位与（包含 m, n 两端点）。
```



## **示例 1:** 

```java
输入: [5,7]
输出: 4
```



## **示例 2:**

```java
输入: [0,1]
输出: 0
```





## 方法①、暴力解法（一步步优化分析，勉强通过）

### 实现思路

```java
直接从 m 遍历到 n，将每个数都进行按位与

版本一：
class Solution {
    public int rangeBitwiseAnd(int m, int n) {
        int res = m;
        for(int i = m + 1; i <= n; i++){
            res &= i;
        }
        return res;
    }
}

但这样做是有问题的，不仅仅是超时的问题，而是如果，比如 当 n = 2147483647，即 Integer.MAX_VALUE 二进制为 0111 1111 ... 1111，
那么当 i == n, 完成这一次处理后，i++，由于溢出导致变成 1000 0000 ... 0000 即 -2147483648, 即 Integer.MIN_VALUE
那么这时候 i < n，因此会重新计算 到 n，即会超时，同时最终结果也是错误的，因此我们再 i == 2147483647 的时候 break

版本二：
class Solution {
    public int rangeBitwiseAnd(int m, int n) {
        int res = m;
        for(int i = m + 1; i <= n; i++){
            res &= i;
            if(i == Integer.MAX_VALUE){
                break;
            }
        }
        return res;
    }
}

但我们其实还可以再优化，由于 0 跟任何数按位与都是 0，即 0 & x = 0，
因此当 res == 0 时，可以提前 break，这里也同时处理了 初始值 m == 0 的情况

版本三：
class Solution {
    public int rangeBitwiseAnd(int m, int n) {
        int res = m;
        for(int i = m + 1; i <= n; i++){
            res &= i;
            if(i == Integer.MAX_VALUE || res == 0){
                break;
            }
        }
        return res;
    }
}

但上面还是存在问题，我们是直接 int i = m + 1，
如果 存在以下 用例：
m = 2147483647
n = 2147483647
这就意味着 i = m + 1 会溢出，变成 -2147483648，使得范围变成 [-2147483648, 2147483647]
结果错误，因此我们需要处理这种情况，可以在最前面加一个 if() 判断，或者将 res 初值设置为 -1，即 1111 1111 ... 1111，这样就不会存在问题
因为 0 & 1 == 0, 1 & 1 == 1，因此 -1 & x == x，所以 res = -1 的设置不会对结果造成影响

版本四：
class Solution {
    public int rangeBitwiseAnd(int m, int n) {
    /*
        if(m == Integer.MAX_VALUE){
            return m;
        }
    */
        int res = -1;
        for(int i = m; i <= n; i++){
            res &= i;
            if(res == 0 || i == Integer.MAX_VALUE){
                break;
            }
        }
        return res;
    }
}
```



### 实现代码

```java
class Solution {
    public int rangeBitwiseAnd(int m, int n) {
        int res = -1;
        for(int i = m; i <= n; i++){
            res &= i;
            if(res == 0 || i == Integer.MAX_VALUE){
                break;
            }
        }
        return res;
    }
}
```





## 方法②、规律解法

### 实现思路

```java
方法① 过于暴力，对于这种范围题必定不会是单单从 m 一个个按位与到 n，而是存在一定的简化方法

前置知识：
我们需要知道，对于某个位置的二进制数，无论存在多少个 1，只要出现过一个 0，那么按位与后 该位置的二进制数必定为 0
比如
1111
1101
1110
------
1100
低位两个都出现过 0，因此最终按位与结果为 0

我们需要将 m 和 n 的二进制序列划分为两部分，划分的标准为， m 的左半部分和 n 的左半部分相同，m 的右半部分 和 n 的右半部分不同
我们先看下例子：
m = 1100 0101
n = 1111 0011
	 ↑
在该位置，m 和 n 的左半部分相同，而 右半部分是不同的
那么最终 [m, n] 按位与结果 为 1100 0000

m = 0000 0010 0101
n = 0000 1011 0011
	   ↑
在该位置，m 和 n 的左半部分相同，而 右半部分是不同的
那么最终 [m, n] 按位与结果 为 0

我们可以看出，左半部分相同的不变，右半部分不同的全部为 0，这个规律为什么成立？
m = 1100 0101
n = 1111 0011
     ↑
左半部分 11 相同
最终 [m, n] 按位与结果为 1100 0000

左半部分保留的原因：
我们知道 m < n，那么 m 会一直 + 1，直到等于 n
那么一直在发生改变的就是 m 和 n 不相同的右半部分，因为左半部分是高位，并且还相同，那么意味着当低位的右半部分相同时， m 和 n 就相同了
因此高位的左半部分最终无论 m 怎么变，都是一样的，由于 x & x == x，那么最终按位与的结果肯定存在左半部分

右半部分必定为 0 的原因：
由于 m 一直在 + 1，并且右半部分低位一直在变，直到变得跟 n 的右半部分低位相同，每个位置变化的过程必定经历的是 0 和 1
比如上面 m 和 n 的右半部分：
00 0101 -> 11 0011，逐步 + 1 的过程中必定每个位置都经过了 0，
不可能只出现 0 或 只出现 1，由于出现了 0，我们最开始也说了，无论存在多少个 1，只要某个位置出现了 0，那么最终该位置按位与的结果是 0
因此右半部分必定是 0
    
    
综上，我们只需要将 m 和 n 一直右移，直到出现 m == n，即 留下 左半部分，将右半部分全部右移走
同时，我们需要记录右移的次数，即右半部分的位数，然后再最后通过补 0 将右半部分的位数给补回来

步骤：
m = 1100 0101
n = 1111 0011
不断右移，直到 m == n == 11, 右移次数为 6
再左移补 6 个 0 ，即得到最终结果 1100 0000
```



### 实现代码

```java
class Solution {
    public int rangeBitwiseAnd(int m, int n) {
        int c = 0;
        while(n != m){
            n >>= 1;
            m >>= 1;
            c++;
        }
        return m << c;
    }
}
```


# 线程池



## 1、为什么使用线程池？

线程池解决的核心问题是 线程的资源管理问题，在并发环境下，不能够确定在任意时刻中有多少任务需要执行，这种不确定性会带来以下问题：

- 频繁的创建 和 销毁 线程，存在额外消耗

  - ```java
    创建线程的过程：
    1、调用操作系统底层 api 创建一个线程
    2、为线程分配一个虚拟机栈 和 一个程序计数器
    ```

- 无限制的创建线程，占用太多的系统资源

  - ```java
    一个线程创建后即时什么都不干，也需要占据 1MB 内存，这样 10 个线程就需要占据 10MB 内存
    ```

因此需要线程池来 管理线程，避免 大量创建 和 频繁销毁 线程，使得高并发情况下 系统性能下降





## 2、线程池的参数

- `corePoolSize`：核心线程数，当已经创建的线程数等于 指定的 `corePoolSize` 时，那么就不会再创建线程了，而是将任务放入到任务队列中，等其他线程执行完毕再来这个任务队列中调用任务继续执行
- `maximumPoolSize`：线程池允许创建的最大线程数，上面说了，线程数到 `corePoolSize` 个数时，就会将任务放到任务队列，当然也不是一直放，任务队列有一个指定大小的，当任务队列满了之后，就会再次创建线程，而这次的最大边界就是这里指定的 `maximumPoolSize`，当线程池中线程数到达这个数量时，之后就不会再创建线程了，除非销毁掉一些旧的线程
- `keepAliveTime`：线程空闲时间，也可以叫空闲存活时间，用来 帮助 getTask()  进行线程管理
- `unit`：时间单位，显然是跟上面那个存活时间共用的
- `workQueue`：任务队列，就是上面说的，没有线程可以调用时任务存放的队列，**都是阻塞队列**
- `threadFactory`：创建线程的工厂，里面只有一个 newThread()，可以指定线程的名字
- `handler`：拒绝策略，当线程池内的线程数达到 max 级别，并且任务队列内的元素已经满了，那么就对于后来的任务就会使用 指定的 拒绝策略，默认情况下是对于新来的任务抛出异常
  - 丢弃 ，抛异常
  - 丢弃，不抛异常
  - 由调用线程池的线程处理任务，比如 main() 线程，不抛异常
  - 丢弃队首任务，将该任务入队，不抛异常





## 3、线程池运行原理



我们需要先知道，线程池的几个主要方法：

- execute()：执行任务，无返回值，在里面会调用 addWorker() 创建线程
- submit()：执行任务，有返回值，会返回一个 Future 类，可以通过 future.get() 获取执行结果，不过会等待阻塞，可以控制等待的时间
- shutdown()：关闭线程池，不会去强制中断正在执行的线程，只是去销毁掉空闲线程，然后等待所有线程执行完毕，才会进入人 SHUTDOWN 状态
- shutdownNow()：顾名思义，立马关闭线程，不论线程是否执行完毕，都强制中断，立马进入 SHUTDOWN 状态



### 1、任务提交流程



当提交一个任务给线程池的时候，线程池执行过程如下：

1、检查线程状态，判断是否是 RUNNING，如果不是，则直接拒绝

2、如果 workCount < corePoolSize，那么创建一个新的线程去执行任务

3、如果 workCount >= corePoolSize，那么放入到 workQueue

4、如果 workCount > corePoolSize 并且 workCount < maximumPoolSize，并且 

workQueue已满，那么创建新的线程去执行任务

5、如果  workCount == maximumPoolSize，并且任务队列已满，那么启动拒绝策略

![img](https://pic1.zhimg.com/80/v2-b06a332965a66469ac512d92ff70e2db_720w.jpg)





### 2、Worker类





```java
private final class Worker
    extends AbstractQueuedSynchronizer
    implements Runnable
{

    //执行线程
    final Thread thread;
    //创建 Worker 时传进来的第一个任务
    Runnable firstTask;

    Worker(Runnable firstTask) {
        this.firstTask = firstTask;
        //这里创建线程的时候将 Worker 自身作为 Runnable 传入了，后面 t.start() 就是执行当前类的 run()
        this.thread = getThreadFactory().newThread(this);
    }

    public void run() {
        runWorker(this);
    }

    protected boolean tryAcquire(int unused) {
        //CAS，尝试获取锁
        if (compareAndSetState(0, 1)) {
            setExclusiveOwnerThread(Thread.currentThread());
            return true;
        }
        return false;
    }

    protected boolean tryRelease(int unused) {
        setExclusiveOwnerThread(null);
        setState(0);
        return true;
    }

    public void lock()        { acquire(1); }
    public boolean tryLock()  { return tryAcquire(1); }
    public void unlock()      { release(1); }
    public boolean isLocked() { return isHeldExclusively(); }
```

Worker 类是 线程池的一个内部类，内部有 thread 和 firstTask 两个变量，其中 firstTask 是在创建 Worker 时通过构造方法传入的，表示当前需要执行的任务，而 thread 是通过 ThreadFactory 直接创建的

里面还有一个 run() ，内部调用了 runWorker() 来执行任务



**Worker 类继承了 AQS，内部定义了 lock() 等方法，跟 ReentrantLock 类似，只是这个 lock() 不是用来防止竞争的，而是当调用 shutdown() 的时候，调用 worker 的 tryLock() 尝试获取锁，以此来判断线程是否处于空闲状态，如果是，那么进行回收**



### 3、execute() 和 addWorker()

```java
public void execute(Runnable command) {
    if (command == null)
        //获取当前线程数 c
        int c = ctl.get();
    //c 小于核心线程数，那么直接调用 addWorker 并且将任务交给它执行
    if (workerCountOf(c) < corePoolSize) {
        if (addWorker(command, true))
            return;
        c = ctl.get();
    }
    /*
    isRunning(c) 判断线程池是否还在执行， workQueue.offer(command) 将任务提交到任务队列中
    这里的意思是如果 线程数小于 corePoolSize，那么直接将任务交给新创建的核心线程执行
    如果大于 corePoolSize，那么将任务放到任务队列中
    如果放入成功，那么就在队列中等待
    如果放入失败，表示任务队列满了，尝试添加一个 Worker，如果超过了 max，那么添加失败，实施拒绝策略，如果添加成功，那么执行
    */
    if (isRunning(c) && workQueue.offer(command)) {
        int wc = ctl.get();
        if (!isRunning(wc) && remove(command))
            reject(command);
        else if (workerCountOf(wc) == 0)
            addWorker(null, false);
    }
    else if (!addWorker(command, false))
        reject(command);
}

private boolean addWorker(Runnable firstTask, boolean core) {
    for (;;) {
        int c = ctl.get();
        int rs = runStateOf(c);
        for (;;) {
            //获取线程数量，如果超过了 max ，那么不能创建新线程
            int wc = workerCountOf(c);
            if (wc >= CAPACITY ||
                wc >= (core ? corePoolSize : maximumPoolSize))
                return false;
            //通过CAS自旋，增加线程数+1，增加成功跳出双层循环，继续往下执行
            if (compareAndIncrementWorkerCount(c))
                break;
        }
    }

    Worker w = null;
    try {
        //创建 Worker，并且调用 t.start() 执行任务
        w = new Worker(firstTask);
        final Thread t = w.thread;
        if (t != null) {
            //到这里开始加锁，只在将新创建的线程添加进 workers 中时加了锁，缩小了锁的粒度
            final ReentrantLock mainLock = this.mainLock;
            mainLock.lock();
            try {
                int rs = runStateOf(ctl.get());
                /*
                workers 是一个 HashSet，添加我们新增的Worker, 它是线程不安全的，因此需要加锁添加
                workers 用于调用 shutdown() 时遍历线程
                */
                workers.add(w);
                int s = workers.size();
                if (s > largestPoolSize)
                    largestPoolSize = s;
                workerAdded = true;
            }
        } finally {
            mainLock.unlock();
        }
        if (workerAdded) {
            //启动Worker
            t.start();
            workerStarted = true;
        }
    }
    return workerStarted;
}
```

当调用 execute() 提交任务的时候，会先判断线程数量 c 是否小于 corePoolSize

如果是，那么直接调用 addWorker() 创建新的 Worker 执行任务

如果不是，那么先将任务放入任务队列排队

如果放入成功，那么就这样不管

如果放入失败，表示队列已满，那么调用 addWorker() 创建新的线程

在第二次调用的  addWorker() 中，会判断线程数量是否已经超过 max，如果超过，那么不创建，直接返回。如果不超过，那么创建新的 Worker 并获取 Worker 中的 thread 调用 run() 执行任务，而 run() 中调用的是 runWorker()

即最终任务的执行是在 runWorker() 中的





### 4、任务执行 runWorker()

```java
final void runWorker(Worker w) {
    Thread wt = Thread.currentThread();
    Runnable task = w.firstTask;
    try {
        while (task != null || (task = getTask()) != null) {
            w.lock();
            try {
                task.run();
            } finally {
                task = null;
                w.unlock();
            }
        }
    } 
}
```

我们可以看出，它会使用一个 while() 循环不断从 getTask() 中获取任务执行

当 task != null，即获取到一个任务的时候，那么就会调用 lock() 加锁，前面也说了，lock() 不是为了防止别的线程进行竞争，而是为了告知线程池现在自己有任务要执行，不是处于空闲状态

当任务执行完毕后，会将 task 置 null，然后释放锁，然后再继续循环调用 getTask() 获取任务



### 5、任务获取 getTask()



```java
private Runnable getTask() {
        boolean timedOut = false; // Did the last poll() time out?
		
    	//循环判断
        for (;;) {
            int c = ctl.get();
            int rs = runStateOf(c);

            // 检查线程池状态，如果线程池是关闭状态 或者 任务队列为空，那么返回 null,表示无任务可做
            if (rs >= SHUTDOWN && (rs >= STOP || workQueue.isEmpty())) {
                decrementWorkerCount();
                return null;
            }
			//获取工作线程数
            int wc = workerCountOf(c);
			
            // 线程数量 wc 超过 corePoolSize 时为 true
            boolean timed = allowCoreThreadTimeOut || wc > corePoolSize;
			//当工作线程数超过 max，或者 (等待时间超时 并且 线程数量 wc 超过 corePoolSize)，那么返回 null
            if ((wc > maximumPoolSize || (timed && timedOut))
                && (wc > 1 || workQueue.isEmpty())) {
                if (compareAndDecrementWorkerCount(c))
                    return null;
                continue;
            }

            try {
                //workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) 是一个阻塞方法
                //表示等待一定时间，如果没有任务，就停止等待
                Runnable r = timed ?
                    //这里的等待超时时间是 创建线程池时传入的 空闲存活时间
                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :
                    workQueue.take();
                if (r != null)
                    return r;
                timedOut = true;
            } catch (InterruptedException retry) {
                timedOut = false;
            }
        }
    }
```



getTask() 的作用是空闲的线程用来获取任务执行的

而它其实还有一个重要作用：减少超过 corePoolSize 之外的线程数量，即控制线程数量



它的执行流程如下：

- 如果线程数量超过 max 或者 (线程数量超过 core 并且 timeout = true)，那么就不再循环获取任务，直接返回 null
- 如果前面没有返回 null，那么调用 任务队列的 poll() ，等待获取任务的时间为 keepAliveTime，如果这段时间获取不到任务，那么设置 timeout = true，并且进入下一轮等待
- 当获取到任务时，直接将任务返回



> ### 保证核心线程不会被销毁的原理

对于 core 数量内的线程来说，在 getTask() 中获取不到任务也会一直循环，这样就导致 core 线程不会处于空闲状态，从而不会被回收

而对于 core 外的线程来说，它会给这些线程一次获取任务的机会，如果在 poll() 等待过程中获取到了任务，那么就返回执行

如果在 keepAliveTime 时间内没有获取任务，表示这段时间用户没有提交任务了，线程资源不需要这么多了，那么就设置 timeout = true。在下一轮中返回 null，即不再获取任务，这样的话，对于 runWorker() 在 while() 中调用了 getTask()，发现返回了 null，那么 while() 也会停止循环，这样的话线程就处于空闲状态，等到达一定的空闲时间，这些线程就会被回收了，就是这样保证了线程池线程的数量



**我们可以看出，keepAliveTime 的作用就是用来 帮助 getTask()  进行线程管理的**





### 6、线程池减少锁的竞争（CAS）

使用一个 AtomicInteger ctl，将线程池的状态 和 当前的线程数量合并到一个 int 变量当中

前 3 位表示线程池的状态，后 29 位表示当前的线程数，这样就使用最少的变量来减少锁的竞争，即无论是线程池状态还是线程的数据在修改的时候都不需要加锁来修改了

```java
    //CAS，无锁并发
    private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
    //表示线程池线程数的数量，Integer.SIZE = 32，而 bitCount = 32 - 3 = 29
    private static final int COUNT_BITS = Integer.SIZE - 3;
    //最大的线程数量，1 << 29 - 1，即 00011111111111111111111111111111
    private static final int CAPACITY   = (1 << COUNT_BITS) - 1;

    // runState is stored in the high-order bits
    //1110 0000 0000 0000 0000 0000 0000 0000（很耿直的我）
    private static final int RUNNING    = -1 << COUNT_BITS;
    //0000 0000 0000 0000 0000 0000 0000 0000（很耿直的我）
    private static final int SHUTDOWN   =  0 << COUNT_BITS;
    //0010 0000 0000 0000 0000 0000 0000 0000（很耿直的我）
    private static final int STOP       =  1 << COUNT_BITS;
    //0100 0000 0000 0000 0000 0000 0000 0000（很耿直的我）
    private static final int TIDYING    =  2 << COUNT_BITS;
    //0110 0000 0000 0000 0000 0000 0000 0000（很耿直的我）
    private static final int TERMINATED =  3 << COUNT_BITS;

    // Packing and unpacking ctl
    //获取线程池的状态，c & 111000000...
    private static int runStateOf(int c)     { return c & ~CAPACITY; }
    //获取线程的数量，c & 0001111...
    private static int workerCountOf(int c)  { return c & CAPACITY; }
    //组装状态和数量，成为ctl
    private static int ctlOf(int rs, int wc) { return rs | wc; }
```





### 7、线程池 shutdown() 和 shutdownNow()



> ### shutdown()

shutdown() 是先回收空闲线程，然后等正在执行的其他线程执行完毕后才进行回收

关于空闲线程的判断，就是利用 线程在执行任务前调用的 lock()，线程池通过调用 tryLock() 尝试获取锁判断线程的执行状态

```java
private void interruptIdleWorkers(boolean onlyOne) {
        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock();
        try {
            for (Worker w : workers) {
                Thread t = w.thread;
                //调用 tryLock() 尝试获取锁，获取成功表示线程处于空闲状态
                if (!t.isInterrupted() && w.tryLock()) {
                    try {
                        t.interrupt();
                    } catch (SecurityException ignore) {
                    } finally {
                        w.unlock();
                    }
                }
                if (onlyOne)
                    break;
            }
        } finally {
            mainLock.unlock();
        }
    }
```





> ### shutdownNow()

该方法调用后会直接中断所有在执行的线程，然后进行回收





## 4、线程池的 submit() - FutureTask

最上面讲了 线程池的 execute()，这里来讲讲线程池的 submit()，主要是用来阻塞等待线程完成任务，如果有返回结果的话顺便获取返回结果，它返回的是一个 FutureTask 对象

```java
//接收 Runnable 对象
public Future<?> submit(Runnable task) {
    //封装
    RunnableFuture<Void> ftask = newTaskFor(task, null);
    //调用
    execute(ftask);
    return ftask;
}
//接收 Callable 对象
public <T> Future<T> submit(Callable<T> task) {
    //封装
    RunnableFuture<T> ftask = newTaskFor(task);
    //调用
    execute(ftask);
    return ftask;
}
//将 Callable 封装成 FutureTask
protected <T> RunnableFuture<T> newTaskFor(Callable<T> callable) {
    //封装程一个 FutureTask
    return new FutureTask<T>(callable);
}
//将 Runnable 封装成 FutureTask
protected <T> RunnableFuture<T> newTaskFor(Runnable runnable, T value) {
    return new FutureTask<T>(runnable, value);
}
```

我们可以看出，线程池 ThreadPoolExecutor 的 submit() 方法无论是 Runnalbe 还是 Callable 内部都是封装一个 FutureTask，然后调用 execute() 方法传入 FutureTask，最终将这个 FutureTask 返回



> ### FutureTask 类

核心就是这个 FutureTask 类

```java
public class FutureTask<V> implements RunnableFuture<V> {
    //state 表示当前任务的状态，以下 7 个状态就是使用 state 表示
    private volatile int state;
    //任务刚初始化，还没执行
    private static final int NEW          = 0;
    //任务正在执行
    private static final int COMPLETING   = 1;
    //任务执行完毕
    private static final int NORMAL       = 2;
    //任务出现异常
    private static final int EXCEPTIONAL  = 3;
    //任务中断
    private static final int CANCELLED    = 4;
    //任务中断中
    private static final int INTERRUPTING = 5;
    //任务中断完成
    private static final int INTERRUPTED  = 6;
    
    //需要执行的任务，内部是 call()
	private Callable<V> callable;
    //调用 get() 返回的结果
    private Object outcome;
    //调用 get() 等待结果的线程节点队列
    private volatile WaitNode waiters;
    
    //构造方法一：将 Runnable 通过 callable() 通过适配器模式封装成一个 Callable
    public FutureTask(Runnable runnable, V result) {
        this.callable = Executors.callable(runnable, result);
        this.state = NEW;       // ensure visibility of callable
    }
    //构造方法二：简单赋值
    public FutureTask(Callable<V> callable) {
        this.callable = callable;
        this.state = NEW;       // ensure visibility of callable
    }   
}
```

我们可以看出，FutureTask 实现了 RunnableFuture 接口

```java
public interface RunnableFuture<V> extends Runnable, Future<V> {
    void run();
}
```

而 RunnableFuture 实现了 Runnable 和 Future 接口，**意味着 FutureTask 是一个 Runnable 类 和 Future 类**

它在构造方法一处将 传进来的 **Runnable 任务通过适配器封装成了一个 Callable 任务，消除了 Runnable 和 Callable 的差异**



```java
public <T> Future<T> submit(Callable<T> task) {
    if (task == null) throw new NullPointerException();
    RunnableFuture<T> ftask = newTaskFor(task);
    //调用 execute() ，将 FutureTask 对象传入
    execute(ftask);
    return ftask;
}
```

而在创建完 FutureTask 对象后，线程池将 FutureTask  对象作为参数传入 execute()



> ### 所以 FutureTask 为什么这么设计？

- **在 FutureTask 层面**，FutureTask 的出现 就是为了提供一个方法来阻塞等待线程完成任务，如果有返回值则顺便获取返回值，而这个任务可以是 Runnable 类型，也可以是 Callable 类型，它们之间的差距就是 Runnable 调用的是 run()，并且没有返回值，Callable 调用的是 call()，有返回值；因此为了消除这个差异，FutureTask 在构造器传入 Runnable 的时候使用适配器将它封装为一个 Callable 方法，这样它们调用的都是 call()，并且都有返回值了，对于 Runnable 类型的任务来说返回值为 null，这样就无需为两种方法设计两套不同的调用方案，都可以通过 get() 来阻塞等待
- **在线程池的 execute() 层面**，Runnable 和 FutureTask 是同个等级的，将 FutureTask 设计为 Runnable 类型就是为了消除在 execute() 调用的时候 Runnable 和 FutureTask 的差异，后面直接在 Worker 中可以直接传入 FutureTask 或者 Runnable 任务，这样就不需要为 Worker 设计两套方案来分别调用 FutureTask 和 Runnable 了
- **在 Callable 层面**，Callable 类型的任务因为存在返回值，所以如果要获取返回值就必须等待线程执行完毕，因此就出现了 FutureTask，Callable 需要配合 FutureTask 一起使用，即两者是绑定的，而对于 Runnable 来说如果想要阻塞等待也可以使用 FutureTask ，如果不想则不需要，即不用跟 FutureTask 绑定



在执行 submit() 的时候，方法执行顺序如下：

- 调用 submit()
- 将 Runnable 任务 或者 Callable 任务封装成 FutureTask
- 将 FutureTask 作为参数传入 execute()
- 调用 execute()，并将 FutureTask 返回给用户，这时可以调用 get() 进行等待
- t.start() 调用的是 Worker 的 run()
- 在 Worker 的 run() 中调用了 FutureTask 的 run()
- 在 FutureTask 的 run() 中调用了 Callable 的 call()

```java
//以下是 FutureTask 的 run()
public void run() {
    try {
        Callable<V> c = callable;
        if (c != null && state == NEW) {
            V result;
            boolean ran;
            try {
                //调用 Callable 的 call()，获取返回结果
                result = c.call();
                ran = true;
            } catch (Throwable ex) {
                result = null;
                ran = false;
                setException(ex);
            }
            if (ran)
                //将返回结果设置到全局的 outcome 变量中，供 get() 调用返回，并且在内部唤醒线程
                set(result);
        }
    } finally {
        runner = null;
    }
}
public V get() throws InterruptedException, ExecutionException {
    int s = state;
    //通过 state 判断任务没有完成
    if (s <= COMPLETING)
        //如果任务还没有完成，那么将当前线程作为一个 Node 节点入队挂起
        s = awaitDone(false, 0L);
    return report(s);
}
private int awaitDone(boolean timed, long nanos)
        throws InterruptedException {
        final long deadline = timed ? System.nanoTime() + nanos : 0L;
        WaitNode q = null;
        boolean queued = false;
        for (;;) {
            if (Thread.interrupted()) {
                removeWaiter(q);
                throw new InterruptedException();
            }

            int s = state;
            if (s > COMPLETING) {
                if (q != null)
                    q.thread = null;
                return s;
            }
            else if (s == COMPLETING) // cannot time out yet
                Thread.yield();
            else if (q == null)
                q = new WaitNode();
            else if (!queued)
                queued = UNSAFE.compareAndSwapObject(this, waitersOffset,
                                                     q.next = waiters, q);
            else if (timed) {
                nanos = deadline - System.nanoTime();
                if (nanos <= 0L) {
                    removeWaiter(q);
                    return state;
                }
                //限时挂起
                LockSupport.parkNanos(this, nanos);
            }
            else
                //挂起线程，这里会阻塞
                //然后在 FutureTask 的 run() 执行完结尾会调用 set()，将返回结果赋值给全局变量，顺便唤醒线程
                LockSupport.park(this);
        }
    }
```

它在内部调用了 Callable 任务的 call() 并且获取返回结果，并调用 set(result); 将结果设置到 全局变量中让 get() 方便调用

同时 FutureTask 内部维护了一个队列

调用 get() 时，如果任务还没有完成，那么调用 awaitNode() 将线程封装为节点入队，然后挂起线程，等待 run() 执行完调用 set() 添加返回结果并且唤醒线程

awaitNode() 只会自旋 3 次：

- 第一次封装节点
- 第二次节点入队
- 第三次挂起线程，等待任务完成后被唤醒
给出一棵二叉树，其上每个结点的值都是 0 或 1 。每一条从根到叶的路径都代表一个从最高有效位开始的二进制数。例如，如果路径为 0 -> 1 -> 1 -> 0 -> 1，那么它表示二进制数 01101，也就是 13 。

对树上的每一片叶子，我们都要找出从根到该叶子的路径所表示的数字。

以 10^9 + 7 为模，返回这些数字之和。


	    1           
	  /   \
	 0     1         
	/ \   / \
   0   1 0   1
输入：[1,0,1,0,1,0,1]
输出：22
解释：(100) + (101) + (110) + (111) = 4 + 5 + 6 + 7 = 22
 

提示：

树中的结点数介于 1 和 1000 之间。
node.val 为 0 或 1 。

/*
	
		1           
	  /   \
	 0     1         
	/ \   / \
   0   1 0   1
	看最左边，从根节点到叶子节点，二进制数为 100
	最先遇到的是 1，然后遇到 0，对于这个 0，前面的结果需要左移一位 << 1，即 (1 << 1) + 0， 二进制为 10
	然后再遇到 0，对于这个 0，前面的结果需要左移一位 << 1。即 (10 << 1) + 0， 二进制为 100
	
	我们就使用前面结果 << 1 再 + root.val 的方式进行递归
	
	注意的是，我们需要先处理左右子树为空的情况，而不能递归到为空再处理，原因如下：
		1  一
	  /   
	 0     二
	/ 
   0   	   三
   当树为上述情况时，
   当我们在 二号节点时，它的右子树为空，当我们递归到最后才进行处理空节点，那么我们应该返回的结果二进制数是 10，即将到父节点的结果 sum 直接返回
   当我们在 三号节点时，它的左右子树为空，那么我们仍然递归它的左右子树，两边都为空，两边都返回 父节点的结果 sum = 100，那么这意味着会导致 100 重复添加
   
   因此我们需要提前处理空值，防止重复添加数据（这方法在 113. 路径总和 II 的时候也用过）
*/
class Solution {
    public int sumRootToLeaf(TreeNode root) {
        if(root == null){
            return 0;
        }   
        return dfs(root, 0);
    }
    private int dfs(TreeNode root, int sum){
        sum = sum * 2 + root.val;
        if(root.left == null && root.right == null){
            return sum;
        }
        if(root.left == null){
            return dfs(root.right, sum);
        }
        if(root.right == null){
            return dfs(root.left, sum);
        }
        return dfs(root.right, sum) + dfs(root.left, sum);
    }
}
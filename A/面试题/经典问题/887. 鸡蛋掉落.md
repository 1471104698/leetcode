## **[887. 鸡蛋掉落](https://leetcode-cn.com/problems/super-egg-drop/)**

```java
你将获得 K 个鸡蛋，并可以使用一栋从 1 到 N  共有 N 层楼的建筑。

每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。

你知道存在楼层 F ，满足 0 <= F <= N 任何从高于 F 的楼层落下的鸡蛋都会碎，从 F 楼层或比它低的楼层落下的鸡蛋都不会破。

每次移动，你可以取一个鸡蛋（如果你有完整的鸡蛋）并把它从任一楼层 X 扔下（满足 1 <= X <= N）。

你的目标是确切地知道 F 的值是多少。

无论 F 的初始值如何，你确定 F 的值的最小移动次数是多少？

 

提示：
1 <= K <= 100
1 <= N <= 10000
```



## **示例 1：**

```java
输入：K = 1, N = 2
输出：2
解释：
鸡蛋从 1 楼掉落。如果它碎了，我们肯定知道 F = 0 。
否则，鸡蛋从 2 楼掉落。如果它碎了，我们肯定知道 F = 1 。
如果它没碎，那么我们肯定知道 F = 2 。
因此，在最坏的情况下我们需要移动 2 次以确定 F 是多少。
```



## **示例 2：**

```java
输入：K = 2, N = 6
输出：3
```



## **示例 3：**

```java
输入：K = 3, N = 14
输出：4
```





## 方法①、递归（超时）

### 实现思路

要求的是安全楼层，那么如果鸡蛋在 F 楼碎了，但在 F - 1 楼没碎，那么安全楼层就是 F - 1
并且要求在所有可能发生的条件下找出最少的扔的次数，即所有的最坏情况中的最好情况

#### 1、过程说明

比如 N = 100，鸡蛋有 2 个，

- 第一个鸡蛋在 50 楼扔，存在碎和不碎两种情况
  - 如果碎了，表示安全楼层在 【1，49】，并且只剩下 1 个鸡蛋可以扔了，这时候我们只能一层一层测试
  - 如果没碎，表示安全楼层在 【50， 100】，还有 2 个鸡蛋可以扔，并且由于 50 我们测了，所以我们只需要再测【51，100】
  - 在测 【1，49】和【51，100】的时候，会存在最坏的情况，我们需要考虑的就是这个最坏的情况下的扔蛋次数

- 第一个鸡蛋在 10 楼扔，会存在对应的最坏的情况
- 第一个鸡蛋在 x 楼扔，会存在对应的最坏的情况
- 我们就是要求这所有的最坏情况中最好的情况，即最坏情况下扔的次数最少的

#### 2、为什么选择最坏的情况？

假设某一层 F 扔鸡蛋，在只有 K 个鸡蛋的情况下：

如果碎了的话，那么我们测试【1，F - 1】层，在只有 K - 1 个鸡蛋的情况下，假设我们只需要扔 2 次即可以测出来

如果没碎，那么我们测试 【F + 1, N】层，在只有 K 个鸡蛋的情况下，假设我们需要 10 次才可以测出来

虽然我们这里会希望它在这一层碎，因为扔的次数比不碎的次数少，但是问题贴近现实的话，实际上现实往往不会往我们预料的方向去发展，因此我们需要知道最坏的情况下需要的扔蛋次数，好有个充分的准备

#### 3、为什么选择最坏情况下最好的情况？

最开始，我们初始的扔蛋位置可以选择每一层楼，而对应的楼层都存在对应的最坏扔蛋次数

假设第一次在 10 楼扔的话的最坏情况需要扔 10 次，在 20 楼扔的话的最坏情况需要扔 5 次

那么我们为了更少的代价，肯定第一次会选择在 20 楼扔啊，因为在相同条件下所需的代价更少

我们就是要选择一个楼层，让最坏情况下的扔蛋次数（代价）更少，而不是考虑最理想情况下的扔蛋次数更少



#### 4、初始值设置

如果 N == 1，即只有一个楼层，那么无论有多少个鸡蛋，我们都只需要扔一次
如果 K == 1，即只有一个鸡蛋，那么我们必须保证在鸡蛋不碎的情况下去尝试所有的楼层，那么怎么做？
    我们只能从 1 楼开始扔，如果 1 楼碎了，那么安全楼层为 0，如果没碎，那么到 2 楼扔，再到 3 楼扔、... 、N 楼扔

最坏的情况需要扔 N 次

#### 5、递归方程

递归：我们从 F 楼扔，然后判断 碎 和 没碎 的递归情况
碎：    `superEggDrop(K - 1, F - 1) + 1`
没碎：`superEggDrop(K, N - F) + 1`



### 实现代码

```java
class Solution {
    public int superEggDrop(int K, int N) {
        if(N == 0 || K == 0){
            return 0;
        }
        if(K == 1){
            return N;
        }
        if(N == 1){
            return 1;
        }

        int maxCount = (int)1e9;
        for(int F = 1; F <= N; F++){
            maxCount = Math.min(maxCount, Math.max(superEggDrop(K - 1, F - 1), superEggDrop(K, N - F)) + 1);
        }
        return maxCount;
    }
}
```



## 方法②、记忆化递归（超时）

### 实现思路

添加缓存，因为某个楼层 N 可能存在重复计算

我们需要记录 K 个鸡蛋 和 N 个楼层这两个状态对应的最坏的扔鸡蛋数

### 实现代码

```java
class Solution {
    Integer[][] cache;
    public int superEggDrop(int K, int N) {
        /*
        K 个鸡蛋， N 层楼
        在 T 层进行实验，有碎和不碎两种情况
        如果碎了，那么安全楼层在 [1, T - 1]
        如果没碎，那么安全楼层在 [T, N]

        如果 N == 1，那么无论多少个鸡蛋都只需要扔一次
        如果 K == 1，那么由于只能扔一次，因此我们需要一层一层扔，最坏情况扔 N 次
        */
        //没有鸡蛋或楼层，那么扔的次数为 0
        if(cache == null){
            cache = new Integer[K + 1][N + 1];
        }
        if(cache[K][N] != null){
            return cache[K][N];
        }
        if(N == 0 || K == 0){
            return 0;
        }
        if(N == 1){
            return 1;
        }
        if(K == 1){
            return N;
        }
        //获取从每层楼扔，碎和不碎的情况
        int max = (int)1e9;
        for(int i = 1; i <= N; i++){
            max = Math.min(max, Math.max(superEggDrop(K - 1, i - 1), superEggDrop(K, N - i)) + 1);
        }
        return cache[K][N] = max;
    }
}
```



## 方法③、动规（超时）

### 实现思路

**思路跟 递归一样**

**状态转移方程：**
	`dp[i][j] `表示 有 i 个鸡蛋的情况下检测 j 层楼 最坏情况下，扔鸡蛋最少的次数
	在有 j 层楼的情况下，任选一层 k 扔鸡蛋，那么存在 碎 和 不碎 两种情况，取得其中最坏的情况
	`dp[i][j] = Math.max(dp[i][j], Math.max(dp[i - 1][k - 1], dp[i][j - k]) + 1);`



### 实现代码

```java
class Solution {
    public int superEggDrop(int K, int N) {
        int[][] dp = new int[K + 1][N + 1];
        //只有一个鸡蛋的情况
        for(int i = 1; i <= N; i++){
            dp[1][i] = i;
        }
        //只有一层楼的情况
        for(int i = 1; i <= K; i++){
            dp[i][1] = 1;
        }
        //遍历鸡蛋和楼层的状态
        for(int k = 2; k <= K; k++){
            for(int n = 2; n <= N; n++){
                dp[k][n] = (int)1e9;
                //遍历从 [1, n] 各个楼层扔的情况
                for(int j = 1; j <= n; j++){
                    dp[k][n] = Math.min(dp[k][n], Math.max(dp[k - 1][j - 1], dp[k][n - j]) + 1);
                }
            }
        }
        return dp[K][N];
    }
}
```



## 双蛋问题

在 N = 100，K = 2 的情况下，我们怎么去扔蛋？

如果我们按间隔 n = 10 去扔的话

那么最坏的情况下，【1，90】都没有碎，这时候扔蛋次数为 9 次

然后在第 100 层的时候碎了，这时扔蛋次数为 1 次

那么我们就需要使用剩下的一个鸡蛋在【91，99】之间一层一层扔，共需要 9 次

那么总共扔蛋次数为 9 + 1 + 9 = 19 次

*![image.png](https://pic.leetcode-cn.com/36fb64021620faaa217eed6ba8e920f15ae37ba6d393c03de10156bdeea9f413-image.png)*



由于我们上面间隔取 n = 10，相同间隔，而越往后扔蛋次数就越增加，如果在10 层不碎的话，那么需要往 20 层扔，次数 +1，如果 20 层不碎的话，那么需要往 30 层扔，次数 +1

但是间隔是一样的，即如果在后面的楼层碎的话，仍然需要 【x1,x9】这 9 次扔蛋，

那么能否通过缩减间隔的方法，来减少扔蛋次数呢？

我们假设第一次扔蛋的区间长度为 n，不碎，第二次扔蛋区间长度为 n-1，不碎，第三次扔蛋区间长度为 n-2,不碎，直到最后 扔蛋区间长度为 1

那么有 1 + 2 + 3 + 。。。 + n >= 100，那么 n >= 13.65，即 取 n = 14

那么我们第一次扔蛋在 n = 14 层楼扔，如果不碎，那么到 14 + 13 = 27 层楼扔，如果不碎，那么到 27 + 12 = 39 层楼扔，直到最后，由于我们区间长度是递减的，

如果我们在 14 层楼碎了，那么我们需要测试 【1，13】，总共 1 + 13 = 14 次

如果我们在 27 层楼碎了，那么我们需要测试 【15，26】，总共 1  + 1 + 12 = 14 次

我们在 27 层楼的时候，通过缩减区间变成 n - 1，来中和掉 14 层楼时的一次扔蛋次数

*![image.png](https://pic.leetcode-cn.com/9265db2929f73e095579af459fb0c2c637a312337793239649d3f3d759de4938-image.png)*
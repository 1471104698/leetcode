# 进程间的通信方式



## 引言

我们需要知道的是，不需要去细分什么 "同步" 和 "通信" 的关系，而是当作 能够 "通信" 那么就一定是一种同步机制

所有的通信方式如下：

![img](https://pic4.zhimg.com/80/v2-c6aeb64f7e87579f12f6cc2c92dc95c0_720w.jpg)





## 1、管道

管道有两种：匿名管道 和 命名管道



> ### 匿名管道

匿名管道是存在于内存当中的，而不存在文件形式，管道实际上就是内核中的一个缓冲区，数据写入都放到这个缓冲区中

```java
ps auxf | grep
```

上面的 "|" 就是一条匿名管道，需要的时候就创建，用完就直接销毁，没有名字的，跟 java 的匿名内部类一样

比如下面这段 java 代码，传入了一个 Runnable 的匿名类对象，用完即毁

```java
new Thread(() -> {
    System.out.println(1);
}).start();
```



它是将 "|" 前面的命令输出结果当作写入到管道中，而 "|" 后面的命令会去读取管道内的数据

图示如下：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190522031913582.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyODk2NjI3,size_16,color_FFFFFF,t_70)





匿名管道的调用方法：

```C
int pipe(int fd[2]);
```

fd[2] 中一个作为写端，一个作为读端

匿名管道只能用于父子进程间的通信，即当前进程创建 管道，它内部是调用 fork() 创建子进程，然后进行通信

父进程调用 pipe()，传入两个 fd，然后再调用 fork() 创建出来的子进程会同时复制 父进程的 fd

这样父进程使用 fd[0] 进行读取， 子进程使用 fd[1] 进行写入，完成通信



比如下面，父子进程的 fd 都一样的，都是 3 和 4，不过父进程使用 fd = 4，子进程使用 fd = 3，这样就不会存在干扰

![clipboard.png](https://segmentfault.com/img/bVN8RW?w=548&h=557)



> ### 命名管道

```java
 mkfifo myPipe
```

上面是创建了一个 名字为 myPipe 的管道，它是以文件形式存在的，可以进行复用，并且不局限于父子进程，即本机进程都可以使用这个管道进行通信，不过通信前需要指定是哪两个进程，比匿名管道麻烦点



> ### 管道的缺点

- 使用管道进程会阻塞，如果没有数据需要阻塞等待数据，不适合频繁的交换数据

- 只能单向传输，如果要双向通信，那么需要创建两个管道

- 匿名管道只能使用在父子进程

  

## 2、消息队列 

管道不适合进程间的频繁通信，因为进程会阻塞，效率低

而消息队列就能够解决这个问题

消息对队列是保存在内核中的消息链表，进程间的通信数据结构就是 数据块（类似链表的 Node 节点）

当进程 A 要给进程 B 发消息时，将数据封装在数据块中，然后放入消息队列，然后就可以返回做其他事了

而进程 B 需要的时候再去读取数据就可以了

类似我们平时发的电子邮件，你一封我一封，可以频繁交流

但是这种邮件形式的方式也有缺点：

- 一是信息不具有即时性，由于邮件什么的什么时候都可以看，因此可能今天看的这封邮件是几天前发的

- 二是邮件大小也有限制

我们上面说了，数据是封装在 数据块的，它也是一种数据结构，那么内部肯定是使用数组实现的，那么就有对应的大小限制



> ### 消息队列的缺点

- 由于消息队列内部是使用数组来存储数据的，那么存在大小限制，不适合大数据的传输
- 消息队列用于不需要实时性的数据传输



## 3、共享内存

具体看 [udp卷2 共享内存 1](https://blog.csdn.net/u010129119/article/details/77949579?utm_medium=distribute.pc_relevant.none-task-blog-title-3&spm=1001.2101.3001.4242)

[udp卷2 共享内存 2](https://blog.csdn.net/enlyhua/article/details/79888868?utm_medium=distribute.pc_relevant.none-task-blog-title-2&spm=1001.2101.3001.4242)



共享内存是 多个进程拿出某些虚拟页，然后再从用户态内存中拿出一块物理内存，将进程的虚拟页共同映射到这块物理地址上

这样的就它们的数据交流就不需要经过内核态缓存了



**我们讲的拷贝是什么？**

数据从 磁盘到内核 以及 从内核到磁盘 的拷贝 都是借助 DMA 来实现的，这里不涉及到 CPU，我们讲的 拷贝都是 CPU 来实现的，都是需要占用 CPU 资源，因此我们减少拷贝次数目的就是为了提高 CPU 效率



**管道/消息队列存在四次用户态和内核态之间的拷贝：**

- 进程 A 调用系统函数 read() 读取文件 A，DMA 将文件 A 从磁盘拷贝到内核 buffer，CPU 将内核 buffer 的数据拷贝到 用户态**（发生一次内核态到用户态的拷贝）**
- 进程 A 调用 write()，CPU 将 数据拷贝到 内核态的 缓存中（缓存可以是 管道或者消息队列，这个缓存跟上面的 buffer 不一样，上面的是内核态常驻的，这里的缓存是为了通信而开启的）**（发生一次用户态到内核态的拷贝）**
- 进程 B 调用 read()，CPU 从内核态缓存中读取数据**（发生一次内核态到用户态的拷贝）**
- 进程 B 调用系统函数 write() 将数据 写到文件 B 中，CPU 将数据从用户态拷贝到内核态，然后写回到磁盘中**（发生一次用户态到内核态的拷贝）**

![img](https://img-blog.csdn.net/20170912211559441)

**共享内存只需要两次拷贝：**

- 进程 A 调用系统函数 read() ，DMA 读取文件到内核态缓存，CPU 将数据从内核态拷贝到用户态的共享内存中（发生一次内核态到用户态的拷贝）
- 进程 B 调用系统函数 write() ，CPU 将共享内存中的数据拷贝到内核态，DMA 将内核态缓存的数据写入文件，（发生一次用户态到内核态的拷贝）

![img](https://img-blog.csdn.net/20170912211610292)

简单讲，共享内存减少的两次拷贝就是 进程 A 和 进程 B 之间的数据通信



> ### 共享内存的缺点

多线程下共享资源的不合理竞争，导致数据错乱



## 4、信号量（PV，为共享内存服务）

共享内存存在进程不安全的问题，即会发生数据错乱，因此需要保护机制，**保证共享内存一次只能由一个进程访问**

**信号量是为共享内存服务的，（Java 中的 sync 锁 和 lock 锁实际上是 信号量的一种特殊情况，只有一个可用资源）**



信号量涉及两个操作：P 和 V

P 操作是将可用资源数 -1，V 操作是将可用资源数 + 1

**过程：**

- 信号量初始化为 1
- 当 进程  A 先到达时，执行 P 操作，发现信号量为 0，那么可以访问数据

- 当 进程 B 到达的时候，执行 P 操作，发现信号量为 -1，那么陷入阻塞状态

- 等到 进程 A 访问完数据，执行 V 操作，信号量 +1，变成 0，唤醒 进程 B
- 进程 B 访问完数据，执行 V 操作，信号量 +1，变成 1

这样做就很好的保护了共享内存



上面这个是信号量用来互斥的，但有时我们就需要实现 生产者-消费者模式，同样可以使用 PV 来实现

比如 进程 A 是生产者，进程 B 是消费者

 ![img](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZckxn1SzJ697nE1m1wJzmPQlO6zu8K0xlLpDBbew0jVibibhVm59TQy4ibJSZKxqKsWOrcLIibZE6RAVg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1) 

**过程：**

- 信号量初始化为 0，表示当前无数据 可消费
- 如果 进程 B 先执行 P 操作，发现信号量为 -1，那么进入阻塞状态
- 之后 进程 A 执行，生产数据，然后执行 V 操作，信号量 +1，变成 0，唤醒 进程 B 进行消费



## 5、信号（异常通信）

上面的几种通信方式包括下面的 socket，都是正常情况下的进程间通信，比如交换数据之类的

信号的使用：

- 在异常情况下的通信方式，比如杀死一个进程，子进程 exit 后通知父进程进行收尸防止变成僵尸进程，就会使用到 信号
- kill 指令就是发送信号，表示立即停止该线程

- 当某个进程陷入阻塞，比如我们 mysql 在事务中进行当前读的时候需要锁，而锁被别的事务获取了，所以会陷入阻塞，那么这时候可以通过 crtl + c 发送信号来中断等待



## 6、Socket（不同主机通信）

上面的几种通信方式，都是在同一台主机上面的进程间的通信方式

如果要跨网络或者主机，就要使用 socket 通信



当我们进行远程传输文件时，数据拷贝是这样的：

- 用户进程 user 调用 read() 读取文件 A，DMA 将磁盘文件 A 的数据拷贝到内核态的 buffer
- CPU 将 内核态的 buffer 数据拷贝到用户态空间（第一次拷贝）
- CPU 再将刚刚拷贝到的用户态空间的数据 再 拷贝到 内核态的 socket 空间的数据（第二次拷贝）

socket 传输文件的拷贝有点类似 共享内存，都是两次数据拷贝，但是实际上只有一个用户进程 user 在进行处理，并不涉及到进程间的数据通信，很显然，这个从内核态到用户态，再将相同的数据从用户态到内核态的这两次数据拷贝显然是很多余的

<img src="https://img-blog.csdnimg.cn/20201009162057988.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDAzODMzMg==,size_16,color_FFFFFF,t_70#pic_center" style="zoom:60%;" />





> #### 零拷贝技术的发展

零拷贝：准确的说是 用户态零拷贝技术，即不涉及到 内核态拷贝用户态 以及 用户态拷贝到内核态 的过程，允许存在 内核态拷贝到内核态



**1、mmap()**

使用 mmap() 来代替 read()

```C
buf = mmap(diskfd, len);
write(sockfd, buf, len);
```

mmap() 实现过程：

- 用户进程调用 mmap() 读取某个文件，DMA 将磁盘文件数据拷贝到 内核态 buffer
- 操作系统会将这段 buffer 和 用户进程共享，这样用户进程调用 write() 就是直接将 内核态 buffer 中的数据拷贝到 内核态 socket 中

可以看出减少了一次从内核态到用户态的拷贝，但是还是存在从 内核态 buffer 到 内核态 socket 的一次 CPU copy

<img src="https://img-blog.csdnimg.cn/2020100916373817.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDAzODMzMg==,size_16,color_FFFFFF,t_70#pic_center" style="zoom:60%;" />



**2、sendfile()**

Linux 2.1 版的内核，出现了 sendfile() 来简化 read() 和 write() 操作

当需要直接向 socket 传输数据时，用户进程不再需要先调用 read() 读取文件，再调用 write() 写入文件了，直接调用一个 sendfile(fd) 表示直接向某个 socket 传输文件

```C
ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count);
```

sendfile() 实现过程：

- 用户进程调用 sendfile()，指定需要传输的文件的 fd 和 socket 的 fd，DMA 将磁盘数据拷贝到内核态 buffer
- CPU 将内核态 buffer 数据拷贝到 内核态 socket

可以看出同样是存在一次 CPU copy，但是这次数据拷贝不涉及到 用户进程，因此相比 mmap() 减少了 用户态 和 内核态的上下文切换，因为数据传输只发生在内核态

<img src="https://upload-images.jianshu.io/upload_images/272719-5c49aebc85085726.PNG?imageMogr2/auto-orient/strip|imageView2/2/w/626/format/webp" style="zoom:70%;" />


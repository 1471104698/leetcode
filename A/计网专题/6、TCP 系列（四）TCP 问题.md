# TCP 问题

## 1、SYN Flood（攻击半连接队列）

**服务端存在两个队列，一个是 SYN 队列（半连接队列），一个是 Accept 队列（连接队列）**

SYN 队列是存储第一次握手接收到的客户端的 SYN 请求，将这个请求放到 SYN 队列中，

Accept 队列是 第三次握手，服务端收到客户端的 ACK 后，将连接从 SYN 队列移除，放到 Accept 队列 中，然后应用程序通过调用 `accept() ` 来获取 Accept 队列 中的连接



正常流程：

- 当服务端接收到客户端的 SYN 报文时，会将其加入到内核的「 SYN 队列」；
- 接着发送 SYN + ACK 给客户端，等待客户端回应 ACK 报文；
- 服务端接收到 ACK 报文后，从「 SYN 队列」移除放入到「 Accept 队列」；
- 应用通过调用 `accpet()` socket 接口，从「 Accept 队列」取出的连接。

![1597974574685](C:\Users\蒜头王八\AppData\Roaming\Typora\typora-user-images\1597974574685.png)



SYN 攻击是针对三次握手的，假设攻击者短时间伪造不同 IP 地址的`SYN` 报文，服务端每接收到一个 SYN 报文后，会将这个连接放到 SYN 队列

当 服务端 发送 ACK + SYN 却没有收到 ACK ，那么这个连接会一直待在 SYN 队列，导致队列被塞满，无法响应正常用户的连接请求



> ### 解决方法：SYN cookie

正常的 TCP 连接：有一个 SYN 队列，用来存储 收到了 SYN 包但是还没有收到 ACK 包的 TCP 连接，当服务端接收到 SYN 包，回发一个 SYN + ACK 包后会将在 SYN 队列中开辟一个内存空间存储这个 TCP 连接

SYN cookie 是对三次握手进行改造，接收方不会将 TCP 连接存储在 SYN 队列中，根据 TCP 规范，在发送 SYN + ACK 包时，数据包存在一个初始序列号，这个序列号是接收方自己制定的，SYN cookie 就作为这个包的初始序列号

这个 SYN cookie 涉及到密码学的加密，是无法进行伪造的

当发送方接受到 SYN + ACK 包后，根据里面的 seq 发送 ACK 包，且序列号为 seq + 1

接收方收到 ACK 包后获取 seq，使用 seq - 1 得到 SYN cookie 进行计算，校验成功那么表示是正常的连接





## 2、TCP 半打开连接 和 半关闭连接

TCP 连接是全双工的

全双工：一个端点 既能够发送数据又能够接收数据

半双工：一个端点 只能够发送数据或者接收数据

半打开连接和半关闭连接就是相对全双工来说的，TCP 连接的端点中存在一个端点只能发送数据或者接收数据



> ### 半打开连接

从 TCP 协议上看，半打开连接是指 TCP 其中一个端点 A 异常断电 或者 关闭时未告知另外一个端点 B，这种情况下 端点 A 就不能正常接收数据，如果 B 给 A 发送数据，那么 A 会回发一个 RST 包

从 Linux 实现的角度看，Linux 上 三次握手时有个 SYN 队列，这时没有收到 ACK 包的 TCP 连接都存储在 SYN 队列里，称作半连接，应该可以叫做半打开连接



> ### 半关闭连接

一个端点 A 发送了 FIN 包，一个端点 B 还没有发送 FIN 包，这样的话，端点 A 是不会发送用户数据，但可以发送 FIN 包 和 接收数据，端点 B 可以发送数据也可以接收数据，这样的 TCP 连接就处于半关闭状态

比如四次挥手（FIN - ACK - FIN - ACK），发送方发送了 FIN 包，而接收方可能还有数据要处理，因此不会立马发送 FIN 包，只会发送一个 ACK 包，这时候 TCP 连接是 半关闭连接；等到接收方处理完数据完，发送 FIN 包





## 3、MSS 如何确定

MSS：TCP 最大报文段长度，即除去 TCP 头部、IP 头部 后 TCP 所能发送的真正的用户数据

在 数据链接层上转发 的 IP 报文是有一定的长度限制的，这个长度限制就是 MTU（最大传输单元），当 IP 报文超过这个长度，那么就会进行 IP 分片，使得每一片都小于 MTU，才能进行转发

因此，**MSS = MTU - TCP 头部（20字节） - IP 头部（20字节）**



使用 MSS 是为了在 TCP 层进行分片，而避免在 IP 层进行分片，因为一旦在 IP 层进行分片，那么只要存在任何一片丢失，整个 TCP 报文就需要重新发送一次，这样重发的概率就加大了，明显不划算





## 4、长连接、短连接

所谓的连接指的是 TCP 连接，而不是 HTTP 连接

短连接就是 TCP 短连接，长连接就是 TCP 长连接

HTTP 协议实际上没有连接一说，平常所说的 HTTP 连接实际上就是 TCP 连接，

HTTP 协议是基于 请求/响应的，当收到一个请求，返回一个响应后，这个 HTTP 请求就结束了



当使用短连接时， 三次握手后，一般是进行一次 HTTP 请求/响应后就发起 close()，然后进行四次握手，即一个 TCP 短连接对应一个 HTTP 请求，

```
HTTP 1.0 的时候使用的就是短连接，由于一个 HTTP 请求/响应表示一个短连接，也导致了一个请求在没有得到响应前是不能发送另外一个请求的
```



当使用长连接时，三次握手后，这个 TCP 连接可以复用，即可以进行多次 HTTP 请求/响应，当一段时间没有 HTTP 请求/响应时，这个长连接就会断开

```
HTTP 1.1 使用的管道就是建立在长连接的基础上的，可以同时发送多个请求，然而响应的顺序还是根据请求的顺序来的
```





HTTP 协议是运行在应用层上的协议，它不会管数据的传输，它只负责告诉 TCP 哪些数据要发送，以及从 TCP 那接收数据

而 TCP 来保证数据的可靠传输，作为发送方就需要保证数据的可靠发送，作为接收方就需要保证数据的有序

HTTP 将数据交给 TCP，TCP 会按照特定情况进行封装，标记上序列号之类的，然后进行发送，丢失了还会进行重发

TCP 接收方获取到数据后，会根据序列号进行拼接，然后将拼接好的有序数据交给 HTTP

而实际数据的传输是 TCP 交给 IP 来做的



## 5、TCP 保活定时器

保活计时器是建立在长连接的基础上的，即开启  Keep Alive 来使用长连接的时候同时也会使用这个功能，即是跟长连接绑定的



服务端存在一个计时器，当一个 TCP 连接在一段时间内（默认 2h）没有任何 HTTP 请求/响应时，那么服务端会发送探测报文给客户端，一共会发送 10 次，每次间隔 75s，客户端有以下几种状态：

- 客户端正常，那么会回应探测报文，服务端收到回应报文后会重新开始计时
- 客户端断电或者正在重启，无论是哪一种，客户端都不会回应报文，因此服务端发送完 10 次探测报文后会认为客户端已经断开了，那么就将 TCP 连接断开
- 客户端断电后重启，那么保存的连接都消失了，这时收到探测报文，客户端会认为这是一个不存在的连接，因此会发送一个 RST 报文，告知服务端发生异常，直接断开连接
- 客户端正常，但是网络拥堵，导致服务端发送 10 次后没有收到回应报文，那么断开连接

保活计时器的作用就是避免客户端出现问题了，而服务端不知道，一直在保持着连接，浪费资源





## 6、CLOSE_WAIT 状态

CLOSE_WAIT 和 TIME_WAIT 数量大的时候造成的影响很相似

CLOSE_WAIT 是被动关闭的状态

TIME_WAIT 是主动关闭的状态



当 被动关闭的一方 比如服务端 接收到客户端发送的 FIN 报文时，会回发一个 ACK 报文，但是这时候可能还有数据没有进行处理，因此不会立即发送 FIN 报文给客户端

在发送 FIN 报文前，客户端处于 FIN_WAIT2 ，服务端处于 CLOSE_WAIT

（当客户端接收到 FIN 报文后会从 FIN_WAIT2 转变为 TIME_WAIT）

 ![img](https://img2018.cnblogs.com/blog/519126/201905/519126-20190528133127642-1380534897.png)

可以发现，当服务端发送出一个 FIN 后，就从 CLOSE_WAIT 转变为 LAST_ACK

 

> ### 服务器出现大量 ClOSE_WAIT 的原因

在客户端发送 FIN 后，服务端回应一个 ACK，这时候如果服务端有数据处理，那么就会继续处理数据，处于 CLOSE_WAIT 

如果处理数据的时间过长，那么就会很长时间处于 CLOSE_WAIT，而客户端一直等不到 FIN，等待超时了就直接关闭连接了



ClOSE_WAIT 就是服务端没有发送出去 FIN，而没有发送出去的常见原因就是 没有关闭 socket 连接 或者 其他的阻塞操作：

- 使用数据库连接池，在 CLOSE_WAIT 阶段请求数据库连接的时候，如果忘记在使用完连接后关闭，那么其他的请求会一直占用数据库连接导致当前请求无法获取到连接，进而阻塞，长期处于 CLOSE_WAIT 状态
- 处理完数据后忘记调用 close() 关闭 socket 连接，这样就不会发送 FIN 给客户端



**默认处于 ClOSE_WAIT 的时间最长为 2h，解决方法就是修改参数来缩短 ClOSE_WAIT 的时间**

> ### 出现大量 ClOSE_WAIT 的危害

每一个 ClOSE_WAIT 跟 TIME_WAIT 一样，都是需要占用文件描述符的，而一个进程的文件描述符数量是有限的

如果都被 ClOSE_WAIT 占用了，那么就无法获取新的 socket 连接了

还有一点就是 ClOSE_WAIT 会占用内存资源





## 7、TIME_WAIT 状态

> ### 为什么需要 TIME_WAIT  状态？

- 确保 TCP 全双工正常关闭

  ```
  比如客户端发起 FIN，这时候客户端关闭了发送数据的能力，服务端接收到后发送 ACK，后续再发送 FIN，这时候服务端也关闭了发送数据的能力，如果客户端收到服务端的 FIN 后回应一个 ACK 后就断开连接，那么如果由于网络拥堵等问题服务端没有收到 ACK，服务器就会重发 FIN，而客户端关闭连接后不会保存上一个连接的信息，因此收到后会发现这是一个不存在的连接，因此会发送一个 RST 包，服务端收到 RST 包后就会触发异常，不能正常关闭
  ```

- 确保旧数据包不会应用到新的连接中

  ```
  如果客户端第一次发送 FIN，但是由于网络问题没有到达服务端，超时重发 FIN 包，而后收到服务端的 ACK 和 FIN 包后回应一个 ACK 客户端就关闭了，然后后面客户端又用这个相同的【四元组】起一个新的连接，此时如果刚刚最开始发送的 FIN 到达服务端，并且序列号也对的上，那么就会导致新建的连接出现了混乱。。。
  ```



> ### 为什么 TIME_WAIT 是 2MSL？

一个包的最大存活时间为 MSL
客户端给服务端发送 ACK 报文后，假设经过时间 t

- 如果服务端能够接收到 ACK 报文，存在 0 < t < MSL
- 如果服务端没接收 ACK 报文，存在 t >= MSL



服务端等待 ACK 报文时间最大为 MSL，而如果等不到发送了 FIN 报文 或者在接收到 ACK 报文的一瞬间发送了 FIN 报文，这个 FIN 到达客户端的时间最大也为 MSL

因此在 ACK 发送到 服务端，再到服务端重发 FIN 到达客户端的这个时间端，临界逼近 2MSL，因此 TIME_WAIT 设置为 2MSL



**在这 2MSL 里，这个【四元组】是不能被建立起新的连接的，因此就防止旧的 FIN 包影响到新的连接**

2MSL 是考虑最坏情况下的时间，尽管很多时候都是不存在这个极端情况的，但是总归是要防止 "万一"





> ### 服务端出现大量 TIME_WAIT的原因

高并发情况下，服务端主动发起关闭



> ### TIME_WAIT 过多的问题

客户端一个 socket 连接占用一个端口，当大量 TIME_WAIT 导致客户端端口占满时，那么客户端就无法建立新的连接

服务端一个 socket 连接占用一个文件描述符 和 4KB 内存，文件描述符的个数是有限的，因此当大量 TIME_WAIT占满了文件描述符，那么就无法建立起新的连接，并且还占据内存



> ### 大量 TIME_WAIT 解决

- 调整参数缩短 TIME_WAIT 时间
- 使用长连接代替短连接（不过一般不这么用，长连接只是取消了 TIME_WAIT 的状态，在没有请求的情况下照样是 占用一个文件描述符）
- 开启 TIME_WAIT 快速回收与重用
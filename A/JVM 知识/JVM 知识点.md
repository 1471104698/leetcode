# JVM 知识点



**我们需要先知道，Java 有两种对象：实例对象 和 Class 对象**

## 1、类编译 到 类加载 过程 及 产物





> ### 类编译

当我们写完代码后，生成的是一个 .java 的静态文件，这个文件在磁盘中

当我们点击运行 .java 文件的时候，它会先开始编译，将代码转变成二进制数据，其中是一条条的指令，变成 .class 文件（字节码文件）



> ### 类加载

JVM 将某个 .class 文件中的二进制数据加载进内存中，创建出对应的一个 `java.lang.Class` 对象，类加载的最终产物就是 JVM 中的 Class 对象



### 1.1、什么是 Class 类（类加载的最终产物）

---



> ### `java.lang.Class` 类 和 我们自己写的类的关系

除了 int 等基本数据类型之外**（基本数据类型不是类）**，**Java 的其他类型（包括 interface）都是 Class 类的实例**

其他类（接口）是 Class 类的实例？ 那么 Class 类是谁写的？

Class 类是 `jvm` 动态加载进内存的，它是 private 类型的，用户无法自己创建

```java
public final class Class {
    private Class() {}
}
```



Class 类里包含了 某个 class 类的所有方法变量信息，当 JVM 加载一种新的 class 类的时候，比如 String 类，那么就会**获取 String 的信息，为这个 String 类创建一个 Class 类实例，然后关联起来**

```java
Class cls = new Class(String);
```



也就是说，**除了 Class 外的其他所有 class 类，每个 class 类对应一个 Class 类实例，在 JVM 中的类都是 Class 实例**

```ascii
┌───────────────────────────┐
│      Class Instance       │──────> String
├───────────────────────────┤
│name = "java.lang.String"  │
└───────────────────────────┘
┌───────────────────────────┐
│      Class Instance       │──────> Random
├───────────────────────────┤
│name = "java.util.Random"  │
└───────────────────────────┘
┌───────────────────────────┐
│      Class Instance       │──────> Runnable
├───────────────────────────┤
│name = "java.lang.Runnable"│
└───────────────────────────┘
```



**注意：是一个 class 类对应一个 Class 实例，而不是一个 class 对象对应一个 Class 实例，即相当于我们平常的内存中的 Cat 类，它是一个 Class 实例，不过这个 Class 实例的名字对外暴露的是 Cat，它具有我们自己写的对应的变量，然后使用这个 Class 对象创建出更多的我们自定义的 所谓的 Cat 实例对象**





> ### 反射的概念

换言之，所有 class 类的信息都存储在对应的 Class 类实例中，那么我们只需要获取对应的 Class 类实例，就意味着获取了这个 class 类的所有信息，**通过`Class`实例获取`class`信息的方法，就是反射**



### 1.2、类加载的基本知识点

---

类加载需要知道几个基本知识点：

- JVM 只有在 两个类 的 类名（包名 + class 类名）相同 并且 由同一个类加载器加载的时候，才算作是同一个类
- 父类加载器加载的类子类可以看到，子类加载器加载的类父类看不到





### 1.3、双亲委派模型

---



> ### 什么是双亲委派模型？



当某个类加载器要加载类的时候，会将这个类一层层传递给父类加载器加载，如果父类加载器有这个类，加载成功，那么返回成功，否则就自己加载，这就是双亲委派模型



> ### 双亲委派模型的过程

ClassLoader 中有两个主要方法：loadClass() 和 findClass()

**其中 加载类的方法主要是 loadClass()，而 findClass() 是一个空方法，它需要子类去实现**

**loadClass() 是双亲委派机制的逻辑体现，而 findClass() 是类加载器对类进行加载的逻辑**

双亲委派模型加载过程：

- findLoadedClass() 判断该类是否已经被加载过了
- 如果没有，则判断当前加载器的父加载器是否为空，不为空那么交给父加载器去加载
- 如果为空，那么表示父加载器是 根加载器，那么交给根加载器去加载
- 如果都加载不成功，那么调用 findClass() 方法，进行加载（这里我们可以看出，我们自定义类加载器主要实现加载逻辑就是将 parent 设置为 null，这样根加载器肯定加载不了，然后再重写这个 findClass() 方法）

```java
    protected Class<?> loadClass(String name, boolean resolve)
        throws ClassNotFoundException
    {
        synchronized (getClassLoadingLock(name)) {
            //查看这个类是否自己已经加载过了
            Class<?> c = findLoadedClass(name);
            
            if (c == null) {
                long t0 = System.nanoTime();
                try {
                    //父类加载器不为空
                    if (parent != null) {
                        c = parent.loadClass(name, false);
                    } else {
                        //父类加载器为空，调用根类加载器加载
                        c = findBootstrapClassOrNull(name);
                    }
                } catch (ClassNotFoundException e) {
                }

                if (c == null) {
                    //调用自己的加载逻辑
                    c = findClass(name);
                }
            }
            return c;
        }
    }
```



> ### 双亲委派模型的好处



最开始也说了，JVM 认定类的原理，如果我们不使用双亲委派模型，自己写了一个 `java.lang.Object` 类，那么将会由 `AppClassLoader` 去加载

由于官方的 Object 类 和 我们自定义的 Object 类的类加载器不同

那么内存中就存在两个 Object 类，那么当我们使用 Object 类的时候，导入的` java.lang.Obejct`，也不知道是哪一个类

编译不会出错，但是运行会出错

```java
package java.lang;
//自定义 java.lang.Object 类
public class Object {
    public static void main(String[] args) {
        Object object = new Object();//编译不报错，运行报错
    }
}

```

  

双亲委派机制的好处：

- 用户写的类覆盖核心类
- 避免类重复加载（如果不是双亲委派，那么多个类加载器加载同个类，内存中就存在重复对象，并且算作是不同的对象，因为我们上面说了，只有被同个类加载器加载的类才是相同的类）



> ### 如何打破双亲委派机制

双亲委派模型的体现主要就是 ClassLoader 中的 loadClass() 方法

它会先调用父加载器进行加载，失败了才调用当前类加载器的 findClass() 

因此，我们自定义一个类加载器，有两种选择：

- **重写 loadClass() 方法：**自定义类加载的模型，这样就**破坏了双亲委派机制**
- **重写 findClass() 方法：** 将自定义类加载器的父类加载器设置为 null，这样就默认父加载器是根类加载器，它必定不能加载我们自己写的类，因此会交给我们自定义类加载器进行加载，因此我们重写 findClass() 方法，自定义类加载逻辑，但这实际上**并没有打破类加载机制**，因为它还是存在委托给 根类加载器的情况，虽然没起什么作用就是了



> ### 为什么要破坏双亲委派模型

**看起来双亲委派机制好像挺好的，那么为什么还需要打破呢？**

对于一般情况下，用户类使用的是基础类，但是有的情况下，基础类也需要使用到用户类

在基础类的代码中使用用户类，该用户类需要加载，那么怎么进行加载？看调用方法，比如 Class.forName()，它的方法逻辑是使用调用类的类加载器进行加载的，如果是 基础类内部调用了 Class.forName()，并且加载的是一个用户类，显然，根类加载器是无法加载这个用户类的，因为 根类加载器只能加载特定的类，那么需要调用 AppClassLoader 来加载这个类，这样，从父类加载器调用子类加载器加载类，就破坏了双亲委派机制



**什么时候基础类会去使用用户写的类呢？**

SPI 机制：service provider interface（服务提供商接口）

比如 jdbc，jdk 提供的是一个规范接口 Driver，并不提供实现，提供实现的是数据提供商，它们的所有实现都需要根据这个 接口规范，而在第三方的类总不能放在 jdk 目录里作为基础类被 根加载器加载吧。。。

为什么这里会说 第三方实现类是由 根类加载器加载的，我们需要从没有 SPI 的时候说起

在没有 SPI 的时候，jdbc 我们不能使用接口编程，即不能：

```java
Class clz = Class.forName("java.sql.Driver"); Driver d = (Driver)clz.newInstance();
```

通过反射 Driver 类，因为 Driver 只是一个接口，没有具体的实现类，这样会报错

我们可以在  classpath 中引入一个  mysql-connector-java.jar ，里面有 Driver 的一个实现类，因此我们可以写成

```java
Class clz = Class.forName("com.mysql.jdbc.Driver"); Driver d = (Driver) clz.newInstance();
```

具体反射这个实现类，这就是我们自己硬编码指定加载某个类

这样的硬编码显然不合适，这种做法无法面向接口编程

因此，引入了 SPI 后，代码就变成：

```java
Connection connection = DriverManager.getConnection("jdbc:mysql://xxxxxx/xxx", "xxxx", "xxxxx");
```

DriverManager 自动根据 jdbc:mysql 去找实现，而 DriverManager 是根类加载器加载的，这样的话，它找到实现类，这个实现类是第三方类，使用默认的双亲委派机制的话，它没有父类，而自己(根类加载器)也无法加载，因此，就引入了线程上下文类加载器，可以通过线程上下文类加载器获取 AppClassLoader，来加载这个第三方类





## 2、JVM 内存模型



**JVM 内存结构有三大块：方法区、堆内存 和 栈**

其中，堆内存是最大的一块

**堆内存 和 方法区 是线程共享的，栈 是线程私有的**



### 2.1、堆内存

---

堆内存 是 JVM 内存中最大的一块内存，基本上所有 的实例对象都是在这里分配内存，即基本上所有的实例对象都是存储在堆内存中

堆内存分为：新生代和老年代

当堆内存无法给新的实例对象进行内存分配的时候，那么就会抛出 OutOfMemoryError 的异常



### 2.2、方法区

---

存储 JVM 加载的类的信息、常量、静态变量、代码段等



**当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。**



### 2.3、虚拟机栈

---

虚拟机栈 跟 上面两个内存模型不同，它是线程私有的

**是 JVM 用来描述 Java 方法执行的内存模型**

每当一个方法被调用时，就会创建一个新的栈帧，当某个方法执行完毕后，那么就会将栈顶的栈帧弹出

由于是栈模型，所以表示栈顶的栈帧是最新的，即对应的是当前正在执行的方法

并且由于每个线程都有自己的调用链，所以栈只能是自己私有的，各个线程的方法调用必须是独立



栈的内存空间也是有限的，即存储的栈帧是有限的，即递归调用的方法数是有限的

如果一直深入递归，那么就会栈溢出，那么抛出 StackOverflowError 异常

```java
package cn.oy;

public class Fuxk {
    public static void main(String[] args) {
        dfs();
    }
    public static void dfs(){
        dfs();
    }
}
```





## 3、JVM 内存分配策略



JVM 内存分配 有 5 钟策略

**注：新生代划分为 伊甸区 和 两个幸存区**



> ### 对象优先进入新生代

大多数情况下，对象都是在 伊甸区 中分配内存，如果不存在连续内存进行分配的话，那么就会触发一次 GC



> ### 大对象直接进入老年代

大对象是需要大量连续的内存空间的，比如大数组和超长字符串，因此我们需要尽量避免这种短命大对象，避免占据了大量的空间导致触发 GC

对于多大的对象才直接进入老年代，可以通过参数设置



> ### 根据对象年龄判断是否进入老年代

所谓的年龄，如果经历过一次 GC 对象仍然存活，那么年龄 +1，如果没有存活，那么直接享年 x 岁

某个对象第一次经历 GC 存活时，会将该对象从 伊甸区 移动到幸存区，且对象年龄为 1，往后只要经历过 指定次 GC 还活着，那么就将该对象移动到 老年代



> ### 幸存区中相同年龄对象超过幸存区空间一半的，直接进入老年代

上述讲的 对象年龄到达阈值 才进入老年代的，其实并不是一定的，因为幸存区可能很多个对象都存活，并且都存活了很多次，那么我们可以根据这个判断条件，将相同年龄的对象数超过幸存区空间一半的时候，将大于等于该年龄的对象提前放入老年代



> ### 空间分配担保（这个就不太容易理解了，后续有时间再来理解吧）





## 4、类的生命周期（类加载过程）

类加载（加载 class 文件到内存中，生成 Class 对象） - 验证（校验 class 文件中的字节流信息符合虚拟机的规范，防止恶意代码）- 准备（给静态变量赋 jvm 内部设定的初始值，执行静态代码块） -解析（类加载时的 符号引用转换为直接引用） -初始化（执行类的构造器，比如 new 之类的代码，执行构造代码块，给变量赋值）-卸载（回收对象）



**加载：**上面都说了，是加载 class 文件到内存当中，创建一个 Class 对象，这时候方法区里面的数据代码段和常量池之类的都准备好了

**验证：**上面说了

**准备：**静态变量赋 jvm 设置的初值，比如 int 设置为 0

**解析：**符号引用转换为直接引用

**初始化**：主动使用 时进行初始化，关于初始化什么，看下面

**卸载：**1、该类没有任何实例   2、该类的 Class 对象没有在任何地方引用，即无法同个反射获取 Class 对象



主动使用：常见的就是 new 了

> ### 初始化 是在干什么？

首先，如果是 new 这种的话，那么执行的顺序为：

- 先是父类，静态变量赋值，执行静态代码块
- 然后是子类，静态变量赋值，执行静态代码块
- 然后再是父类，非静态变量赋值，执行构造代码块，调用构造方法
- 然后再是子类，非静态变量赋值，执行构造代码块，调用构造方法

new 这种的话会使得 静态和非静态 都进行初始化

而如果是 调用静态变量 或者 静态方法，或者 在某个类上执行 静态的 main()，或者 Class.forName() 进行反射

那么上面的顺序不变， 只是 非静态变量  不会赋值，构造代码块和构造方法不会执行

**注意：**如果是在 子类使用 main()，那么父子都会静态初始化，如果是在 父类使用 main()，那么只有父类会静态初始化





## 5、符号引用 和 直接引用



> ### 符号引用

编译成 class 文件后，代码变成一条条的指令，而这些指令就是都是字符串的形式

这些字符串包含了足够多的信息， 如：“java/io/PrintStream.println:(Ljava/lang/String;)V”。

里面有类的信息，方法名，方法参数等信息。 就是一个开发者自己指定的模板



> ### 直接引用

第一次运行时，根据符号引用这个模板，拆分出信息，然后定位到 该方法/变量

比如上面的例子，定位到 java.io.PrintStream 类里的参数为 String 的 println() 方法

然后使用 直接引用 替代，后续就无需再次搜索



## 6、GC 回收算法



**共有 4 种回收算法，如：标记-清除、复制算法、标记-整理、分代收集算法**



> ### 标记-清除



**过程：**

如字面意思，分为 标记 和 清除 两个阶段，首先一趟遍历，**标记存活的对象（可达性分析判断）**，然后再一趟遍历，清除没有标记的对象



**优点：**

。。。



**缺点：**

一个是效率问题，需要两趟遍历，效率不高

第二个是会产生内存碎片，零零散散的内存空间，如果遇到需要分配连续大内存的对象，那么如果全都是内存碎片而拿不出连续的大内存的话，就又会触发一次效率不高的 GC



这个算法是所有算法中的基础算法，后续的所有算法都是根据这个算法来进行优化的



> ### 复制算法



**过程：**

它将原本可用的内存空间划分为大小相等的两大块，每次只使用其中一块来进行内存分配，当需要触发 GC 时，就将这一块的不需要回收的对象 复制到另一块中去，然后再将这块使用过的内存空间全部清理掉



**优点：**

对象复制的过程中只需要按照内存顺序进行复制，只需要移动指针即可，不会产生内存碎片，简单高效





**缺点：**

将可用的堆内存分为了两半，即可用的相当于原来的一半了，内存减少，那么就可能会更多的 GC，某些长时间存活的对象每次都需要进行复制，效率会降低

![img](http://mmbiz.qpic.cn/mmbiz_png/PgqYrEEtEnqLYgY6g5DgUKYUPgXXTjorcDwjZkYkrJ4fpgTibYjMEDGVK81YIQWDpW0k1S9ibjxLvRz3848v91qg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



> ### 标记-整理



**过程：**

为了不想 像 复制算法那样浪费一半的内存空间，并且经常进行复制操作，那么就出现了 标记-整理 算法

标记还是更 标记-清除一样，一趟进行标记，然后后续不是对回收对象进行处理，而是将存活对象一个个按照顺序进行移动，紧靠着



**优点：**

不会产生内存碎片，并且相比 复制算法，一些长时间存活的对象如果靠着边界的话，是不会需要移动的，后续无需管它



**缺点：**

整理相比 清除 会花费更多的时间，但其实从长远来看，这是必要的，短时间的低效率是为了以后的高效率



![img](http://mmbiz.qpic.cn/mmbiz_png/PgqYrEEtEnqLYgY6g5DgUKYUPgXXTjorH0wLYIx1oZ7fGo2uNUgB6dwGLYV3h7pJtMgficMpicMOhUENpStgSCog/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



> ### 分代收集算法

GC 分代的假设：绝大多数的对象的生命周期都很短

因此将 Java 堆分为 新生代 和 老年代

**对于新生代，由于每次 GC 都会存在大量的对象死去，因此使用复制算法，每次只需要复制少量存活的对象即可，效率**

**对于老年代，每次 GC 很少对象死去，因此使用 标记-清除 或 标记-整理算法**



## 7、JVM 中如何判断对象生死？（GC 回收对象的判断）



> ### 引用计数法

每个对象都有一个引用计数的属性，每当一个有一个指针变量引用它时，那么它的引用次数 +1，反之，引用次数 -1，当次数为 0 时，表示可以进行回收

优点：

- 实现简单，判定效率高，实时删除，没有延迟



缺点：

- 无法循环引用问题，当两个对象循环引用时，那么就无法回收，因为它们的引用计数都不为 1
- 每个对象都需要添加一个 计数器 字段来存储引用计数，增加了空间的开销
- 每次增加和删除引用，都需要更新 计数器，都需要伴随加减法，增加了时间的开销



> ### 可达性分析

从 GC roots 出发，如果某个对象无法到达，那么该对象没有被引用，那么可以回收



说到 GC roots，就跟 Java **四种引用有关系了**



> ### Java 四种引用



**Java 提出的这四种引用类型，实际上是为了方便 JVM 进行垃圾回收判断的**



强引用：

```java
A a = new A()
```

基本我们平时写的代码都是强引用，当 new A() 这个在堆中的对象只要有 a 这个强引用指向的时候，永远不会被回收，即使堆内存不足，JVM 宁愿抛出 OOM 也不会去回收

而当 a = null 时，表示 new A() 这个对象没有引用，那么就会被 JVM 回收



软引用：

```java
SoftReference<Student>studentSoftReference=new SoftReference<Student>(new Student());
Student student = studentSoftReference.get();
System.out.println(student);
```

软引用就是使用一个 SoftReference 包装对象，需要的时候使用 get() 获取这个对象

包装对象就是用来标识这个对象就是个软引用的，当 GC 后内存还是不足，那么就会回收掉软引用对象

即只有在内存不足的时候才会回收对象

**它适合当缓存，当内存足够的时候，我们可以使用它当作缓存，如果内存不足的时候，它自然就会被干掉了**



弱引用：

```java
WeakReference<byte[]> weakReference = new WeakReference<byte[]>(new byte[1024\*1024\*10]);
System.out.println(weakReference.get());
```

同样是使用一个外壳 WeakReference 来包装对象，使用 get() 来获取对象

跟软引用相比，无论内存是否足够，只要发生 GC，就会被干掉

**ThreadLocl 上就使用了弱引用，防止发生内存泄漏（具体看 ThreadLock 源码）**



虚引用：

```java
ReferenceQueue queue = new ReferenceQueue();
PhantomReference<byte[]> reference = new PhantomReference<byte[]>(new byte[1], queue);
System.out.println(reference.get());

public T get() {        
 return null;
}
```

它涉及两个类：虚引用外壳 PhantomReference， 引用队列 ReferenceQueue

它的 get() 方法跟上面的软引用和弱引用都不一样，直接返回 null 的，即虚引用目的不是用来当缓存之类的，因为无法获取传入的对象

虚引用需要配合 引用队列一起使用，它的主要作用是用来通知对象回收

当发生 GC 的时候，虚引用会被回收，并且回收前会将消息放入到 引用队列中，我们到时候就可以直接从引用队列获取被回收的对象

其实这个 引用队列就相当于是消息队列，通知哪些对象被回收了

**在NIO中，就运用了虚引用管理堆外内存.**



> ### GC roots

我们上面说了 GC 回收判断方法，其中的 可达性分析涉及到了 GC roots

而 GC roots 就又跟四种引用类型挂钩

因为 GC roots 是查找引用链，当某个对象没有被引用的时候，就会被对象回收，而引用就是上面的四种引用



GC roots 包括：

- JVM 栈（方法内部的局部变量引用的对象）中的引用的对象
- 方法区中的常量引用（final int a，这个 a 引用的对象）
- 方法区中的静态引用 (static int a，这个 a 引用的对象)
- 本地方法（native） 内部引用的对象

相当于就是说：局部变量、全局变量、常量、静态变量 和 native 方法内部的变量 引用的对象



> ### 死亡标记 和 拯救

在可达性算法中，**宣判对象的死亡存在两次标记过程**：

- 从 GC roots 出发，从每个 GC root 都能够引伸出多条引用链，比如 a 引用了 b ,b 引用了 c 之类的

而没有在引用链上面的对象，那么就会被进行第一次标记

- 当第一次标记后，会在标记过的对象上进行筛选，判断该对象是否有必要执行 finalize() 方法



执行 finalize() 方法有两个必要条件：

- 重写了 finalize() 方法
- 在之前没有调用过 finalize() 方法，一个对象一生中只能调用一次 finalize() 方法



**finalize() 方法是 Object() 中的一个方法，它是一个空方法，子类可以通过重写这个 finalize() 方法来实现自救**

**在这个方法中，对象可以重新让其他对象的引用指向自己，让自己有引用，而不会被回收**



当 GC roots 后将某个对象进行标记了，那么第二次标记的时候，JVM 会判断该对象是否重写了 finalize() 方法，

如果没有重写，那么第二次标记，然后回收；如果重写了，并且还没有调用过，那么进行调用；如果之前已经调用过了，自救方法次数用完了，那么第二次标记，然后回收



```java
public class FinalizeDemo {
    //引用
    public static FinalizeDemo Hook = null;

    //重写 finalize() 方法，实现自救
    @Override
    protected void finalize() throws Throwable {
        super.finalize();
        System.out.println("执行finalize方法");
        //将别的对象的引用指向自己，让自己有引用，而不会被回收
        FinalizeDemo.Hook = this;
    }

    public static void main(String[] args) throws InterruptedException {
        Hook = new FinalizeDemo();
        // 第一次拯救
        Hook = null;
        //执行 finalize() 方法
        System.gc();
        Thread.sleep(500); // 等待finalize执行
        if (Hook != null) {
            System.out.println("我还活着");
        } else {
            System.out.println("我已经死了");
        }
        // 第二次，代码完全一样
        Hook = null;
        //这里不会再执行 finalize() 方法，因为上面已经执行过一次了
        System.gc();
        Thread.sleep(500); // 等待finalize执行
        if (Hook != null) {
            System.out.println("我还活着");
        } else {
            System.out.println("我已经死了");
        }
    }
} 
```

执行的结果：

> 执行finalize方法
> 我还活着
> 我已经死了





## 8、GC 回收器

总共有 4 种垃圾回收器，按照级别排序就是：串行回收器，并行回收器，CMS 回收器，G1 回收器

**新生代频繁发生 GC，应选择高吞吐量的回收器，老年代对内存空间大小比较敏感，因此需要避免使用 复制 算法的垃圾回收器**



### 1、串行回收器

串行回收器是最开始提出的垃圾回收器，基本是在单 CPU 下运行的，**使用的是复制算法**

单线程进行垃圾回收，每次 GC 都会产生 "stop the word"（砸瓦鲁do）现象，即其他工作的用户线程都会停止，等待垃圾回收线程完成后才继续工作

这样用户体验及其不好，效率极低，如果垃圾回收 10s，那么用户线程就需要停止 10s，太 low 了



### 2、并行回收器

并行：多个线程同时工作，多个 CPU 的

并发：单个 CPU 切换多条线程



并行回收器主要是用在 多核 CPU 上，开启多个垃圾回收线程，并发回收，回收算法什么的跟串行基本一样

而且同样会产生 "stop the word"（砸瓦鲁do）现象，只是多条线程可以更快完成垃圾回收，停顿的时间更短



如果是在单 CPU 下使用的话，那么由于多线程需要 CPU 频繁进行切换，那么效率可能比 串行回收器 还低



### 3、CMS 回收器

 **CMS** （Concurrent Mark Sweep，并发标记清除）收集器要求回收的停顿时间短，使用的是标记-清除算法，主要是用于老年代（上面说了老年代使用 标记-清除 算法 或者 标记-整理 算法）



> ### CMS 三色标记

CMS 中定义了三种颜色：白色、灰色、黑色

白色：没有 GC roots 链引用的对象或者还没有扫描的对象

灰色：已经扫描过的对象，但是这个对象还存在引用没有扫描

黑色：已经扫描过的对象，并且它的所有引用都已经扫描了

在 GC 中，最终标记还是只会剩下 白色和黑色，灰色是白色和黑色 的过渡颜色

最后如果标记为白色的对象，会被回收

![img](https://user-gold-cdn.xitu.io/2020/2/23/170726139d42da78?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)







> ### 图解过程

1、初始标记：标记老年代中存活的对象，分为两步：标记 GC roots 直达对象，标记 新生代可达的老年代对象

**该阶段会发生 STW**

 ![img](https://upload-images.jianshu.io/upload_images/2184951-4eb4f86a4db07c72.png?imageMogr2/auto-orient/strip|imageView2/2/w/730/format/webp)   



2、并发标记：GC 线程和用户线程并发执行，遍历 初始标记 标记的存活对象，然后继续递归标记这些存活对象的可达对象

由于用户线程同时也在工作，因此对象的引用可能会被用户线程进行改变

比如 新生代晋升老年代，老年代引用发生改变等，这些会导致上一次标记的 存活对象发生改变

因此，通过 Card Marking，将老年代分为大小相同的多个 Card，JVM 将引用发生改变的对象 或者 新加入的对象 所在的 Card 标记为 Dirty ，后续扫描这些 Drity Card 即可，避免扫描整个老年代

  ![img](https://upload-images.jianshu.io/upload_images/2184951-c1622c7b27675950.png?imageMogr2/auto-orient/strip|imageView2/2/w/756/format/webp)   



3、并发预清理：GC 线程和用户线程并发执行，上面说了，由于并发标记的过程中，用户线程也在运行，所以可能某些引用关系发生改变，但是在 并发标记 阶段的时候，JVM 已经记录了引用发生改变的对象所在的 Card，因此该阶段直接扫描 Dirty Card，刷新引用关系，修改存活对象，然后清除 Dirty 标记

 ![并发预清理](https://user-gold-cdn.xitu.io/2019/9/25/16d68b1df1859305?imageView2/0/w/1280/h/960/format/webp/ignore-error/1) 



4、并发可取消的预清理：GC 线程和 用户线程并发执行，因为后续的 重新标记 阶段会 STW，因此该阶段尝试多做一些工作，以减少后续的 STW 时间，该阶段不断进行循环，标记老年代存活对象，扫描 Dirty Card 中的对象

循环结束条件：达到指定循环次数、达到指定循环时间、新生代内存使用率达到阈值



5、重新标记：最后的一次标记，停止用户线程，扫描 GC roots，新生代、Dirty Card 对象，以此来 重新 标记存活对象

该阶段 会 产生 STW



6、并发清除：GC 线程 和用户线程并发执行，清除掉老年代内 除 之前阶段标记的存活对象之外的所有对象



> ### 初始标记、并发标记、重新标记各自的意义

由于初始标记会 STW，所以就只标记 GC roots 直连的老年代对象，以及 新生代直连的老年代对象，这样不会 STW 太长时间，用户体验也好

然后并发标记就直接跟用户进程一起工作，递归深入标记老年代其他对象，因为这个递归需要的时间可能很长，因此这个过程需要避免 STW

然后 并发预清理 就是修改并发标记产生浮动垃圾，防止应该存活的对象被回收

最后重新标记也是最后一次标记，产生 STW，**由于 并发预处理也是跟用户线程一起工作的，所以可能也会产生一些引用修改，所以最终需要一个 STW 来完成最后的标记工作**，**主要是用来处理之前并发处理阶段残留的更新对象**





> ### CMS 的缺点

- 由于使用的是标记-清除，因此自然会产生内存碎片

- 存在浮动垃圾，比如在最后的并发清除阶段，清除的是之前标记的对象，此时用户进程也在运行，可能会产生新的垃圾，这些垃圾只能在下一次 GC 才能回收





### 4、G1 回收器

JDK1.7 新加入 的 G1 回收器，按长远来看，可能会取代 CMS 回收器



> ### 基于Region的堆内存布局

G1 将整个堆划分成了大小相等的多个区域 Region，分别为 E、S、O、H，即 伊甸区、幸存区、老年区、大对象区



一个 Region 可以存放很多的对象



回收时以 Region 作为一个基本单位（跟内存管理的分页机制类似），这样就避免了内存碎片



G1 会预测每个 Region 的回收时间，回收后得到的内存来判断回收该 Region 的价值，根据用户设置的期望时间来判断是否回收该 Region，以此达到每次都回收最大价值的 Region 的目的（有点类似死锁避免的银行家算法）

判断回收价值 大概就是看 Region  中存在多个存活对象，判断如果回收需要多少时间，回收后有多少可用内存，是否值得回收



**注意，划分的是虚拟内存，它们的连续的地址，就是使用虚拟地址跟实际的物理地址进行映射，来达到好像空间是连续的的感觉，这样也就可以无需使用真正连续的物理空间来存储大对象**

![img](https://picb.zhimg.com/80/v2-f18e615acfc6b36e69194bd5736fe27b_720w.jpg)



> ### Rset 解决 跨 Region 调用

由于堆内存分成了多个 Region，那么就存在 Region A 内的对象 调用 Region B 内的对象的情况

那么当我们回收 Region 的时候，怎么判断里面的对象是否存活呢？难道遍历所有的 Region，查找是否有其他对象引用这个对象么？

这样效率太低了，正常思维，我们就直接在 Region 记录哪个 Region 引用了自己的哪个对象

按照这种思想，引入了 Rset，在每个 Region 初始化的时候，都会分配一个 Rset，在这种设计思想下，Region 被更加细分，每个 Region 被 划分为了 512 个 卡页（Card Page），我们可以当作每个 卡页作为一个空间单位，当 Region B 中的某个卡页内的对象 引用了 Region A 中的某个卡页内的对象时，在 Region A 的 Rset 就会记录引用了它的 卡页地址

![img](https://pic4.zhimg.com/80/v2-5e2eea2d4c4ea3faa85bc51298bed169_720w.jpg)

这样的话，后续判断 Region 内的某个对象是否存活的话，直接搜索 Rset 查看是否有引用指向它即可，如果有，再判断指向它的对象是否存活即可，无需扫描整个 Region



> ### G1 回收过程

1、初始标记（STW）：跟 CMS 一样，不同的是 G1 只标记 GC roots 直连对象

2、并发标记：跟用户线程并发执行，递归标记 GC roots 直连对象的可达对象，并且该阶段会使用 快照

3、重新标记 (STW)：把并发线程时删除的引用通过快照进行处理

4、筛选回收（STW）统计每个 Region 的回收价值，根据用户指定的期望值来指定回收计划（类似银行家算法），后续根据回收计算，选择任意多个 Region 进行回收，先将有存活对象的 Region  中的存活对象复制到空的 Region 中，然后再清理掉整个旧的 Region，多个旧 Region 空间的对象可以拷贝到同一个 Region 中



> ### G1 的优缺点

优点：

根据用户期望值进行 Region 回收，一次回收不需要针对全部内存，只需要先回收垃圾最多的 Region ，可以有效控制 STW 的时间

Region 的堆内存划分使得 G1 不容易产生内存碎片，能够方便存储大对象



缺点：

每个 Region  维护一个 Rset，当引用很多的时候，记录的就变得更多，这样 Rset 占的内存空间就越多，甚至可能会占用整个堆的 20%，因此 G1 更适合在大内存的服务器上





### 5、并发标记的问题

- 产生浮动垃圾
- “对象消失”问题



> ### 浮动垃圾的产生

GC 使用的是 三色标记

黑色表示对象存活，并且它的所有引用都扫描过了

灰色表示对象存活，但是它的引用有的还没有扫描过

白色表示对象未扫描或者需要回收



如下面的动图，当我们处理完 6，将 7 设置为 灰色，但是这时候 用户将 6 的指针不再指向 7，而 7 由于已经被染成灰色，所以 GC 认为它还存活，所以继续将后面的引用染成黑色，这样的话，7 8 4 10 11 都不会被本次 GC 回收，这就产生了浮动垃圾

![img](https://user-gold-cdn.xitu.io/2020/3/1/17093d3d3ee999f4?imageslim)

> ### 什么是对象消失？

正常情况下是这样的

![img](https://user-gold-cdn.xitu.io/2020/2/23/1707265e1a8f8b43?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



但是，并发标记的过程中，用户可能会修改引用，使得尚未扫描到的存活对象扫描不到了，导致它被垃圾回收

比如下图：当  5 扫描完成后，接着是扫描 6 的，而本来 6 是指向 9 的，但是由于用户线程的修改了引用，导致 6 和 9 间的引用断开了，而 5 指向了 9，因为 5 已经标记为黑色，而 6 不存在与 9 的引用，这意味着 9 不会被标记，而最终只能是白色，而被回收掉，但实际上它是存活的对象

![img](https://user-gold-cdn.xitu.io/2020/2/23/1707266cd4d9d2fb?imageslim)







> ### 解决 对象消失 的方法

1、增量更新

**CMS 使用的就是增量更新，它规定，黑色对象一旦插入 白色对象后，它就会重新变成灰色**

这样的话，就会从这个灰色节点再次扫描一遍，就能够扫描到新插入的白色节点

比如上面就是由于 5 是黑色的，所以不会再去扫描 9，而 白色对象 9 插入后，它重新变成灰色，就会再次扫描

![img](https://user-gold-cdn.xitu.io/2020/2/23/170726cb3673541b?imageslim)



2、快照

**G1 使用的就是快照**

简单的说就是在 GC 的时候，该对象是存活的那么它就是存活的，因此需要提前给对象的引用关系做一次快照，当并发标记的过程中，有用户线程删除了引用的时候，导致某个对象没有被标记上，那么在并发标记结束后的重新标记阶段，会通过这个快照按照原来的引用关系再扫描发生改变的对象（注意：快照只恢复并发标记过程中用户线程删除的引用）

**恢复引用会导致浮动垃圾的存活，比如用户线程修改了引用，这个对象已经没有引用了，是需要回收的，但是按照快照又给它恢复成有引用的样子，导致它在此次 GC 中不会被回收**



![img](https://user-gold-cdn.xitu.io/2020/2/23/170726d12a19361a?imageslim)
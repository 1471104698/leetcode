# TCP 的可靠性实现



## TCP 可靠性 靠什么实现？

这里的可靠性不是说三次握手、四次挥手，而是连接完成后，中间的数据传输

TCP 的可靠性是通过 序列号、确认应答、重传机制、滑动窗口、流量控制、拥塞控制 实现的



## 重传机制

**1、超时重传**



## 滑动窗口

#### 1、使用窗口前的数据发送方式

TCP 是每发送一次数据，都要进行一次应答确认，即得到 上一个数据包的 应答，才发送下一个数据包

这也是 TCP 的可靠性之一

如果每次数据发送的大小都是一个 TCP 段的话，那么就有点像你我两个人聊天，你一句我一句的，你说我回，我回了你才能继续说

如果你说了一句话，而我在干别的事，那么你需要等待我干完，你还必须重新说那句话，这样效率低下

*![image.png](https://pic.leetcode-cn.com/1597982380-WwqbeW-image.png)*



#### 2、滑窗窗口

**为了解决这个问题，TCP 引入了 滑动窗口**

当使用窗口的时候，无需等待收到确认应答，只要在窗口大小内还有可发送数据，那么可以直接发送

窗口的实现实际上是操作系统内部的一个缓存空间，当你发送出数据后，直到收到确认应答，才可以删除对应的数据缓存，否则，那么需要根据缓存的数据进行重发

比如下面的，发送了 【100， 700】，如果 服务端处理完 【500，599】 后发送的 ACK 丢失了，即客户端没有收到确认应答，但是，后面收到了 700 的 ACK，那么表示 700 前面的数据都处理完毕了，无需等待 600 的 ACK

但是，如果这里只发送了 【100，599】，却没有收到 600 的 ACK，但是收到了 500 的 ACK，那么就需要从缓存中获取 【500，599】 的数据重新发送

**这种叫做累计确认**



*![image.png](https://pic.leetcode-cn.com/1597993414-gESvQl-image.png)*



#### 3、窗口大小由哪一方决定？

TCP 中有 窗口大小  这个字段，是接收方告诉发送方自己现在还能接收多少数据，

那么发送端就可以根据服务端的接收能力来发送对应大小的数据，而不会一股脑的发送数据，超出服务端的处理能力

因此窗口大小由接收端决定



#### 4、发送方的滑动窗口

发送方的窗口分为四个部分：

- 已发送并且已经收到 ACK（处理完毕， #1： 1 - 31 字节）

- 已发送但未收到 ACK（服务端尚未处理完毕，或者 ACK 还在路上，#2：32 - 45 字节）

- 未发送但是可以发送（服务端还能接收数据，这些数据现在可以发送给服务端，但是现在还没有发送，

  #3 ：46 - 51 字节）

- 未发现并且现在不能发送（后面的这些数据不能发送，因为超出了服务端的接收能力，#4 ：52 - 56 字节）



*![image.png](https://pic.leetcode-cn.com/1597993856-goRUji-image.png)*



如果 32 - 36 字节收到 ACK 后，那么缓存空间中会删除掉这些数据，并且窗口会往右边移动，到达 56

*![image.png](https://pic.leetcode-cn.com/1597994071-LvuLnd-image.png)*



滑动窗口 4 个部分的表示是使用 3 个指针来区分的，即相当于我们使用 write 和 read 指针来压缩字符串一样

SND.WND：窗口大小变量

SND.UNA：第一个指针，位于窗口的第一个字节，表示窗口的起始位置

SND.NXT：已发送数据的末尾位置，同时也是可发送数据的起始位置，SND.NXT - SND.UNA 即为 #2 的大小

*![image.png](https://pic.leetcode-cn.com/1597994129-NGveQS-image.png)*



#### 5、接收方的滑动窗口

没啥好说的，比较简单

*![image.png](https://pic.leetcode-cn.com/1597994365-FJXXeT-image.png)*
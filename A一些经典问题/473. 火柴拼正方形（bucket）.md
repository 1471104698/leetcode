# [473. 火柴拼正方形（bucket）](https://leetcode-cn.com/problems/matchsticks-to-square/)

![1596352889903](C:\Users\蒜头王八\AppData\Roaming\Typora\typora-user-images\1596352889903.png)

## 题意描述

有一个火柴数组` nums`，判断是否能够通过这些火柴组成一个正方形

即给定一个数组 `nums`, 判断是否将 所有元素 能够分割为 4 个 元素和相等的子数组

**注意:**

1. 给定的火柴长度和在 `0` 到 `10^9`之间。
2. 火柴数组的长度不超过15。



## **示例 1:**

```java
输入: [1,1,2,2,2]
输出: true

解释: 能拼成一个边长为2的正方形，每边两根火柴。
```



## **示例 2:**

```java
输入: [3,3,3,3,4]
输出: false

解释: 不能用所有火柴拼成一个正方形。
```



## 方法①、回溯 `dfs` + 逐一装进 bucket

### 实现思路

我们提前判断总和 sum 是否能够分为 4 份

```java
if(sum % 4 != 0){
    return false;
}
```

然后分割创建一个 大小为 4 的 bucket，每个 bucket 的容量为 `sum / 4`

然后我们将` nums` 中的火柴通过` dfs `逐一装进 bucket 中

比如 `nums[i]`， 如果 `bucket[j]` 的容量足够装进这根火柴，那么就尝试装进去，然后继续 `dfs`

如果返回结果为 false，那么就从 `bucket[j] `中删除这根火柴，即回溯



#### 装火柴的顺序：

倒序装入，先将较大的火柴放入

因为如果我们先将小的放入的话，那么比如 火柴总数为：`1 1 1 1 2 2 2 2 3 3 3 3 。 。 。  9999 9999 9999 9999`

火柴组成的正方形边长会很长，那么我们 `dfs` 的时候，第一个 bucket 会由于容量足够而一直放入 `[1,1,1,1,2,2,2,...]`

然后最后发现不行，再回溯，这样由于容量的问题浪费了大量无用的时间

如果我们先将大的火柴放入，那么第一个 bucket 放入 9999，那么剩下的空间就很小，不会多做无意义的回溯

### 实现代码

```java
class Solution {
    public boolean makesquare(int[] nums) {
        int sum = 0;
        for(int num : nums){
            sum += num;
        }
        if(sum <= 0 || sum % 4 != 0){
            return false;
        }
        Arrays.sort(nums);
        int[] bucket = new int[4];
        Arrays.fill(bucket, sum / 4);

        return dfs(nums, bucket, nums.length - 1);
    }
    private boolean dfs(int[] nums, int[] bucket, int i){
        int len = nums.length;
        if(i == -1){
            return true;
        }
        for(int j = 0; j < 4; j++){
            if(bucket[j] < nums[i]){
                continue;
            }
            bucket[j] -= nums[i];
            if(dfs(nums, bucket, i - 1)){
                return true;
            }
            bucket[j] += nums[i];
        }
        return false;
    }
}
```


# 多线程处理



> 先来看看虚构的小故事

已经晚上 11 点了，程序员小明的双手还在键盘上飞舞着，眼神依然注视着的电脑屏幕。

没办法这段时间公司业绩增长中，需求自然也多了起来，加班自然也少不了。

天气变化莫测，这时窗外下起了蓬勃大雨，同时闪电轰鸣。

但这一丝都没有影响到小明，始料未及，突然一道巨大的雷一闪而过，办公楼就这么停电了，随后整栋楼都在回荡着的小明那一声撕心裂肺的「卧槽」。

此时，求小明的心里面积有多大？

等小明心里平复后，突然肚子非常的痛，想上厕所，小明心想肯定是晚上吃的某堡王有问题。

整栋楼都停了电，小明两眼一抹黑，啥都看不见，只能靠摸墙的方法，一步一步的来到了厕所门口。

到了厕所（**共享资源**），由于实在太急，小明直接冲入了厕所里，用手摸索着刚好第一个门没锁门，便夺门而入。

这就荒唐了，这个门里面正好小红在上着厕所，正好这个厕所门是坏了的，没办法锁门。

黑暗中，小红虽然看不见，但靠着声音，发现自己面前的这扇门有动静，觉得不对劲，于是铆足了力气，用她穿着高跟鞋脚，用力地一脚踢了过去。

小明很幸运，被踢中了「命根子」，撕心裂肺地喊出了一个字「痛」！

故事说完了，扯了那么多，实际上是为了说明，**对于共享资源，如果没有上锁，在多线程的环境里，那么就可能会发生翻车现场。**



## 多线程竞争问题

一般我们讲的多线程是单核 CPU 下的情况，虽然现在计算机都是多核 CPU，但是那个不做讨论

在单 CPU 下，一个进程中的多线程肯定是并发执行的，而不是并行执行，那么就会发生线程切换

![img](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcJWrfgAR82HEMZFficYr34yUqcPlbC7BA8K7uvbjMzlZDYPwYMZEbDxqjqZvU4YmdlxmKJmz6kvsg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

进程是资源分配的基本单位，线程是CPU 调度的基本单位

多个线程共享进程的资源，那么问题就来了，如果多个线程竞争同一个共享资源，在什么都不处理的情况下就会造成资源混乱

比如设置一个全局变量 i = 0，两个线程分别对它 进行 1W 次 +1，那么最终结果应该是 2W，但是实际上结果 < 2W



> 为什么会发生这种情况？

这跟底层的实现有关，之前也已经说了，代码通过编译变成的是一条条的指令，执行代码（进程）实际上内部 是在执行一条条的指令，那么这个 i + 1 也一样

它不是表面上看的那么简单，直接就 +1，它底层是分成了 3 条指令

![img](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcJWrfgAR82HEMZFficYr34ycbfdlYTI8NxrEIboJP2rbWVEImGkWhjiafS9rbKu1wTQsFNjL7Ld16w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

既然操作有时间先后顺序，不是同时发生的，那么在中间过程就可能发生 线程的切换，即线程 A 在执行 i++ 操作的时候，才对 寄存器中的 i 值 +1，还没有写回内存，CPU 就切换到线程 B 执行 i++，这时 B 拿到的是旧的 i  = 50，+1 后再将 i = 51 写回内存，然后 CPU 才切换到线程 A，将 i = 51 写回内存，这时就导致错误了

![img](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcJWrfgAR82HEMZFficYr34y4CUp2YtpUAbQrXfc9rbzhmYColm2QHFic6ibuCcSOAicnu9P6qzvcr5ew/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

导致错误的原因有两个：

- 代码的底层的指令不是原子性的，它不像我们写的代码比如 i ++ 只有一行，而是分成了 3 条指令，它们有执行的先后顺序，并且过程中还可能发生线程切换
- 共享资源被一个线程访问的时候还可以被其他的线程所访问

上面两个原因我们解决一个即可，但是原因一就不太可能解决了，因为需要去设置执行过程中不能进行线程切换 或者 精简指令，我不太了解，大概是不可能的了

因此就只能解决原因二，即对共享资源上锁，同一个共享资源一次只能由一个线程访问，就跟上面的故事中的厕所一样，一次只能有一个人上，避免翻车



## 互斥和同步



> 互斥的概念

上面的这种情况是多线程操作共享资源的时候，发生了线程切换，得到了错误的结果

由于多线程执行操作共享变量的这段代码可能会导致竞争状态，因此我们将此段代码称为**临界区（critical section），它是访问共享资源的代码片段，一定不能给多线程同时执行。**

对于临界代码我们就希望这种一次只能有一个线程去操作，当有一个线程操作的时候，其他线程就不能操作，这就是**互斥**

（多进程竞争共享资源的时候也是如此）

![img](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcJWrfgAR82HEMZFficYr34yN1iadgAqAS7xRP2Do4SnFFGIqCKQ5gsGUANdJib1CPjjJ1Ql6XPJd6Mw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



> 同步的概念

在多线程里，如果不加处理，那么线程的处理速度是未知的，因为 随时都可能发生线程的上下文切换

但有时候我们又想要多个线程中每个线程按照特定的顺序执行

比如：线程 1 是负责读入数据的，而线程 2 是负责处理数据的，我们希望 线程 2 在没有收到 线程 1 的唤醒通知时，就会一直阻塞等待，当 线程 1 读完数据需要把数据传给 线程 2 时，线程 1 会唤醒 线程 2，并把数据交给 线程 2 处理。

**所谓同步，就是并发进程/线程在一些关键点上可能需要互相等待与互通消息，这种相互制约的等待与互通信息称为进程/线程同步**。

就比如下面要讲的生产者-消费者，当生产者还没生产出东西时，那么即使发生线程切换，CPU 调度消费者线程，那么它也不能执行，需要继续阻塞，并且释放锁（CPU 的控制权）



注意，同步与互斥是两种不同的概念：

- 同步就好比：「操作 A 应在操作 B 之前执行」，「操作 C 必须在操作 A 和操作 B 都完成之后才能执行」等；
- 互斥就好比：「操作 A 和操作 B 不能在同一时刻执行」；

## 互斥与同步的实现和使用



为了实现进程/线程间正确的协作，操作系统必须提供实现进程协作的措施和方法，主要的方法有两种：

- *锁*：加锁、解锁操作；
- *信号量*：P、V 操作；

这两个都可以方便地实现进程/线程互斥，而信号量比锁的功能更强一些，它还可以方便地实现进程/线程同步。
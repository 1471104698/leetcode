给你一个整数数组 nums 和一个整数 k。

如果某个 连续 子数组中恰好有 k 个奇数数字，我们就认为这个子数组是「优美子数组」。

请返回这个数组中「优美子数组」的数目。

 

示例 1：

输入：nums = [1,1,2,1,1], k = 3
输出：2
解释：包含 3 个奇数的子数组是 [1,1,2,1] 和 [1,2,1,1] 。
示例 2：

输入：nums = [2,4,6], k = 1
输出：0
解释：数列中不包含任何奇数，所以不存在优美子数组。
示例 3：

输入：nums = [2,2,2,1,2,2,1,2,2,2], k = 2
输出：16
 

提示：

1 <= nums.length <= 50000
1 <= nums[i] <= 10^5
1 <= k <= nums.length

class Solution {
    public int numberOfSubarrays(int[] nums, int k) {
        /*

        我们可以发现，当 k = 2 时
        2,2,2,1,2,2,1,2,2,2
        0 0 0 1 0 0 2 0 0 0 （1、2 表示第几个出现的奇数）
        1 2 3 4     1 2 3 4
        满足条件的子数组个数为 4 * 4 = 16
		即满足条件的子数组为 {2,2,2,1,2,2,1} {2,2,1,2,2,1}} {2,1,2,2,1}} {1,2,2,1}} {1,2,2,1,2,2,2} {1,2,2,1,2,2} {1,2,2,1,2} ... 之类的 16 个

        因此，当 k = 2 时，我们只需要计算 0 到 1 之间偶数的个数 和 2 到 3 之间偶数的个数即可
        （讲不太清楚，反正就是这么回事）
        同样的，初始化 dp[0] = -1, 这样第 0 各奇数 和 第 1 个奇数之间长度为 dp[1] - dp[0] = dp[1] - (-1) = dp[1] + 1

        使用 dp 记录奇数出现的索引位置
        使用 idx 记录出现了第几个奇数，从 1 算起
        （注意：下面 idx 初始化为 0，但是实际上填充的时候是 ++idx，思考下，如果 idx 初始化为 1，然后 idx++,最终循环结束会有什么不同？）

        
        */
        int len = nums.length;
        int[] dp = new int[len + 1];
        dp[0] = -1;
        int idx = 0;
        int c = 0;
        for(int i = 0; i < len; i++){
            if((nums[i] & 1) != 0){
                dp[++idx] = i;
                if(idx > k){
                    c += (dp[idx - k] - dp[idx - k - 1]) * (dp[idx] - dp[idx - 1]);
                }
            }
        }
        if(idx < k){
            return 0;
        }
		/*
		2,2,2,1,2,2,1,2,2,2 1
        0 0 0 1 0 0 2 0 0 0 3
		
		2,2,2,1,2,2,1,2,2,2 1 2
        0 0 0 1 0 0 2 0 0 0 3 0
		
		注意：比如 k = 2，而 idx = 3，即存在 3 个奇数，但上面我们计算的只是 1 、 2 奇数位置的子数组的个数
		2 、 3 位置奇数 的子数组的个数我们还没有计算，因此，这里需要再计算下
		*/
        c += (dp[idx - k + 1] - dp[idx - k]) * (len - dp[idx]);
        return c;
    }
}
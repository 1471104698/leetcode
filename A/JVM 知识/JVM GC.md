# JVM GC

## 1、GC 回收算法



**共有 4 种回收算法，如：标记-清除、复制算法、标记-整理、分代收集算法**



### 1、标记-清除



**过程：**

如字面意思，分为 标记 和 清除 两个阶段，首先一趟遍历，**标记存活的对象（可达性分析判断）**，然后再一趟遍历，清除没有标记的对象



**优点：**

。。。



**缺点：**

一个是效率问题，需要两趟遍历，效率不高

第二个是会产生内存碎片，零零散散的内存空间，如果遇到需要分配连续大内存的对象，那么如果全都是内存碎片而拿不出连续的大内存的话，就又会触发一次效率不高的 GC



这个算法是所有算法中的基础算法，后续的所有算法都是根据这个算法来进行优化的



### 2、复制算法



**过程：**

它将原本可用的内存空间划分为大小相等的两大块，每次只使用其中一块来进行内存分配，当需要触发 GC 时，就将这一块的不需要回收的对象 复制到另一块中去，然后再将这块使用过的内存空间全部清理掉



**优点：**

- 不需要标记的过程，直接遇到存活的对象就进行复制，即一遍扫描即可完成

- 对象复制的过程中只需要按照内存顺序进行复制，只需要移动指针即可，不会产生内存碎片，简单高效





**缺点：**

将可用的堆内存分为了两半，即可用的相当于原来的一半了，内存减少，那么就可能会更多的 GC，某些长时间存活的对象每次都需要进行复制，效率会降低

![img](http://mmbiz.qpic.cn/mmbiz_png/PgqYrEEtEnqLYgY6g5DgUKYUPgXXTjorcDwjZkYkrJ4fpgTibYjMEDGVK81YIQWDpW0k1S9ibjxLvRz3848v91qg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



### 3、标记-整理



**过程：**

为了不想 像 复制算法那样浪费一半的内存空间，并且经常进行复制操作，那么就出现了 标记-整理 算法

标记还是更 标记-清除一样，一趟进行标记，然后后续不是对回收对象进行处理，而是将存活对象一个个按照顺序进行移动，紧靠着



**优点：**

不会产生内存碎片，并且相比 复制算法，一些长时间存活的对象如果靠着边界的话，是不会需要移动的，后续无需管它



**缺点：**

整理相比 清除 会花费更多的时间，但其实从长远来看，这是必要的，短时间的低效率是为了以后的高效率



![img](http://mmbiz.qpic.cn/mmbiz_png/PgqYrEEtEnqLYgY6g5DgUKYUPgXXTjorH0wLYIx1oZ7fGo2uNUgB6dwGLYV3h7pJtMgficMpicMOhUENpStgSCog/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



### 4、分代收集算法

GC 分代的假设：绝大多数的对象的生命周期都很短

因此将 Java 堆分为 新生代 和 老年代

**对于新生代，由于每次 GC 都会存在大量的对象死去，因此使用复制算法，每次只需要复制少量存活的对象即可，效率**

**对于老年代，每次 GC 很少对象死去，因此使用 标记-清除 或 标记-整理算法**



## 2、JVM 中如何判断对象生死？（GC 回收对象的判断）



### 1、判断方法

> ### 引用计数法

每个对象都有一个引用计数的属性，每当一个有一个指针变量引用它时，那么它的引用次数 +1，反之，引用次数 -1，当次数为 0 时，表示可以进行回收

优点：

- 实现简单，判定效率高，实时删除，没有延迟



缺点：

- 无法循环引用问题，当两个对象循环引用时，那么就无法回收，因为它们的引用计数都不为 1
- 每个对象都需要添加一个 计数器 字段来存储引用计数，增加了空间的开销
- 每次增加和删除引用，都需要更新 计数器，都需要伴随加减法，增加了时间的开销



> ### 可达性分析

从 GC roots 出发，如果某个对象无法到达，那么该对象没有被引用，那么可以回收

说到 GC roots，就跟 Java **四种引用有关系了**





### 2、Java 四种引用



**Java 提出的这四种引用类型，实际上是为了方便 JVM 进行垃圾回收判断的**

> ### 强引用

```java
A a = new A()
```

基本我们平时写的代码都是强引用，当 new A() 这个在堆中的对象只要有 a 这个强引用指向的时候，永远不会被回收，即使堆内存不足，JVM 宁愿抛出 OOM 也不会去回收

而当 a = null 时，表示 new A() 这个对象没有引用，那么就会被 JVM 回收



> ### 软引用

```java
SoftReference<Student>studentSoftReference=new SoftReference<Student>(new Student());
Student student = studentSoftReference.get();
System.out.println(student);
```

软引用就是使用一个 SoftReference 包装对象，需要的时候使用 get() 获取这个对象

包装对象就是用来标识这个对象就是个软引用的，当 GC 后内存还是不足，那么就会回收掉软引用对象

即只有在内存不足的时候才会回收对象

**它适合当缓存，当内存足够的时候，我们可以使用它当作缓存，如果内存不足的时候，它自然就会被干掉了**



> ### 弱引用

```java
WeakReference<byte[]> weakReference = new WeakReference<byte[]>(new byte[1024\*1024\*10]);
System.out.println(weakReference.get());
```

同样是使用一个外壳 WeakReference 来包装对象，使用 get() 来获取对象

跟软引用相比，无论内存是否足够，只要发生 GC，就会被干掉

**ThreadLocl 上就使用了弱引用，防止发生内存泄漏（具体看 ThreadLock 源码）**



> ### 虚引用

```java
ReferenceQueue queue = new ReferenceQueue();
PhantomReference<byte[]> reference = new PhantomReference<byte[]>(new byte[1], queue);
System.out.println(reference.get());

public T get() {        
 return null;
}
```

它涉及两个类：虚引用外壳 PhantomReference， 引用队列 ReferenceQueue

它的 get() 方法跟上面的软引用和弱引用都不一样，直接返回 null 的，即虚引用目的不是用来当缓存之类的，因为无法获取传入的对象

虚引用需要配合 引用队列一起使用，它的主要作用是用来通知对象回收

当发生 GC 的时候，虚引用会被回收，并且回收前会将消息放入到 引用队列中，我们到时候就可以直接从引用队列获取被回收的对象

这个 引用队列 就相当于是消息队列，通知哪些对象被回收了



### 3、GC roots



GC roots 是查找引用链，当某个对象没有被引用的时候，就会被对象回收

GC roots 引用的对象包括：

- JVM 栈（方法内部的局部变量引用的对象）中的引用的对象
- 方法区中的常量引用（final User user，这个 user 引用的对象）
- 方法区中的静态引用 (static User user，这个 user 引用的对象)
- 本地方法（native） 中引用的对象

相当于就是说：局部变量、全局变量、常量、静态变量 和 native 方法内部的变量 引用的对象，这些都是被堆外引用的对象，而不是堆内互相引用的对象



首先，我们要知道，这个 GC roots 一般情况下指代的是堆外，比如栈中的引用变量，而不是对象

而 GC root 引用了堆内的某个对象，这个对象就是可达的，回收算法的 初始标记阶段就是标记 GC roots 直接引用的这些对象

一般而言，在没有在 GC roots 链上的 堆内对象的互相引用，也算是回收对象了，因为它没有外部引用，即不能再被使用了



### 4、死亡标记 和 拯救 finalize()

在可达性算法中，**宣判对象的死亡存在两次标记过程**：

- 从 GC roots 出发，从每个 GC root 都能够引伸出多条引用链，比如 a 引用了 b ,b 引用了 c 之类的

而没有在引用链上面的对象，那么就会被进行第一次标记

- 当第一次标记后，会在标记过的对象上进行筛选，判断该对象是否有必要执行 finalize() 方法



执行 finalize() 方法有两个必要条件：

- 重写了 finalize() 方法
- 在之前没有调用过 finalize() 方法，一个对象一生中只能调用一次 finalize() 方法



**finalize() 方法是 Object() 中的一个方法，它是一个空方法，子类可以通过重写这个 finalize() 方法来实现自救**

**在这个方法中，对象可以重新让其他对象的引用指向自己，让自己有引用，而不会被回收**



当 GC roots 后将某个对象进行标记了，那么第二次标记的时候，JVM 会判断该对象是否重写了 finalize() 方法，

如果没有重写，那么第二次标记，然后回收；如果重写了，并且还没有调用过，那么进行调用；如果之前已经调用过了，自救方法次数用完了，那么第二次标记，然后回收



```java
public class FinalizeDemo {
    //引用
    public static FinalizeDemo Hook = null;

    //重写 finalize() 方法，实现自救
    @Override
    protected void finalize() throws Throwable {
        super.finalize();
        System.out.println("执行finalize方法");
        //将别的对象的引用指向自己，让自己有引用，而不会被回收
        FinalizeDemo.Hook = this;
    }

    public static void main(String[] args) throws InterruptedException {
        Hook = new FinalizeDemo();
        // 第一次拯救
        Hook = null;
        //执行 finalize() 方法
        System.gc();
        Thread.sleep(500); // 等待finalize执行
        if (Hook != null) {
            System.out.println("我还活着");
        } else {
            System.out.println("我已经死了");
        }
        // 第二次，代码完全一样
        Hook = null;
        //这里不会再执行 finalize() 方法，因为上面已经执行过一次了
        System.gc();
        Thread.sleep(500); // 等待finalize执行
        if (Hook != null) {
            System.out.println("我还活着");
        } else {
            System.out.println("我已经死了");
        }
    }
} 
```

执行的结果：

> 执行finalize方法
> 我还活着
> 我已经死了





## 3、GC 回收器

总共有 4 种垃圾回收器，按照级别排序就是：串行回收器，并行回收器，CMS 回收器，G1 回收器

**新生代频繁发生 GC，应选择高吞吐量的回收器，老年代对内存空间大小比较敏感，因此需要避免使用 复制 算法的垃圾回收器**



### 1、串行回收器

串行回收器是最开始提出的垃圾回收器，基本是在单 CPU 下运行的，**使用的是复制算法**

单线程进行垃圾回收，每次 GC 都会产生 "stop the word"（砸瓦鲁do）现象，即其他工作的用户线程都会停止，等待垃圾回收线程完成后才继续工作

这样用户体验及其不好，效率极低，如果垃圾回收 10s，那么用户线程就需要停止 10s，太 low 了



**新生代：复制算法**

**老年代“：标记- 整理**



### 2、并行回收器

并行：多个线程同时工作，多个 CPU 的

并发：单个 CPU 切换多条线程



并行回收器主要是用在 多核 CPU 上，开启多个垃圾回收线程，并发回收，回收算法什么的跟串行基本一样

而且同样会产生 "stop the word"（砸瓦鲁do）现象，只是多条线程可以更快完成垃圾回收，停顿的时间更短



如果是在单 CPU 下使用的话，那么由于多线程需要 CPU 频繁进行切换，那么效率可能比 串行回收器 还低



**新生代：复制算法**

**老年代：标记-整理**



### 3、CMS 回收器



 **CMS** （Concurrent Mark Sweep，并发标记清除）

> ### CMS 出现的原因

在 CMS 出现之前，有串行 和 并行两种垃圾回收器，它们无论是新生代还是老年代的 STW 都导致用户线程停留太长时间，效率过低



**CMS 只收集老年代，不过并发标记的时候会遍历新生代**



CMS 的提出主要是给 老年代服务的,老年代使用的都是标记-清除 / 或者标记-整理 算法，CMS 默认情况下使用 标记-清除算法

主要是为了减少 上面两个回收器的 STW 时间，提高用户线程的效率



**新生代：仍然使用的是并行回收器，复制算法**

**老年代：标记-清除**



> ### CMS 三色标记

CMS 中定义了三种颜色：白色、灰色、黑色

白色：没有 GC roots 链引用的对象或者还没有扫描的对象

灰色：已经扫描过的对象，但是这个对象还存在引用没有扫描

黑色：已经扫描过的对象，并且它的所有引用都已经扫描了

在 GC 中，最终标记还是只会剩下 白色和黑色，灰色是白色和黑色 的过渡颜色

最后如果标记为白色的对象，会被回收

![img](https://user-gold-cdn.xitu.io/2020/2/23/170726139d42da78?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)







> ### 图解过程

1、初始标记：标记老年代中存活的对象，分为两步：标记 GC roots 直达的老年代对象，标记 新生代可达的老年代对象

**该阶段会发生 STW**

 ![img](https://upload-images.jianshu.io/upload_images/2184951-4eb4f86a4db07c72.png?imageMogr2/auto-orient/strip|imageView2/2/w/730/format/webp)   



2、并发标记：GC 线程和用户线程并发执行，遍历 初始标记 标记的存活对象，然后继续递归标记这些存活对象的可达对象

(**由于用户线程同时也在工作，因此对象的引用可能会被用户线程进行改变**)

这时候会使用 car table 记录新发生的老年代对新生代对象的引用

  ![img](https://upload-images.jianshu.io/upload_images/2184951-c1622c7b27675950.png?imageMogr2/auto-orient/strip|imageView2/2/w/756/format/webp)   



3、并发预清理：GC 线程和用户线程并发执行，扫描 card table，刷新老年代对新生代对象的引用关系

由于 下面的 重新标记 会扫描新生代对象，因此这里可能也会发生一次 young GC，减少新生代对象，以此来减少 STW 的时间

 ![并发预清理](https://user-gold-cdn.xitu.io/2019/9/25/16d68b1df1859305?imageView2/0/w/1280/h/960/format/webp/ignore-error/1) 



4、重新标记：最后的一次标记，停止用户线程，扫描 GC roots，以此来 重新 标记存活对象

**该阶段 会 产生 STW，比 初始标记长，比并发标记短**



5、并发清除：GC 线程 和用户线程并发执行，清除老年代回收对象



> ### 初始标记、并发标记、重新标记各自的意义

由于初始标记会 STW，所以就只标记 GC roots 直连的老年代对象，以及 新生代直连的老年代对象，这样不会 STW 太长时间，用户体验也好

然后并发标记就直接跟用户进程一起工作，递归深入标记老年代其他对象，因为这个递归需要的时间可能很长，因此这个过程需要避免 STW

然后 并发预清理 修改 card table 记录的引用，进行一次 young GC，节省 重新标记 STW 扫描新生代对象的时间

最后重新标记也是最后一次标记，产生 STW，**由于 并发预处理也是跟用户线程一起工作的，所以可能也会产生一些引用修改，所以最终需要一个 STW 来完成最后的标记工作**，**主要是用来处理之前并发处理阶段残留的更新对象**





> ### CMS 的缺点 及 解决方法

- 存在内存碎片：由于使用的是标记-清除，因此自然会产生内存碎片
- 存在浮动垃圾：比如在最后的并发清除阶段，清除的是之前标记的对象，此时用户进程也在运行，可能会产生新的垃圾，这些垃圾只能在下一次 GC 才能回收
- 重新标记 STW 的时间较长
- 会出现 **并发失败（concurrent mode failure）** 问题：比如 CMS 在并发标记过程中，用户线程也是在执行的，假如用户线程将对象直接放入老年代 或者 E区空间满了，执行 young GC，这时需要将 S区的对象放入到老年代，而这时老年代空间不足，这时候就会出现 concurrent mode failure，CMS 会退化为串行回收器，停止所有的用户线程，降低效率



解决方法：

- 内存碎片可以通过参数设置 几次 full GC 后采用标记-整理算法，消除掉内存碎片
- 浮动垃圾这个没法搞
- 重新标记需要 STW 长可以通过 在 重新标记前来一次 young GC，回收掉新生代的对象，这样可以减少遍历新生代对象
- 并发失败（concurrent mode failure）：设置预留的用户内存空间，比如设置为老年代内存占用 60% 时就进行 CMS，这样就留下 40% 给用户线程存放对象到老年代  (不能设置太大，如果设置 90%，那么就只剩下 10% 给用户线程了，可能不够用)



### 4、G1 回收器



> ### G1 出现的原因

JDK1.7 新加入 的 G1 回收器，按长远来看，可能会取代 CMS 回收器



在 G1 出现之前，有上面 3 中 GC 回收器，都有如下几个共同点：

- 新生代、老年代都是独立连续的内存空间，每次都需要提前分配好对应的空间

- 新生代使用 复制算法
- 老年代收集都必须扫描整个老年代

G1 使用的是分区思想（类似分页），分为了多个区，逻辑上有新生代和老年代的概念，但实际上物理上不存在这种区别，每个分区之前可能是新生代，下次就可能是老年代，因此不需要跟其他垃圾回收器一样，事先确定好新生代和老年代的空间范围

由于每个区分不是属于固定的哪个代的，当新生代内存空间不足时，可以将空闲的分区加入到新生代，即存储新生代对象

这样看来，就是**自由分配**，哪个代需要的空间多，就分配更多的分区，不需要的时候就拿回来给别的代使用





> ### 基于Region的堆内存布局



G1 将整个堆划分成了大小相等的多个区域 Region，分别为 E、S、O、H，即 伊甸区、幸存区、老年区、大对象区，**每个是连续范围的虚拟内存。**并且一个 Region 可以存放很多的对象

回收时以 Region 作为一个基本单位（跟内存管理的分页机制类似），这样就避免了内存碎片



G1 内部会自动跟踪每个 Region 中可以回收的对象大小和预估时间，在垃圾回收的时候，根据用户的期望值来判断回收 某个 Region 的价值，即回收对象是否多，并且大概需要多少回收时间，将每个 Region 根据价值进行排序，根据用户设置的期望时间来判断是否回收该 Region，以此达到每次都回收最大价值的 Region 的目的（有点类似死锁避免的银行家算法）



**注意，划分的是虚拟内存，它们的连续的地址，就是使用虚拟地址跟实际的物理地址进行映射，来达到好像空间是连续的的感觉，这样也就可以无需使用真正连续的物理空间来存储大对象**

![img](https://picb.zhimg.com/80/v2-f18e615acfc6b36e69194bd5736fe27b_720w.jpg)





> ### G1 回收过程

G1 的内存划分形式，决定了 G1 需要同时管理 新生代 和 老年代，根据回收区域的不同， G1 分为两种回收模式：

- young GC：只回收新生代

- mixed GC：回收所有新生代 和 部分老年代

  > 当 mixed GC 的回收速度跟不上用户线程请求的内存分配速度时，会暂停所有的用户线程，使用单线程进行 full GC

young GC 整个过程都会 STW，而 mixed 的初始标记阶段一般都伴随着 young GC，因此可以当作 mixed 的初始标记阶段是借用了 young GC 的这段 STW 时间



1、初始标记（STW）：表示所有 GC roots 直达的对象，借用的是 young GC 的 STW 时间

2、并发标记：跟用户线程并发执行，递归标记 GC roots 直连的对象，并且记录每个 Region 对象的存活数据，比如百分比(并发标记开始时会进行快照，用来恢复被用户线程修改的引用)

3、重新标记 (STW)：把并发线程时删除的引用通过快照进行处理

4、筛选回收（STW）统计每个 Region 的回收价值，根据用户指定的期望值来指定回收计划（类似银行家算法），后续根据回收计算，选择任意多个 Region 进行回收，先将有存活对象的 Region  中的存活对象复制到空的 Region 中，然后再清理掉整个旧的 Region，多个旧 Region 空间的对象可以拷贝到同一个 Region 中



> ### G1 的优缺点

优点：

- 不需要跟其他回收器一样每次 full GC 都需要扫描整个老年代，可以根据用户期望值进行 Region 回收，一次回收不需要针对全部内存，只需要先回收垃圾最多的 Region ，可以有效控制 STW 的时间
- Region 的堆内存划分使得 G1 不容易产生内存碎片，能够方便存储大对象
- 快照会把原本应该回收的对象也会当作是存活的



缺点：

每个 Region  维护一个 Rset，当引用很多的时候，记录的就变得更多，这样 Rset 占的内存空间就越多，甚至可能会占用整个堆的 20%，因此 G1 更适合在大内存的服务器上





### 5、并发标记的问题 - 浮动垃圾 和 对象消失



> ### 产生浮动垃圾

GC 使用的是 三色标记

黑色表示对象存活，并且它的所有引用都扫描过了

灰色表示对象存活，但是它的引用有的还没有扫描过

白色表示对象未扫描或者需要回收



如下面的动图，当我们处理完 6，将 7 设置为 灰色，但是这时候 用户将 6 的指针不再指向 7，而 7 由于已经被染成灰色，所以 GC 认为它还存活，所以继续将后面的引用染成黑色，这样的话，7 8 4 10 11 都不会被本次 GC 回收，这就产生了浮动垃圾

![img](https://user-gold-cdn.xitu.io/2020/3/1/17093d3d3ee999f4?imageslim)

> ### 什么是对象消失？

正常情况下是这样的

![img](https://user-gold-cdn.xitu.io/2020/2/23/1707265e1a8f8b43?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



但是，并发标记的过程中，用户可能会修改引用，使得尚未扫描到的存活对象扫描不到了，导致它被垃圾回收

比如下图：当  5 扫描完成后，接着是扫描 6 的，而本来 6 是指向 9 的，但是由于用户线程的修改了引用，导致 6 和 9 间的引用断开了，而 5 指向了 9，因为 5 已经标记为黑色，而 6 不存在与 9 的引用，这意味着 9 不会被标记，而最终只能是白色，而被回收掉，但实际上它是存活的对象

![img](https://user-gold-cdn.xitu.io/2020/2/23/1707266cd4d9d2fb?imageslim)







> ### 解决 对象消失 的方法

1、增量更新

**CMS 使用的就是增量更新，它规定，黑色对象一旦插入 白色对象后，它就会重新变成灰色**

这样的话，就会从这个灰色节点再次扫描一遍，就能够扫描到新插入的白色节点

比如上面就是由于 5 是黑色的，所以不会再去扫描 9，而 白色对象 9 插入后，它重新变成灰色，就会再次扫描

![img](https://user-gold-cdn.xitu.io/2020/2/23/170726cb3673541b?imageslim)



2、快照

**G1 使用的就是快照**

简单的说就是在 GC 的时候，该对象是存活的那么它就是存活的，因此需要提前给对象的引用关系做一次快照，当并发标记的过程中，有用户线程删除了引用的时候，导致某个对象没有被标记上，那么在并发标记结束后的重新标记阶段，会通过这个快照按照原来的引用关系再扫描发生改变的对象（注意：快照只恢复并发标记过程中用户线程删除的引用）

**恢复引用会导致浮动垃圾的存活，比如用户线程修改了引用，这个对象已经没有引用了，是需要回收的，但是按照快照又给它恢复成有引用的样子，导致它在此次 GC 中不会被回收**



![img](https://user-gold-cdn.xitu.io/2020/2/23/170726d12a19361a?imageslim)





## 4、什么是 full GC 和 young GC

full GC 一直以为是对 新生代 和 老年代进行 GC，没想到是 老年代 GC，当然还包括其他的一点，比如永久代

但是这里可以直接理解为 full GC 就是老年代 GC

young GC 就是新生代 GC



普通的分配是在新生代的 E 区的，如果空间不足，那么就会触发  young GC,这时候 E 区对象搬到 S 区，S 区对象可能搬到 老年代，对于大对象分配就是直接放到老年代

如果老年代空间不足以分配，那么就会触发 full GC





## 5、young GC 时新生代对象被老年代引用，怎么避免扫描整个老年代（跨代引用解决）



**跨代引用的假设：跨代引用相对于同代引用来说仅占极少数。所以，在对新生代单独做垃圾收集时，不应该为了少量的跨代引用而遍历整个老年代（搜索引用链）**



通过 卡表（card table）实现，用来记录 老年代对象 引用 新生代对象 的记录，防止在 young GC 时为了判断某个 新生代对象是否存活而去扫描整个老年代

将老年代空间分成若干张 512B 大小的卡（card），本质是 int 数组，由于新生代和老年代是在同一个堆中，只是逻辑上将内存分割为两部分，所以这个 card table 新生代也可见

通过卡表可以很快知道哪些新生代对象被老年代对象引用，比如 3 号位置就引用了新生代的某个对象，避免了全堆扫描

![CardTable](https://user-gold-cdn.xitu.io/2020/7/3/1731052eb999f1a7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

跨代引用指的是新生代对象引用老年代，或者 老年代对象引用新生代，前提是必须都是活着的

否则一个 GC roots 不可达的死亡的老年代对象引用新生代对象，这个也没什么意义

因此，跨代引用的前提必须是 引用别人的那个对象必须是 GC roots 可达的，以此来保证它引用的那个对象也是可达的，不会被垃圾回收



新生代的 GC roots 包含两部分：

- 新生代中满足 GC root 定义的对象
- 卡表中老年代引用的新生代对象



由于新生代的对象生命周期并不长，经过一次 young GC 后再进行 full GC，这样 full GC 扫描新生代时对象也很少，无需使用 card table，因为代价不大

所以老年代的 GC roots 包含两部分：

- 老生代中满足GC Root定义的对象
- 新生代活着的对象引用的老年代对象



> ### CMS 的 card table 和 G1 的 card table

在 G1 之前的垃圾回收器为了解决跨代问题，都是使用的 card table，比如 CMS 通过将老年代划分为大小相同的 card table 来记录新生代的引用的，而 CMS 不维护新生代对老年代的 car table，是因为新生代对象变化太快，维护起来开销大，引用需要经过发生改变，所以不需要



而 G1 使用的是 Region 的概念，淡化了新生代和老年代的分区概念，所以没有简单的使用这个方法，而是在 card table 的基础上加上了 Rset

- 它是将 每个 Region 分为多个 card (这点跟之前的老年代划分一样，不过这里是每个 Region 都进行划分)

- 然后为每个 Region 都分配一个 Rset，而这个 Rset 就是记录着其他的 Region 中的哪个 card 引用了当前的这个 Region
- Rset 本质上是一个 HashTable<key, int[]>，这个 key 是其他 Region 的地址，int[] 是 key 对应的 Region 的 card table，对应 card 上为 0 就表示 key 对应的 Region 的该位置的 card 引用了当前的 Region



比如下面这个，两个 int[] 数组是 Region2 的，分别代表 Region1 和 Region3 对 Region2 的引用

比如 第一个 int[] 数组中，2 号位置 和 4 号位置为 1，表示 Region1 的第 2 个 card 和 第 4 个 card 存在对 Region2 的引用

 第二个 int[] 数组中，1 号位置 和 4 号位置为 1，表示 Region3 的第 1 个 card 和 第 4 个 card 存在对 Region2 的引用

*![image.png](https://pic.leetcode-cn.com/1599967286-lhDVis-image.png)*

这样 GC 的时候可以直接获取 Region 的 Rset 判断该 Region 是否还有对象存活
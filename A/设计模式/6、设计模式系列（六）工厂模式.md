# 工厂模式



## 1、简单工厂模式

简单工厂模式它没有区分什么产品，它是将所有产品的生成逻辑都放到一个工厂中

优点是简单，缺点是如果新增一个产品的话，那么就需要去修改对应的代码



产品类：

```java
public class A{

}

public class B{

}

public class C{
    
}
```



工厂类：

```java
public class Factory{
	
    public Object create(int type){
        switch(type){
            case 1:
                return createA();
            case 2:
                return createB();
            default:
                return createC();
        }
    }
    
    public A createA(){
        A a = new A();
        /*
        进行处理，比如配置 XML 信息之类的
        一大堆事
        */
        return a;
    }
    public B createB(){
        B b = new B();
        /*
        进行处理，比如配置 XML 信息之类的
        一大堆事
        */
        return b;
    }
    public C createC(){
        C c = new C();
        /*
        进行处理，比如配置 XML 信息之类的
        一大堆事
        */
        return c;
    }
}
```



当然，如果需要创建的产品是单例的话，那么使用一个 Map 将创建的产品存储起来，下次直接获取

我们可以看出，创建产品的逻辑全部堆积在一个工厂中，如果每个产品创建的逻辑相同的话还可以抽取出来，如果都不相同，那么整个工厂类看起来就相当复杂

如果新增一个产品，那么就需要进入到工厂类中修改代码，这显然是不可行的

按照习惯我们一般是希望将不同产品的创建方法抽取出来，形成一个新的类，这样创建这个产品的逻辑就很清晰明了，不会跟别的产品的创建方法堆积在一起，这样看起来就很清爽

当出现这种想法的时候，就意味着进入了工厂方法模式



## 2、工厂方法模式

工厂方法模式是将各个产品的创建方法都抽取到不同的类中，而这个类就是对应产品的工厂

即一个产品一个工厂



产品类：

```java
public class A{

}

public class B{

}

public class C{
    
}
```



工厂类：

```java
public class AFactory{

    public A create(){
        A a = new A();
        /*
        进行处理，比如配置 XML 信息之类的
        一大堆事
        */
        return a;
    } 
}
public class BFactory{

    public B create(){
        B b = new B();
        /*
        进行处理，比如配置 XML 信息之类的
        一大堆事
        */
        return b;
    }
}
public class CFactory{

    public C create(){
        C c = new C();
        /*
        进行处理，比如配置 XML 信息之类的
        一大堆事
        */
        return c;
    }
}
```



抽取出来后每个类的创建逻辑都很明了，要修改哪个产品的生产逻辑就去对应的工厂上看

但是当新增一个产品的时候，就需要创建对应的一个工厂类，产品一多，工厂类也同样增多

其实简单讲工厂方法模式就是当我们使用简单工厂模式的时候发现这个工厂中堆积了太多的产品创建逻辑，看着太繁杂了，不好维护，而且后续可能还会增加产品，因此索性将各个产品的创建逻辑抽取出来放到各自的一个类中，这个类就是对应产品的工厂
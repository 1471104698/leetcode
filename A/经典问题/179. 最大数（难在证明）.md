# [179. 最大数（难在证明）](https://leetcode-cn.com/problems/largest-number/)

*![image.png](https://pic.leetcode-cn.com/6d98502409cf71656e7fcea7fea5f66bf05b1f33d404aaa320167dd5f1ea0997-image.png)*

## 题意描述

给定一个 `int` 数组，要求经过排列后按照顺序组成的整数的所有排列中最大的

比如 【9,962,96】，它经过排列后最大的是 【962,96,9】，即 962969，没有比它更大的排列

**由于可能最终拼接出来的数非常大，无法用 int 或者 long 表示，因此返回字符串**



## **示例 1:**

```java
输入: [10,2]
输出: 210
```



## **示例 2:**

```java
输入: [3,30,34,5,9]
输出: 9534330
```



## 方法①、转换字符串后排序

### 实现思路

我们将数组转换为字符串数组，然后通过自定义排序 `(a + b).compareTo(b + a)`来对数组进行排序

这样排序过后的顺序就是最大数了

排序的比较主要是通过两个字符串 a 和 b 进行拼接，它们有两种拼接方式：a + b 和 b + a

我们选取能够拼接处较大值的 字符串 放在前面，比如 a + b > b + a，那么将 a 放在 b 前面



#### 1、难点

这道题的难点不在于代码，而在于怎么验证按照这个排序比较规则出来的就是最大数，为什么不会存在更大的数

要知道为什么，我们需要证明 **传递性 和 算法的正确性**



#### 2、传递性

假设存在 s1，s2，s3 三个字符串

它们的数值分别为 m1，m2，m3

它们的长度分别为 L1，L2，L3（长度是看作 10 的幂，比如 9 的长度为 10^1，99 的长度为 10^2）

假设存在 

**①、s1 + s2 >= s2 + s1** 

**②、s2 + s3 >= s3 + s2** 

①式可转换为 m1 * L2 + m2 >= m2 * L1 + m1

​	**（转换的过程：假设 a = "99", b = "888"，那么 a + b = "99888" = 99 * 10^3 + 888）**

​	进行移位变成 m1 * (L2 - 1) >= m2 * (L1 - 1)

②式可转换为 m2 * L3 + m3 >= m3 * L2 + m2

​	进行移位变成 m2 * (L3 - 1) >= m3 * (L2 - 1)

由于 ①、② 左右两边都为非负数，因此左右两边分别相乘，可以转换成：

③、**m1 * m2 * (L2 - 1)  *  (L3 - 1) >= m2 * m3 *  (L1 - 1)  *  (L2 - 1)**

左右两边 m2 同时化简，变成 **m1 *  (L2 - 1)  *  (L3 - 1) >=  m3 *  (L1 - 1)  *  (L2 - 1)**

由于 L2 >=  10^0 = 1（即 s2 可以为空串）

- L2 == 1 时，那么 ③ 式为 0 >= 0
- L2 != 1 时，那么 ③ 式为 m1 * (L3 - 1) >= m3 * (L1 - 1)

**综上，无论 L2 取何值，都存在 m1 * (L3 - 1) >= m3 * (L1 - 1)，**

**即 m1 * L3  + m3 >= m3 * L1 + m1， 亦即 s1 + s3 >= s3 + s1，传递性成立**



#### 3、算法正确性

假设存在一个数组 `nums` 存在一个最大数，它的排列不满足上述的传递性，即至少存在两个数不满足

假设为 s1 和 s2，如果按照传递性，s1 + s2 > s2 + s1，那么得到的排列应该是 S1 = .... s1s2....（.... 表示其他的字符排列）

但是最大数不满足传递性，即最大数是 S2 = .... s2s1 ....（除了 s1 和 s2 不满足传递性，其他都满足）

那么我们可以看出，因为存在 s1 + s2 > s2 + s1，所以 s1s2 是大于 s2s1 的，因此在其他字符串位置不变的情况下， S1 > S2，那么这跟假设相矛盾

**综上，满足传递性的情况下得到的数就是最大数**



### 实现代码

```java
class Solution {
    public String largestNumber(int[] nums) {
        String[] strs = new String[nums.length];
        for(int i = 0; i < nums.length; i++){
            strs[i] = String.valueOf(nums[i]);
        }
        Arrays.sort(strs, (a, b) -> (b + a).compareTo(a + b));
        StringBuilder sb = new StringBuilder();
        for(String str : strs){
            sb.append(str);
        }
        String str = sb.toString();
        return str.charAt(0) == '0' ? "0" : str;
    }
}
```


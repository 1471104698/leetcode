给你一个整数 num，请你找出同时满足下面全部要求的两个整数：

两数乘积等于  num + 1 或 num + 2
以绝对差进行度量，两数大小最接近
你可以按任意顺序返回这两个整数。

 

示例 1：

输入：num = 8
输出：[3,3]
解释：对于 num + 1 = 9，最接近的两个因数是 3 & 3；对于 num + 2 = 10, 最接近的两个因数是 2 & 5，因此返回 3 & 3 。
示例 2：

输入：num = 123
输出：[5,25]
示例 3：

输入：num = 999
输出：[40,25]
 

提示：

1 <= num <= 10^9


class Solution {
    public int[] closestDivisors(int num) {
        /*
            找到 num + 2 的开方 Math.sqrt(num + 2)
            因为最接近的只能是 x * x = num + 2
            我们从 x 开始找，找到 1，最先遇到的就是结果
        */
        
        int x = (int)Math.sqrt(num + 2);

        for(; x >= 1; x--){
            /*
            我们先求 num + 1 的情况
            其实对于 [2, x] 求哪个都无所谓，因为对于 x 不可能存在另一个 y 它们的乘积同时满足 num + 1 又满足 num + 2 的组合
            那么最先找到哪个就是哪个

            但是如果 [2, x] 都没有，那么对于 1 来说是必定存在的，那么我们需要返回最小的一个，因此先遍历 num + 1
            */
            if((num + 1) % x == 0){
                return new int[]{x, (num + 1) / x};
            }
            if((num + 2) % x == 0){
                return new int[]{x, (num + 2) / x};
            }
        }
        return new int[0];
    }
}
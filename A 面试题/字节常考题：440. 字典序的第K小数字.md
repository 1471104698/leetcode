# [字节常考题：440. 字典序的第K小数字](https://leetcode-cn.com/problems/k-th-smallest-in-lexicographical-order/)

*![image.png](https://pic.leetcode-cn.com/55d14fa47859c2d4f3889ad5c3593e9d5ae5b8b652273ab9d77f7eb7d3cc39ad-image.png)*

```java
给定整数 n 和 k，找到 1 到 n 中字典序第 k 小的数字。

注意：1 ≤ k ≤ n ≤ 109。
```



## **示例 :**

```java
输入:
n: 13   k: 2

输出:
10

解释:
字典序的排列是 [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9]，所以第二小的数字是 10。
```





## 方法①、优先队列（超时）



### 实现思路

维护一个大顶堆
直接将 [1, n] 转换为字符串添加进优先队列，维护一个 k 个大小的大顶堆
最终返回堆顶元素



### 实现代码

```java
class Solution {
    public int findKthNumber(int n, int k) {
        PriorityQueue<String> maxHeap = new PriorityQueue<>((a, b) -> b.compareTo(a));
        for(int i = 1; i <= n; i++){
            maxHeap.add(String.valueOf(i));
            if(maxHeap.size() > k){
                maxHeap.poll();
            }
        }
        return Integer.parseInt(maxHeap.peek());
    }
}
```





## 方法②、十叉树



### 实现思路



#### 十叉树建模：

<img src="https://pic.leetcode-cn.com/2d29fc99e0e23eac3bd5a25997ffc111694e1024d24a62677decb89e15f6dfce-file_1568710778725" style="zoom:150%;" />

![image-20200314171628883.png](https://pic.leetcode-cn.com/8bb3eab39d780d4bb3f4962ca805a3311f3acc46d3bbd0a7e3f7e057a706cb19-image-20200314171628883.png)



本题跟 386. 字典序排数 差不多，不过 386 题的数据量较小，只有 5,000,000，即 1e6，因此可以直接添加排序

而本题数据量最大为 1e9

采用 方法① 的思路，将 [1, n] 全部添加排序，再求出第 k 个的话肯定超时

因此，我们需要跟 60. 第k个排列 一样，不是求出所有的，而是通过技巧直接定位到 第 k 个



#### 1、确定某个前缀下的子节点数：

这里说下，前缀就是指比如 1100，它的前缀有 1，11，110

我们求取某个前缀下的子节点个数，意思就是 比如 求取 10 为前缀的子节点的个数（它子节点有 101，102，1001 之类的）

怎么获取某个前缀的子节点个数？

可以用过下一个前缀的起点 - 当前前缀的起点（注意：起点不是子节点）

比如：

我们求取 1 为前缀的子节点的个数

那么存在以下代码

```java
public int getCount(int prefix){
    int cur = prefix;
    int next = prefix + 1;
    int c = 0;
    while(cur <= n){
    /*
    	最开始 cur = 1，next = 2
    	那么该层以 1 为前缀的子节点个数为 2 - 1 = 1
    	然后 cur * 10 ，next * 10， 
    	cur = 10, next = 20
    	那么该层以 1 为前缀的子节点的个数为 20 - 10 = 10
    	然后 cur * 10 ，next * 10， 
    	cur = 100, next = 200
    	那么该层以 1 为前缀的子节点的个数为 200 - 100 = 100
    	
    	直到 cur > n 位置停止循环
    	
    	最开始 cur = 12，next = 13
    	那么该层以 12 为前缀的子节点个数为 13 - 12 = 1
    	然后 cur * 10 ，next * 10， 
    	cur = 120, next = 130
    	那么该层以 12 为前缀的子节点的个数为 130 - 120 = 10
    	然后 cur * 10 ，next * 10， 
    	cur = 1200, next = 1300
    	那么该层以 1 为前缀的子节点的个数为 1300 - 1200 = 100
    */
        c += next - cur;
        next *= 10;
        cur *= 10;
    }
    return c;0
}
```

但上面存在问题，我们上面求取的是每层以 1 作为前缀的子节点的个数，是一层一层求的，

比如 第三层，最小的数为 100，最大的数为 199，那么我们通过 200 - 100，可以得到这 100 个数

但是，如果 next 超过了 n 呢？比如 cur = 100, next = 200, n = 150，实际上只有 n - cur  = 100 - 150 这 50 个数

但是如果使用 next - cur = 200 - 100 的话，就有 100 个数，因此我们需要在 next 和 n 之间取最小值 Math.min(next, n + 1);

注意，这里是 n + 1，而不是 n，因为如果是 n 的话，n - 100 表示不包含 n 这个数，就跟上面的 200 - 100 不包含 200 这个数

因此我们需要使用 n + 1 - cur 才会包含 n 这个数

```java
public int getCount(int prefix){
    int cur = prefix;
    int next = prefix + 1;
    int c = 0;
    while(cur <= n){
        c += Math.min(next, n + 1) - cur;
        next *= 10;
        cur *= 10;
    }
    return c;
}
```



#### 2、确定 k 在哪个前缀下

如果 prefix 的子节点个数为 count 

存在 count <= k，那么不在当前前缀下，那么向右走，进入下一个前缀  prefix++（这里 count == k 放在这里是因为当前前缀 + count 后就是下一个前缀）

存在 count > k，那么在当前前缀下，向下走，缩小范围，prefix *= 10



比如 n = 10, k = 2

初始化条件 prefix = 1, count = 1

prefix 表示目前处于的前缀， count 表示 当前已经查找了前 count 个字典序最小的数

获取前缀为 1 的节点个数 c =  2（即 1 和 10），c + count < k，因此 k 不在当前前缀 1 里，prefix++，prefix 变成 2，同时查找了的数 增加 c 个

获取前缀为 2 的节点个数 c = 1（即 2）, 由于 c + count == k，即 c >= k，那么 k 在当前前缀里，有可能是当前前缀本身 或者 是它的子节点，那么我们访问节点数 +1 后， count == k 的话，那么就是当前节点本身，如果不是，那么往下一层找， prefix *= 10，count +1 表示访问过当前前缀

```java
int prefix = 1;
//目前 prefix 属于 第 count 个最小字典序，我们需要找到第 k 个
int count = 1;
while(count < k){
    int c = getCount(prefix, n);
    if(c + count <= k){
        prefix++;
        count += c;
    }else{
        count++;
        prefix *= 10;
    }
}
return prefix;
```



### 实现代码

```java
class Solution {
    public int findKthNumber(int n, int k) {

        int prefix = 1;
        //目前 prefix 属于 第 count 个最小字典序，我们需要找到第 k 个
        int count = 1;
        while(count < k){
            int c = getCount(prefix, n);
            if(c + count <= k){
                prefix++;
                count += c;
            }else{
                count++;
                prefix *= 10;
            }
        }
        return prefix;
    }

    public int getCount(int prefix, int n){
        long cur = prefix;
        long next = prefix + 1;
        int c = 0;
        while(cur <= n){
            c += Math.min(next, n + 1) - cur;
            next *= 10;
            cur *= 10;
        }
        return c;
    }
}
```


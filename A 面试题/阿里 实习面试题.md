# 阿里 实习面试题

```java
之前在面试阿里实习的时候遇到了一道题没有能做出来，虽然感觉也没有特别难，但是仍然苦于没有思路，故想和大家讨论一下。
大概意思就是给定一个mXn的矩阵，矩阵里面都是非负整数，那么现在要从蓝色区域出发（矩阵上边的矩阵外的区域），
要到达红色区域，请问这个过程中的路径和最小是多少？
你可以从第一行任意一个起点出发，行走的时候可以 往下走，往左走，往右走。求最小的路径和。
//矩阵里都是非负数

作者：tommy
链接：https://leetcode-cn.com/circle/discuss/BNvWBP/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

![image.png](https://pic.leetcode-cn.com/8e9cedf03c8f88270da6a6f4255553afef2656d9563503987d92d2f7e9d06c76-image.png)



## 错误方法



### 错误思路

```java
最开始感觉就是简单的 dp，每个位置都可以从上边、左边、右边过来，因此我们只要取 3 个方向最小值即可
然后 dp 完成，直接从最后一行取最小值
```



### 错误代码

```java
class Solution {
    public int minPath(int[][] mat) {
        if(mat.length == 0 || mat[0].length == 0){
            return 0;
        }
        int rlen = mat.length;
        int llen = mat[0].length;
        int[][] dp = new int[rlen][llen];
        //初始化第一行
        System.arraycopy(mat[0], 0, dp[0], 0, llen);
        for(int i = 1; i < rlen; i++){
            for(int j = 0; j < llen; j++){
                if(j == 0){
                    //只能从上或者右边过来
                    dp[i][j] = Math.min(dp[i - 1][j], dp[i][j + 1]);
                }else if(j == llen - 1){
                    //只能从上或者左边过来
                    dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]);
                }else{
                    //上边 左右边
                    dp[i][j] = Math.min(dp[i - 1][j], Math.min(dp[i][j - 1], dp[i][j + 1]));
                }
                dp[i][j] += mat[i][j];
            }
        }
        //求最小值
        int min = 10000000;
        for(int num : dp[rlen - 1]){
            min = Math.min(min, num);
        }
        return min;
    }
}
```



### 错误原因

```java
上面那个方法错误的原因在于：我们没有处理右边方向
比如：
[7, 5, 1, 3],
[6, 3, 2, 11],
[6, 4, 5, 12],
[7, 5, 15, 16]
当我们遍历完第一行 [7, 5, 1, 3] 的时候
往下继续遍历，[6, 3, 2, 11]
对于 第一个元素 6，我们可以从上面和右边过来，dp[i][j] = Math.min(dp[i - 1][j], dp[i][j + 1])
但是，这里忽略了个问题，即 dp[i][j + 1] 还没有被处理过，即仍然是默认值 0，这就导致了结果出错，因为我们右边还没有进行处理
即我们没有处理 到达 6 右边的元素 3 的最短路径，因此它是默认值 0
```



## 正确方法

### 实现思路

```java
正确是思路应该是：
我们从左往右遍历一遍，每次只走上边和左边，这样对于 dp[i][j] 来说，dp[i][j - 1] 是已经处理过的了
然后我们再从右往左遍历一遍，每次只走右边，这样对于 dp[i][j] 来说，dp[i][j + 1] 是已经处理过的了
三者之间取最小值即可
```



### 实现代码

```java
class Solution {
    public int minPath(int[][] mat) {
        if(mat.length == 0 || mat[0].length == 0){
            return 0;
        }
        int rlen = mat.length;
        int llen = mat[0].length;
        int[][] dp = new int[rlen][llen];
        //初始化第一行
        System.arraycopy(mat[0], 0, dp[0], 0, llen);
        for(int i = 1; i < rlen; i++){
            //从左到右，只看从左和从上
            for(int j = 0; j < llen; j++){
                if(j == 0){
                    //只能从上过来
                    dp[i][j] = dp[i - 1][j] + mat[i][j];
                }else{
                    //上边 和 左
                    dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + mat[i][j];
                }
            }
            //从右到左，只看从右
            for(int j = llen - 1; j >= 0; j--){
                if(j != llen - 1){
                    //右边
                    dp[i][j] = Math.min(dp[i][j], dp[i][j + 1] + mat[i][j]);
                }
            }
        }
        //求最小值
        int min = Integer.MAX_VALUE;
        for(int num : dp[rlen - 1]){
            min = Math.min(min, num);
        }
        return min;
    }
}
```


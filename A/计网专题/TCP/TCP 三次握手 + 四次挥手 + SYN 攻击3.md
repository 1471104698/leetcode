# TCP 三次握手 + 四次挥手 + SYN 攻击3



## 1、三次握手

### 1、三次握手过程

- 第一次握手：客户端随机初始化一个序号，记作 `client_isn`，将它放在 TCP 报文的序列号部分

  然后将 SYN 标志位  置为 1，发送给服务端**（该报文不包含应用层数据）**

  

- 第二次握手：服务端接收到客户端的报文，然后随机初始化一个序号，记作 `server_isn`，将它放在 TCP 报文的序列号部分，再将从客户端报文获取的 `client_isn` + 1 放到 确认号 上，然后将 SYN、ACK 标志位      置 1，发送给客户端**（该报文不包含应用层数据）**

- 第三次握手：客户端接收到服务端的报文，然后将从服务端报文获取的 `server_isn` + 1 放到 确认号 上，然后将 ACK 标志位  置 1，发送给客户端，这次可以将数据放到报文顺便传输给服务端**（该报文包含应用层数据）**

**第一、二次握手没有传输数据，第三次握手可以传输数据**



![img](https://pic1.zhimg.com/80/v2-c2602875a99f219451bb5d9fe087812c_720w.jpg)





### 2、为什么是三次握手？不是两次、四次？

有 3 个原因：

- 三次握手才可以阻止历史连接（主要原因）
- 三次握手才可以同步双方的初始序列号
- 三次握手才可以避免资源浪费
- 

> ### 原因①：避免历史连接

发送方 发送 SYN 请求建立建立，可能由于网络拥堵原因，这个 SYN 和 迟迟到不了接收方 或者 接收方的 SYN + ACK 迟迟到不了 发送方，那么由于超时重发机制，发送方会再次发送 SYN

如果这时候最先的一个 SYN 到达了接收方 或者 接收方的 SYN + ACK 到达了 发送方，后续继续进行握手

而后面超时重发的第一次握手的 SYN 到达 接收方后，接收方会继续发送一个 SYN + ACK 给发送方

而这一个 SYN 连接实际上已经是不需要的了，因为发送方需要建立的连接已经建立了，这个 SYN 就相当于是历史连接了



如果只有两次握手，接收方对这些历史连接的 SYN 发送了 SYN + ACK 后，发送方接收到了，根据 seq 判断了这是历史连接，但是它无法告知接收方这是历史连接，因此接收方会将这些历史连接都放入到 accept 队列中，**这样就是造成了重复连接，导致了资源浪费（原因③）**

而如果是三次握手，那么就可以对这个历史连接进行处理了

- 发送方根据 seq 判断是历史连接，那么发送 RST 包给接收方中断这次连接
- 如果不是，那么发送 ACK 包给接收方，告知接收方没问题了，可以进行数据传输了



> ### 原因②：同步双方的初始序列号

在最上面 0、TCP 的头部讲了 序列号的作用，传输的序列号就是基于初始序列号来的

**只有三次握手，才能确保双方的初始序列号进行同步，方便后续传输**



**两次握手** 只能确保服务端同步了客户端的初始序列号，却不能确保客户端同步了服务端的初始序列号，因为客户端没有发送 ACK 给服务端



> ### 原因③：避免重复连接造成资源浪费

跟原因 ① 具有密不可分的联系

就是由于两次握手，无法解决历史连接问题，会造成重复连接，导致资源浪费



**综上：**

- 不使用两次握手的原因：无法避免历史连接，无法确保双方同步初始序列号，造成资源浪费

- 不使用四次握手的原因：三次已经可以确保可靠连接了，无需更多的通信次数

**即上面的原因都是针对 两次握手 提出的**





## 2、四次挥手



### 1、四次挥手过程

客户端和服务端都可以主动断开连接



现在假设：

- 客户端要断开连接，那么它会发送一个 FIN = 1 的报文给服务端，告知要关闭连接
- 服务端收到报文后，会发送一个 ACK 报文给客户端，表示自己收到了
- 客户端收到 ACK 报文后，会进入等待状态
- 等到服务端处理完数据后，会发送一个 FIN 报文给客户端
- 客户端接收到后，会发送一个 ACK 报文给服务端，然后进入 TIME_WAIT 状态
- 这时，服务端接收到 ACK 报文后，会关闭连接，而 客户端还在 等待
- 过了 2MSL 后，客户端关闭连接

一个来回都需要一个 FIN 和 ACK，称作四次挥手

（FIN 为正常终止连接，RST 为异常中止连接，比如上面的历史连接）

**需要注意的是**：谁先发起的关闭连接谁就有 TIME_WAIT 状态



![img](https://picb.zhimg.com/80/v2-083462b035aeaa02bbf10f67ab78f51f_720w.jpg)





### 2、为什么不能是三次挥手？

客户端发送 FIN 给服务端，表示所有数据都传输完毕了，可以关闭连接了，但仍然能够接收消息

服务端接收到 FIN 后，会发送一个 ACK ，但可能还有数据没有处理完，因此需要等到数据处理完毕后，才发送 FIN 给客户端，告知客户端数据处理完毕，可以关闭连接

对比三次挥手，因为服务端中间可能存在数据没有处理，因此 ACK 和 FIN 需要分开发送，所以需要四次挥手





## 3、SYN 攻击（攻击半连接队列）

**服务端存在两个队列，一个是 SYN 连接队列（半连接队列），一个是 Accept 队列（连接队列）**

SYN 队列是存储第一次握手接收到的客户端的 SYN 请求，将这个请求放到 SYN 队列中

Accept 队列是 第三次握手，服务端收到客户端的 ACK 后，将连接从 SYN 队列移除，放到 Accept 队列 中，然后应用程序通过调用 `accept() ` 来获取 Accept 队列 中的连接



正常流程：

- 当服务端接收到客户端的 SYN 报文时，会将其加入到内核的「 SYN 队列」；
- 接着发送 SYN + ACK 给客户端，等待客户端回应 ACK 报文；
- 服务端接收到 ACK 报文后，从「 SYN 队列」移除放入到「 Accept 队列」；
- 应用通过调用 `accpet()` socket 接口，从「 Accept 队列」取出的连接。

![1597974574685](C:\Users\蒜头王八\AppData\Roaming\Typora\typora-user-images\1597974574685.png)



SYN 攻击是针对三次握手的，假设攻击者短时间伪造不同 IP 地址的`SYN` 报文，服务端每接收到一个 SYN 报文后，会将这个连接放到 SYN 队列

当 服务端 发送 ACK + SYN 却没有收到 ACK ，那么这个连接会一直待在 SYN 队列，导致队列被塞满，无法响应正常用户的连接请求

